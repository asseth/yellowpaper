\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{url}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}
\usepackage[utf8x]{inputenc}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%

\definecolor{lightyellow}{rgb}{1,0.98,0.9}
\definecolor{lightpink}{rgb}{1,0.94,0.95}

\newcommand{\firsthomesteadblock}{\ensuremath{N_H}}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title{Ethereum: Un registre de transactions généraliste, sécurisé et décentralisé\\ {\smaller \textbf{révision EIP-150}}}

\author{
    Dr. Gavin Wood\\
    Fondateur, Ethereum \& Ethcore\\
    gavin@ethcore.io
}
\begin{document}

\pagecolor{lightyellow}
%\pagecolor{lightpink}

\begin{abstract}
Le paradigme de la blockchain, lorsqu'il est couplé à un mécanisme de transaction sécurisé par la cryptographie, a prouvé son utilité non seulement avec Bitcoin mais aussi dans de nombreux de projets. Chacun de ces projets peut être vu comme une simple application basée sur une ressource de calcul décentralisée mais unitaire. Nous pouvons appeler ce paradigme une machine transactionnelle unique à état partagé.

Ethereum implémente ce paradigme de façon généraliste. De plus, Ethereum permet une pluralité de telles ressources, chacune possédant un état distinct et un code fonctionnel, mais néanmoins susceptibles d'interagir via un framework d'échange de messages. Nous discuterons de sa conception, des problèmes d'implémentation, des opportunités que cela fournit et des obstacles que nous anticipons.
\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}

\section{Introduction}\label{sec:introduction}

Internet étant présent dans les plupart des endroits de la planète, la transmission de l'information est globalement devenue incroyablement bon marché. Les innovations technologiques telles que Bitcoin ont démontré, par le pouvoir d'un mécanisme de consensus et de respect volontaire d'un contrat social, qu'il était possible d'utiliser Internet pour créer un système décentralisé de transfert de valeurs, partagé à travers le monde et quasiment gratuit à utiliser. Ce système peut être décrit comme une version très spécifique d'une machine a états basée sur des transactions et sécurisée par la cryptographie. Des systèmes de suivi tels que Namecoin ont adapté ce système original d' ``application monétaire’‘  à d'autres applications quoiqu’elles furent plutôt simples.

Ethereum est un projet qui cherche à créer une version généraliste de cette technologie; technologie sur laquelle tous les concepts de machine transactionnelle à états pourraient être construits. De plus Ethereum a pour but de fournir au développeur final un système intégré de bout en bout afin de construire des logiciels basés sur un paradigme de calcul jusque-là inexploré : un framework de confiance pour la messagerie, le calcul et les objets.

\subsection{Principes directeurs} \label{ch:driving}

Ce projet a beaucoup d’objectifs; un des principaux est de faciliter les transactions entre deux individus consentants qui n'auraient sans cela aucun moyen de se faire confiance l'un à l'autre. Cela peut être dû à une séparation géographique, une difficulté d'interaction, ou peut-être à l'incompatibilité, l'incompétence, la réticence, le coût, l'incertitude, la gêne ou encore la corruption des systèmes légaux existants. En définissant un système de changement d'état à travers un langage riche et non ambigu, et de plus en architecturant un système tel que nous pouvons raisonnablement en attendre qu'un accord soit assuré de manière autonome, nous pouvons fournir un moyen à cette fin.

Les opérations dans le système proposé pourraient avoir beaucoup d'attributs qui souvent n'existent pas dans le monde réel. L'incorruptibilité d'appréciation, souvent difficile à trouver, est naturelle lorsqu'elle vient d'un interpréteur algorithmique désintéressé. La transparence, ou capacité à voir exactement comment un état ou un jugement s'est produit au travers des journaux et règles d'une transaction ou des codes d'instructions, n'est jamais parfaitement atteinte dans les systèmes basés sur l'humain, parce que le langage naturel est nécessairement vague, que de l'information manque souvent et que des préjudices antérieurs sont difficiles à démêler.

De manière générale, je souhaite fournir un système dans lequel les utilisateurs peuvent être sûrs que peu importe avec quels autres individus, systèmes ou organisations ils interagissent, ils peuvent le faire en ayant une confiance absolue dans les résultats possibles et les règles guidant l'obtention de ces résultats.

\subsection{Travaux antérieurs} \label{ch:previous}

\cite{buterin2013ethereum} a proposé initialement le noyau de ce travail fin Novembre 2013. Bien qu'elle ait maintenant évolué sur de nombreux points, la fonctionnalité clé d'une blockchain possédant un langage Turing-complet et une capacité illimitée de stockage inter-transaction fonctionnelle demeure inchangée.

\cite{dwork92pricingvia} a fourni le premier travail d'usage de la preuve cryptographique d’effort de calcul (``proof-of-work, ou preuve de travail'') ayant pour but de transmettre un signal de valeur à travers Internet. Le signal de valeur était utilisé ici comme un mécanisme de dissuasion de spam plutôt que comme une forme de monnaie, mais a démontré de manière décisive le potentiel d'un canal de données basique à porter un \textit{signal économique fort}, autorisant un récepteur à faire une vérification physique sans avoir à s'en remettre à une forme de \textit{confiance}. \cite{back2002hashcash} a plus tard produit un système dans la même veine.

Le premier exemple d'utilisation de la preuve de travail en tant que signal économique fort pour sécuriser une monnaie a été utilisé par \cite{vishnumurthy03karma:a}. Dans cet exemple, le jeton était utilisé pour contrôler l'échange de fichiers en pair to pair et permettait aux ``consommateurs'' de procéder à des micro-paiements aux ``fournisseurs'' pour leurs services. Le modèle de sécurité apporté par la preuve de travail était augmenté avec les signatures digitales et un registre dans le but de protéger l'historique des enregistrements contre la corruption, et contre des actes malicieux tels que la falsification des paiements ou les plaintes abusives. Cinq ans plus tard, \cite{nakamoto2008bitcoin} introduisit un autre jeton de valeur basé sur une preuve de travail sécurisée avec une portée plus large. Le fruit de ce projet, Bitcoin, est devenu le premier registre global décentralisé de transactions à être largement adopté.

D'autres projets construits à partir de Bitcoin ont réussi; les altcoins, ou monnaies alternatives, ont introduit de nombreuses autres monnaies en modifiant le protocole. Quelques-unes des plus connues sont Litecoin et Primecoin, citées par \cite{sprankel2013technical}. D'autres projets ont su prendre la valeur essentielle contenue dans le mécanisme du protocole et de la réappliquer; \cite{aron2012bitcoin} a décrit, par exemple, du projet Namecoin qui a pour but de fournir un système de résolution de nom décentralisé.

D'autres projets visent toujours à construire par-dessus le réseau Bitcoin lui-même, tirant profit de l’importante valeur placée dans le système et de la très grande puissance de calcul destinée au mécanisme de consensus. Le projet Mastercoin, proposé initialement par \cite{mastercoin2013willett}, vise à construire un protocole plus riche, impliquant beaucoup de fonctionnalités de haut niveau par-dessus le protocole Bitcoin à travers l'utilisation d'un grand nombre de parties auxiliaires au protocole de base. Le projet Colored Coins, proposé par \cite{colouredcoins2012rosenfeld}, a une stratégie similaire mais plus simple, agrémentant les règles d'une transaction afin de casser la fongibilité de la monnaie de base Bitcoin et autoriser la création  et le suivi des jetons à travers un ``chroma-wallet'', une surcouche logicielle fonctionnant avec le protocole.

Des travaux supplémentaires ont été effectués avec pour idée d'écarter les fondements de la décentralisation; Ripple, décrit par \cite{boutellier2014pirates}, a cherché à créer un système fédéré pour l'échange de devises constituant effectivement un nouveau système de compensation financière. Cela a démontré que de gros gains d'efficience peuvent être faits si le principe de la décentralisation est rejeté.

Antérieurement un travail sur les smart contracts a été effectué par \cite{szabo1997formalizing} et \cite{miller1997future}. Autour des années 90 il est devenu clair que la résolution par un algorithmique des accords entre humains pourrait devenir une force significative dans la coopération. Bien qu'aucun système spécifique n'ait été proposé pour implémenter un tel système, il a été présumé que le futur du droit soit profondément affecté par ce genre de résolution. Dans cette optique, Ethereum peut être vu comme une implémentation généraliste d'un tel système de \textit{droit cryptographique}.

%E language?

\section{Le paradigme de la blockchain} \label{ch:overview}

Ethereum, pris dans son ensemble, peut être vu comme une machine à état basée sur des transactions: nous commençons avec un état originel, et exécutons des transactions de manière incrémentale pour le transformer en un état final. C'est cet état final que nous acceptons comme la ``version'' canonique du monde d'Ethereum. L'état peut inclure des informations telles que les soldes de comptes, la réputation, des accords de confiance, des données portant sur l'information du monde physique; en résumé, tout ce qui peut actuellement être représenté par un ordinateur est admissible. Les transactions représentent ainsi une passerelle valide entre deux états; l’aspect `valide' est importante---il existe beaucoup plus de changements d'état invalides que de changements d'état valides. Les changements d'état invalides pourraient par exemple être des choses telles que réduire le solde d'un compte sans compenser ailleurs d'un montant équivalent. Un changement d'état valide est un changement produit par le truchement d’une transaction. Formellement: 
\begin{equation}
\boldsymbol{\sigma}_{t+1} \equiv \Upsilon(\boldsymbol{\sigma}_t, T)
\end{equation}


où $\Upsilon$ est la fonction de transition d'état d’Ethereum. Dans Ethereum, $\Upsilon$, combiné avec $\boldsymbol{\sigma}$ sont considérablement plus puissants que tous les systèmes comparables existants; $\Upsilon$ autorise les composants à effectuer des calculs arbitraires, alors que $\boldsymbol{\sigma}$ autorise les composants à stocker des états arbitraires entre les transactions.

Les transactions sont regroupées dans des blocs; les blocs sont chaînés les uns aux autres en utilisant un haché cryptographique comme technique de référencement. Les blocs fonctionnent comme un journal, enregistrant une série de transactions ainsi que le bloc précédant et un identifiant pour l'état final (l'état final n'est cependant pas stocké lui-même---cela serait beaucoup trop volumineux). Ils ponctuent également la série de transaction avec une incitation pour les n\oe{}uds à \textit{miner}.

Miner est le processus consistant à dédier de l'effort (du travail) pour soutenir une série de transactions (un bloc) contre n'importe quel autre bloc concurrent. Cela est mis en \oe{}uvre grâce à une preuve cryptographique sécurisée. Ce schéma est connu comme preuve de travail (proof-of-work), et est étudié en détail dans la section \ref{ch:pow}.


Formellement, on développe ainsi:
\begin{eqnarray}
\boldsymbol{\sigma}_{t+1} & \equiv & \Pi(\boldsymbol{\sigma}_t, B) \\
B & \equiv & (..., (T_0, T_1, ...) ) \\
\Pi(\boldsymbol{\sigma}, B) & \equiv & \Omega(B, \Upsilon(\Upsilon(\boldsymbol{\sigma}, T_0), T_1) ...)
\end{eqnarray}


Où $\Omega$ est la fonction de changement d'état finalisant le bloc (une fonction qui récompense un ensemble désigné); $B$ est ce bloc, qui inclut une série de transactions parmi d'autres éléments; et $\Pi$ est la fonction de changement d'état au niveau du bloc.

Ceci est la base du paradigme de la blockchain, un modèle qui forme la colonne vertébrale non seulement d'Ethereum, mais aussi de tous les systèmes de transactions décentralisés basés sur consensus à l'heure actuelle.

\subsection{Valeur}


Dans le but d'inciter à l’affectation de puissance de calcul à l'intérieur du réseau, il y a besoin de convenir d'une méthode pour transmettre la valeur. Pour régler ce problème, Ethereum a une monnaie intrinsèque, l'Ether, aussi connue comme {\small ETH}, et parfois en référence à l'Anglais Ancien \DH{} (prononcé Eth). La plus petite sous-unité de l'Ether, et celle dans laquelle toutes les valeurs entières de la monnaie sont comptées est le Wei. Un Ether représente $10^{18}$ Wei. Il existe d'autres unités dérivées de l'Ether:
\par
\begin{center}
\begin{tabular}{rl}
\toprule
Ordre de grandeur & Nom \\
\midrule
$10^0$ & Wei \\
$10^{12}$ & Szabo \\
$10^{15}$ & Finney \\
$10^{18}$ & Ether \\
\bottomrule
\end{tabular}
\end{center}
\par

Tout au long du présent document, toute référence à une valeur ou à l'Ether, comme monnaie, balance ou paiement, sera exprimée en Wei.

\subsection{Quel historique?}

Puisque le système est décentralisé et que toutes les parties ont une opportunité de créer un nouveau bloc sur un bloc préexistant, la structure résultante est nécessairement un arbre de blocs. Il est nécessaire de disposer d’un schéma de passage consensuelle dans cette structure, c’est-à-dire un chemin depuis la racine (le bloc originel) jusqu'à la feuille (le bloc contenant les transactions les plus récentes) qui fasse consensus à travers cette structure d'arbre connue sous le nom de blockchain. Si jamais il y avait un désaccord entre les n\oe{}uds sur quel des chemins de l'arbre des blocs constitue la `meilleure' blockchain, alors il y a fourche (fork en anglais).  

Cela voudrait dire que passé un point donné dans le temps (bloc), plusieurs états du système peuvent coexister: certains n\oe{}uds croyant qu'un bloc contient les transactions canoniques, tandis que d'autres n\oe{}uds croyant être canonique un autre bloc, celui-ci contenant potentiellement des transactions radicalement différentes ou incompatibles. Ceci est à éviter à tout prix, tout comme l'incertitude qui s'ensuivrait et qui pourrait tuer la confiance dans le système entier. 

Le schéma que nous utilisons pour générer un consensus est une version simplifiée du protocole GHOST, introduit par \cite{cryptoeprint:2013:881}. Ce processus est décrit en détail dans la section \ref{ch:ghost}.

\section{Conventions}\label{ch:conventions}

J'utilise un nombre de conventions typographiques pour les notations formelles, quelques-unes sont un peu particulières au document présent:

Les deux ensembles de haut niveau, hautement structurés, des valeurs d'état, sont notés en minuscules grecques en gras. Ces valeurs relèvent de la catégorie de l'état du monde noté $\boldsymbol{\sigma}$ (ou une variante de celui-ci) ou de celle de l'état de la machine, $\boldsymbol{\mu}$.

Les fonctions opérant sur ces valeurs hautement structurées sont notés en lettre Grecque majuscule, par exemple $\Upsilon$, la fonction de changement d'état d'Ethereum.

Pour la plupart des fonctions, une lettre majuscule est utilisée, par exemple $C$, la fonction de coût général. Elles peuvent être indicées pour dénoter des variantes spécifiée, par exemple $C_\text{\tiny SSTORE}$,
la fonction de coût pour l'opération {\tiny SSTORE}. Pour certaines fonctions spécialisées et éventuellement définies de manière externe, je peux utiliser une typographie particulière, par exemple la fonction de hachage Keccak-256 (la gagnante du concours SHA-3) est dénotée $\texttt{KEC}$ (et généralement référencée comme simple Keccak). Aussi, $\texttt{KEC512}$ fait référence à une fonction de hachage Keccak 512.

Les tuples sont typiquement notés en lettres majuscules, par exemple $T$ est utilisé pour noter une transaction Ethereum. Ce symbole peut, s’il est défini en conséquence, être indicée pour faire référence à un composant individuel, \eg $T_n$, dénote le nonce de ladite transaction. la forme de l'indice est utilisée pour dénoter son type; par exemple des indices en majuscule font référence à des tuples avec des composants indiçables.

Les scalaires et les séquences d'octets de taille fixe (analogue, les tableaux), sont notés avec une lettre normale minuscule, par exemple $n$ est utilisée pour représenter le nonce de telle transaction. Ceux qui ont une signification particulière peuvent être grecs, par exemple $\delta$, le nombre d'éléments requis dans la pile pour une opération donnée.

Des séquences de longueur arbitraire sont typiquement notés en lettre minuscule et en gras, par exemple $\mathbf{o}$ est utilisé pour représenter la séquence d'octets en sortie d'un appel de message. Pour les valeurs particulièrement importantes, une lettre en majuscule et en gras peut être utilisée.

Tout au long du document nous supposons que les valeurs scalaires sont des entiers positifs, et qu'elles appartiennent à l'ensemble $\mathbb{P}$. L'ensemble de toutes les séquences d'octets est $\mathbb{B}$, formellement défini dans l'annexe \ref{app:rlp}. Si un tel ensemble de séquences est restreint à celles d'une longueur particulière, cela est dénoté avec un indice, ainsi, l'ensemble de toutes les séquences d'octets de longueur $32$  est nommé $\mathbb{B}_{32}$ et l'ensemble de tous les entiers positifs plus petits que $2^{256}$ est nommé $\mathbb{P}_{256}$. Cela formalisé dans la section \ref{ch:block}.

Les crochets sont utilisés pour indexer et référencer les composants individuels ou les sous-séquences de séquences, par exemple $\boldsymbol{\mu}_\mathbf{s}[0]$ représente le premier objet dans la pile de la machine. Pour les sous-séquences, les ellipses sont utilisées pour spécifier la tranche attendue en incluant les éléments au deux limites, par exemple $\boldsymbol{\mu}_\mathbf{m}[0..31]$ représente les 32 premiers objets de la mémoire de la machine.

Dans le cas de l'état global $\boldsymbol{\sigma}$, qui est une séquence de comptes, eux-mêmes des tuples, les crochets sont utilisés pour référencer un compte individuel.

En considérant les variantes des valeurs existantes, je suis la règle qu'au sein d'un périmètre donné comme définition, si nous supposons que la valeur d'`input' non modifiée est désignée par le signe $\Box$ alors la valeur modifiée et utilisable est représentée comme $\Box'$, et les valeurs intermédiaires seraient alors $\Box^*$, $\Box^{**}$ etc. Dans des cas vraiment très particuliers, dans le but de maximiser la lisibilité et seulement si c'est d'un sens non ambigu, je peux utiliser des indices alphanumériques pour représenter des valeurs intermédiaires.		 

En considérant l'utilisation de fonctions existantes, une fonction $f$ étant donnée, la fonction $f^*$ représente une version similaire élément par élément, de la mise en correspondance (mapping) des éléments de la fonction plutôt qu'entre les séquences d’élements. Cela est précisément décrit dans la section \ref{ch:block}.

Je définis un nombre de fonctions utiles à travers ce document. Une des plus communes est $\ell$, qui évalue le dernier objet de la séquence donnée:

\begin{equation}
\ell(\mathbf{x}) \equiv \mathbf{x}[\lVert \mathbf{x} \rVert - 1]
\end{equation}

\section{Blocs, état et transactions} \label{ch:bst}

Ayant introduit les concepts de base d'Ethereum, nous allons discuter de la signification d'une transaction, d'un bloc et de l'état de manière plus détaillée.

\subsection{L'état du monde} \label{ch:state}

L'état du monde (\textit{l'état}), est une mise en correspondance (mapping) entre les adresses (identifiants de 160-bit) et l'état des comptes (une structure de données serialisée comme RLP (Recursive Length Prefix - Préfixe de Longueur Récursive), voir annexe \ref{app:rlp}). Bien que non stockée sur la blockchain, on suppose que l'implémentation va maintenir ce mapping dans un arbre radix merkle modifié (\textit{trie}, voir annexe \ref{app:trie}). Le trie nécessite une base de données en arrière-plan qui maintienne un mapping de tableau de bytes à tableau de bytes; nous nommons cette base de données sous jacente la base de données d'état. Elle a un grand nombre d'avantages; premièrement le n\oe{}uds racine de cette structure est cryptographiquement dépendant de toute les données internes et son haché peut être utilisé comme une identité sécurisée pour l'état du système entier. Deuxièmement, étant une structure de données immutable, elle permet à n'importe quel état précédent (dont le haché racine est connu) d’être appelé à nouveau en altérant simplement le haché racine en fonction. Comme nous stockons tous ces hachés racines dans la blockchain, nous sommes capables de revenir aux anciens états de manière triviale.

L'état d'un compte comprend les quatre champs suivants:	

\begin{description}
\item[nonce] Une valeur scalaire égale au nombre de transactions envoyées depuis cette adresse, ou, dans le cas d'un compte contenant du code, le nombre de contrats créés par ce compte. Pour les comptes ou les adresses $a$ dans l'état $\boldsymbol{\sigma}$, cela sera représenté par $\boldsymbol{\sigma}[a]_n$.
\item[balance] Une valeur scalaire égale au nombre de Wei possédés par cette adresse. Représentée par $\boldsymbol{\sigma}[a]_b$.
\item[storageRoot] Un haché de 256-bit du n\oe{}uds racine d'un arbre radix merkle qui encode le stockage des contenus du compte (un mapping entre des valeurs entières de 256 bits), encodés dans le trie comme un mapping entre le haché Keccak 256 bits des clés entières de 256 bits et les valeurs entières encodées par RLP de 256 bits. Le haché est noté $\boldsymbol{\sigma}[a]_s$.
\item[codeHash] Le haché du code EVM du compte---c'est le code qui est exécuté lorsque cette adresse reçoit un appel de message; il est immutable et ainsi, contrairement à tous les autres champs, ne peut pas être changé après construction. Tous ces fragments de code sont contenus dans la base de données d'état sous leur haché correspondant pour les récupérer plus tard. Ce haché est noté $\boldsymbol{\sigma}[a]_c$, et ainsi le code peut être représenté par $\mathbf{b}$, sachant que $\texttt{\small KEC}(\mathbf{b}) = \boldsymbol{\sigma}[a]_c$.
\end{description}

Comme je souhaite typiquement faire référence, non pas au haché racine du trie mais à l'ensemble des paires clé/valeur stockées à l'intérieur, je définis une équivalence pratique: 
\begin{equation}
\texttt{\small TRIE}\big(L_I^*(\boldsymbol{\sigma}[a]_\mathbf{s})\big) \equiv \boldsymbol{\sigma}[a]_s
\end{equation}

la fonction d'effondrement ordinale pour l'ensemble de paires de clé/valeur dans le trie, $L_I^*$, est définie comme la transformation élément par élément de la fonction de base $L_I$, définie par:
\begin{equation}
L_I\big( (k, v) \big) \equiv \big(\texttt{\small KEC}(k), \texttt{\small RLP}(v)\big)
\end{equation}

où:
\begin{equation}
k \in \mathbb{B}_{32} \quad \wedge \quad v \in \mathbb{P}
\end{equation}

Il faut comprendre ici que $\boldsymbol{\sigma}[a]_\mathbf{s}$ n'est pas un membre `physique' du compte et ne contribue pas a sa sérialisation ultérieure.

Si le champ \textbf{codeHash} est le haché Keccak-256 de la chaîne (de caractères) vide, i.e. $\boldsymbol{\sigma}[a]_c = \texttt{\small KEC}\big(()\big)$, alors le n\oe{}uds représente un simple compte, parfois dénommé compte ``non-contrat''.

Ainsi nous pouvons définir une fonction d'effondrement ordinale de l'état du monde $L_S$:
\begin{equation}
L_S(\boldsymbol{\sigma}) \equiv \{ p(a): \boldsymbol{\sigma}[a] \neq \varnothing \}
\end{equation}
où
\begin{equation}
p(a) \equiv  \big(\texttt{\small KEC}(a), \texttt{\small RLP}\big( (\boldsymbol{\sigma}[a]_n, \boldsymbol{\sigma}[a]_b, \boldsymbol{\sigma}[a]_s, \boldsymbol{\sigma}[a]_c) \big) \big)
\end{equation}

cette fonction , $L_S$, est utilisée tout au long de la fonction de trie pour fournir une identité courte (hash) à l'état du monde. Nous supposons:
\begin{equation}
\forall a: \boldsymbol{\sigma}[a] = \varnothing \; \vee \; (a \in \mathbb{B}_{20} \; \wedge \; v(\boldsymbol{\sigma}[a]))
\end{equation}
où $v$ est la fonction de validité de compte:
\begin{equation}
\quad v(x) \equiv x_n \in \mathbb{P}_{256} \wedge x_b \in \mathbb{P}_{256} \wedge x_s \in \mathbb{B}_{32} \wedge x_c \in \mathbb{B}_{32}
\end{equation}

\subsection{Homestead} \label{ch:homestead}

Un numéro de bloc significatif pour la compatibilité avec le réseau public est le bloc marquant la transition entre les phases {\it Frontier} et {\it Homestead} de la plateforme, que nous représentons avec le symbole \firsthomesteadblock, défini ainsi 
\begin{equation}
\firsthomesteadblock \equiv 1,\! 150,\! 000
\end{equation}
Le protocole a été mis à jour à ce bloc, donc ce symbole apparait dans quelques équations des comptes, pour les changements.

\subsection{La Transaction} \label{ch:transaction}

Une transaction ($T$) est une instruction de signature cryptographique unique construite par un acteur externe au périmètre d'Ethereum. Alors que nous supposons que l'ultime acteur externe sera humain par nature, des outils logiciels seront utilisés pour sa construction et sa propagation\footnote{Particulièrement, de tels `outils' pourraient en fin de compte devenir tellement disjoints de leur relation causale à une création humaine---ou bien les humains pourraient y devenir indifférents---qu'ils pourraient se comporter comme des agents autonomes. Par exemple les contrats pourraient offrir des primes aux humains pour avoir envoyé des transactions pour initier leur exécution.}. Il y a deux types de transactions: celles qui entraînent des appels de messages et celles qui entraînent la création de nouveaux comptes auxquels est associé du code (connues de manière informelle sous le nom de `créations de contrat'). Ces deux types de transaction spécifient un certain nombre de champs communs:

\begin{description}
\item[nonce] Une valeur scalaire égale au nombre de transactions émises par l'envoyeur $T_n$.
\item[gasPrice] Une valeur scalaire égale au nombre de Wei à payer par unité de \textit{gas} pour tous les coûts de calcul engagés comme résultat de l'exécution de cette transaction; $T_p$.
\item[gasLimit] Une valeur scalaire égale au montant maximum de gas qui peut être utilisé en exécutant cette transaction. Cela est payé en amont, avant que tout calcul soit fait et ne peut pas être augmenté plus tard; $T_g$.
\item[to] L'adresse de 160 bits du destinataire de l'appel de message ou, pour une transaction de création de contrat , $\varnothing$, utilisé ici pour noter le seul membre de $\mathbb{B}_0$ ; formellement $T_t$.
\item[value] Une valeur scalaire égale au nombre de Wei à transférer au destinataire de l'appel de message ou, dans le cas d'une création de contrat, comme une dotation pour le nouveau compte à créer; $T_v$.
\item[v, r, s] Les valeurs correspondantes à la signature de la transaction et utilisées pour déterminer l'emetteur de la transaction; formellement $T_w$, $T_r$ and $T_s$. Cela est détaillé dans l'annexe \ref{app:signing}.
\end{description}

De plus, une transaction de création de contrat contient:

\begin{description}
\item[init] Un tableau d'octets de taille illimitée contenant le code EVM pour la procédure d'initialisation du compte, $T_\mathbf{i}$.
\end{description}

\textbf{init} est un fragment de code EVM; il retourne le \textbf{body}, un second fragment de code qui s'exécute à chaque fois que le compte reçoit un appel de message (soit au travers d'une transaction, soit par l'exécution interne de code). \textbf{init} est exécuté une seule fois à la création du compte et reste écarté immédiatement après.

En revanche, une transaction d'appel de message contient:

\begin{description}
\item[data] Un tableau d'octets illimité spécifiant la donnée entrante de l'appel de message, $T_\mathbf{d}$.
\end{description}

L'annexe \ref{app:signing} décrit la fonction, $S$, qui fait correspondre les transactions au destinataire, et s'exécute à travers l'ECDSA de la courbe SECP-256k1, utilisant le hash de la transaction (excepté les trois derniers champs de signature) en tant que datum à signer. Pour le moment nous nous assurons seulement que l'émetteur d'une transaction donnée peut être représenté par $S(T)$.

\begin{equation}
L_T(T) \equiv \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}, T_w, T_r, T_s) & \text{if} \; T_t = \varnothing\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}, T_w, T_r, T_s) & \text{otherwise}
\end{cases}
\end{equation}

Ici, nous supposons que tous les composants sont interprétés par le RLP comme des valeurs entières, avec l'exception des tableaux d'octets de longueur arbitraire $T_\mathbf{i}$ et $T_\mathbf{d}$.

\begin{equation}
\begin{array}[t]{lclclc}
T_n \in \mathbb{P}_{256} & \wedge & T_v \in \mathbb{P}_{256} & \wedge & T_p \in \mathbb{P}_{256} & \wedge \\
T_g \in \mathbb{P}_{256} & \wedge & T_w \in \mathbb{P}_5 & \wedge & T_r \in \mathbb{P}_{256} & \wedge \\
T_s \in \mathbb{P}_{256} & \wedge & T_\mathbf{d} \in \mathbb{B} & \wedge & T_\mathbf{i} \in \mathbb{B}
\end{array}
\end{equation}
où
\begin{equation}
\mathbb{P}_n = \{ P: P \in \mathbb{P} \wedge P < 2^n \}
\end{equation}

Le hash de l'adresse $T_\mathbf{t}$ est légèrement différent: c'est soit le hash de 20 octets d'une adresse, ou, dans le cas d'une création de contrat (et ainsi formellement égal à $\varnothing$), c'est la série RLP d'octets vides et ainsi le membre de $\mathbb{B}_0$:

\begin{equation}
T_t \in \begin{cases} \mathbb{B}_{20} & \text{if} \quad T_t \neq \varnothing \\
\mathbb{B}_{0} & \text{otherwise}\end{cases}
\end{equation}

\subsection{Le Bloc} \label{ch:block}


Le bloc dans Ethereum est l'ensemble de morceaux d'information pertinents (connu comme \textit{l'en-tête} du bloc), $H$, ainsi que l'information correspondant aux transactions incluses, $\mathbf{T}$, et un ensemble d'autres en-têtes $\mathbf{U}$ qui sont connus pour avoir un parent égal au parent du parent du bloc actuel  (ce genre de blocs sont connus en tant que (TODO : traduire ommer, dans la suite du doc aussi) \textit{ommers}\footnote{\textit{ommer} est le terme, neutre au niveau du genre, le plus répandu pour représenter ``la fraternité du parent''; voir \url{http://nonbinary.org/wiki/Gender_neutral_language#Family_Terms}}). L'en-tête du bloc contient plusieurs parties d'information:


%\textit{TODO: Introduire les logs}

\begin{description}
\item[parentHash] Le hash Keccak de 256 bits de l'en-tête du bloc parent, dans son entièreté; $H_p$.
\item[ommersHash] Le hash Keccak de 256 bits de la section de liste de (TODO) ommers de ce bloc; $H_o$.
\item[beneficiary] L'addresse de 160 bits à laquelle seront envoyés tous les frais collectés par le minage réussi de ce bloc; $H_c$.
\item[stateRoot]  Le hash Keccak de 256 bits du noeud racine du trie d'état, après que toutes les transactions sont exécutées et que les finalisations sont appliquées; $H_r$.
\item[transactionsRoot] Le hash Keccak de 256 bits du noeud racine de la structure du trie, peuplé avec chaque transaction dans la section de la liste de transactions du bloc; $H_t$.
\item[receiptsRoot] Le hash Keccak de 256 bits du noeud racine de la structure de  (TODO : trie) trie, peuplée avec les reçus de chaque transaction dans la section de la liste de transactions du bloc; $H_e$.
\item[logsBloom] Le filtre de Bloom composé de l'information indexable (l'adresse du logger et les sujets de log) contenu dans chaque entrée de log depuis le reçu de chaque transaction dans la liste de transactions; $H_b$.
\item[difficulty] Une valeur scalaire correspondant au niveau de difficulté de ce bloc. Il peut être calculé à partir de la difficulté précédente et du timestamp; formally $H_d$.
\item[number] Une valeur scalaire égale au nombre de blocs ancêtre. Le bloc origine a un number de zéro; $H_i$.
\item[gasLimit] Une valeur scalaire égale à la limite courante d'usage de gaz par bloc; $H_l$.
\item[gasUsed] Une valeur scalaire égale au gaz total utilisé par les transactions dans ce bloc; $H_g$.
\item[timestamp] Une valeur scalaire égale à un timestamp Unix raisonnable (time()) pour la naissance de ce bloc; $H_s$.
\item[extraData] Un tableau d'octets de longueur arbitraire contenant des données relatives à ce bloc. Il doit être de 32 octets ou moins; $H_x$.
\item[mixHash] Un hash de 256 bits qui prouve, combiné avec le nonce, qu'une quantité suffisante de calcul informatique a été consacré à ce bloc; $H_m$.
\item[nonce] Un hash de 64 bits qui prouve, combiné avec mix-hash, qu'une quantité suffisante de calcul informatique a été consacré à ce bloc; $H_n$.
\end{description}

Les deux derniers composants dans le bloc sont simplement une liste d'en-têtes de blocs ommer (du même format que ci-dessus) et une liste des transactions. Formellement, on peut noter le bloc $B$:
\begin{equation}
B \equiv (B_H, B_\mathbf{T}, B_\mathbf{U})
\end{equation}

\subsubsection{Quittance de transaction}

De façon à pouvoir stocker l'information concernant une transaction, pour laquelle il peut être utile de fournir une preuve à divulgation nulle de connaissance, ou l'indexer à fins de recherche, nous encodons un récépissé de chaque transaction contenant des informations à propos de son exécution. Chaque récépissé, noté $B_\mathbf{R}[i]$ pour la $i$ème transaction, est placé dans un trie indexé et la racine est encodée dans son en-tête comme $H_e$.

Le récépissé de transaction est un tuple de quatre items comprenant l'état post-transaction $R_{\boldsymbol{\sigma}}$, la totalité du gaz consommé par le bloc contenant le récépissé de transaction comme celle usée immédiatement après sa ratification $R_u$, l'ensemble des journaux créés durant la transaction $R_\mathbf{l}$, et le filtre de Bloom constitué par l'information dans ces journaux $R_b$:
\begin{equation}
R \equiv (R_{\boldsymbol{\sigma}}, R_u, R_b, R_\mathbf{l})
\end{equation}

La fonction $L_R$ prépare simplement le récépissé de transaction à être transformé en un tableau d'octets ordonné RLP:
\begin{equation}
L_R(R) \equiv (\mathtt{\small TRIE}(L_S(R_{\boldsymbol{\sigma}})), R_u, R_b, R_\mathbf{l})
\end{equation}
ainsi l'état post-transaction $R_{\boldsymbol{\sigma}}$ est encodé dans une structure de trie, dont la racine est le premier item.

On définit $R_u$, le gaz consommé comme un entier positif et les journaux Bloom $R_b$, comme hash de taille 2048 bits (256 octets):
\begin{equation}
R_u \in \mathbb{P} \quad \wedge \quad R_b \in \mathbb{B}_{256}
\end{equation}

%Notably $B_\mathbf{T}$ does not get serialised into the block by the block preparation function $L_B$; it is merely a convenience equivalence.

Les rubriques de journalisation, $R_\mathbf{l}$, sont une série de traces, dénotées, par exemple, $(O_0, O_1, ...)$. Une trace $O$, est un tuple d'une adresse d'enregistreur $O_a$, d'une série de sujets de 32-octets de long $O_\mathbf{t}$, et d'un certain nombre d'octets de data, $O_\mathbf{d}$:
\begin{equation}
O \equiv (O_a, ({O_\mathbf{t}}_0, {O_\mathbf{t}}_1, ...), O_\mathbf{d})
\end{equation}
\begin{equation}
O_a \in \mathbb{B}_{20} \quad \wedge \quad \forall_{t \in O_\mathbf{t}}: t \in \mathbb{B}_{32} \quad \wedge \quad O_\mathbf{d} \in \mathbb{B}
\end{equation}

On définit la fonction filtre de Bloom $M$, comme réduction d'une rubrique de journal en une empreinte de 256 octets:
\begin{equation}
M(O) \equiv \bigvee_{t \in \{O_a\} \cup O_\mathbf{t}} \big( M_{3:2048}(t) \big)
\end{equation}

où $M_{3:2048}$ un filtre de Bloom spécialisé qui extrait trois bits de 2048, une série d'octets arbitraire étant donnée. Cela est fait en prenant les 11 bits de poids faible de chacune des trois premières paires d'octets dans une empreinte Keccak-256 de la série d'octets. Formellement:
\begin{eqnarray}
M_{3:2048}(\mathbf{x}: \mathbf{x} \in \mathbb{B}) & \equiv & \mathbf{y}: \mathbf{y} \in \mathbb{B}_{256} \quad \text{où:}\\
\mathbf{y} & = & (0, 0, ..., 0) \quad \text{excepté:}\\
\forall_{i \in \{0, 2, 4\}}&:& \mathcal{B}_{m(\mathbf{x}, i)}(\mathbf{y}) = 1\\
m(\mathbf{x}, i) &\equiv& \mathtt{\tiny KEC}(\mathbf{x})[i, i + 1] \bmod 2048
\end{eqnarray}

Où $\mathcal{B}$ est la fonction binaire telle que $\mathcal{B}_j(\mathbf{x})$ égale le bit d'index $j$ (indexé depuis 0) dans le tableau d'octets $\mathbf{x}$.

\subsubsection{Validation synergique}

On ne peut assurer la validité d'un bloc que s'il satisfait un certain nombre de conditions: il doit être cohérent avec le ommer et avec les empreintes de transactions du bloc, et les transactions données $B_\mathbf{T}$ (comme spécifié en section \ref{ch:finalisation}), exécutées dans l'ordre sur l'état de base $\boldsymbol{\sigma}$ (dérivé de l'état final du bloc parent), donnent comme résultat un nouvel état de l'identité $H_r$:
\begin{equation}
\begin{array}[t]{lclc}
H_r &\equiv& \mathtt{\small TRIE}(L_S(\Pi(\boldsymbol{\sigma}, B))) & \wedge \\
H_o &\equiv& \mathtt{\small KEC}(\mathtt{\small RLP}(L_H^*(B_\mathbf{U}))) & \wedge \\
H_t &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{T} \rVert, i \in \mathbb{P}: p(i, L_T(B_\mathbf{T}[i]))\}) & \wedge \\
H_e &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{R} \rVert, i \in \mathbb{P}: p(i, L_R(B_\mathbf{R}[i]))\}) & \wedge \\
H_b &\equiv& \bigvee_{\mathbf{r} \in B_\mathbf{R}} \big( \mathbf{r}_b \big)
\end{array}
\end{equation}

où $p(k, v)$ est simplement la paire RLP de l'index de la transaction dans le bloc d'une part, et du récépissé de la transaction d'autre part:
\begin{equation}
p(k, v) \equiv \big( \mathtt{\small RLP}(k), \mathtt{\small RLP}(v) \big)
\end{equation}

En outre:
\begin{equation}
\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma})) = {P(B_H)_H}_r
\end{equation}

Ainsi $\texttt{\small TRIE}(L_S(\boldsymbol{\sigma}))$ est l'empreinte du noeud racine de l'arbre merkle radix contenant les paires clé-valeur de l'état $\boldsymbol{\sigma}$ avec des valeurs encodées par RLP, et $P(B_H)$ est le bloc parent de $B$, défini directement.

Les valeurs provenant du calcul des transactions, spécialement les récépissés de transaction $B_\mathbf{R}$, et ceux définis par la fonction d'aggrégation d'états $\Pi$, sont formalisés plus loin dans la section \ref{sec:statenoncevalidation}.

\subsubsection{Sérialisation}

Les fonctions $L_B$ et $L_H$ Sont les fonctions préparatoires pour un bloc et un en-tête de bloc respectivement. De façon très semblable à la fonction de préparation du récépissé de transaction $L_R$, nous assumons que les types et ordre de la structure pour la transformation RLP sont:
\begin{eqnarray}
\quad L_H(H) & \equiv & (\begin{array}[t]{l}H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d,\\ H_i, H_l, H_g, H_s, H_x, H_m, H_n \; )\end{array} \\
\quad L_B(B) & \equiv & \big( L_H(B_H), L_T^*(B_\mathbf{T}), L_H^*(B_\mathbf{U}) \big)
\end{eqnarray}

Avec $L_T^*$ et $L_H^*$ comme transformations élément par élément de la séquence, ainsi:
\begin{equation}
f^*\big( (x_0, x_1, ...) \big) \equiv \big( f(x_0), f(x_1), ... \big) \quad \text{pour toute fonction} \; f
\end{equation}

Les composants type sont définis ainsi:
\begin{equation}
\begin{array}[t]{lclclcl}
H_p \in \mathbb{B}_{32} & \wedge & H_o \in \mathbb{B}_{32} & \wedge & H_c \in \mathbb{B}_{20} & \wedge \\
H_r \in \mathbb{B}_{32} & \wedge & H_t \in \mathbb{B}_{32} & \wedge & H_e \in \mathbb{B}_{32} & \wedge \\
H_b \in \mathbb{B}_{256} & \wedge & H_d \in \mathbb{P} & \wedge & H_i \in \mathbb{P} & \wedge \\
H_l \in \mathbb{P} & \wedge & H_g \in \mathbb{P} & \wedge & H_s \in \mathbb{P}_{256} & \wedge \\
H_x \in \mathbb{B} & \wedge & H_m \in \mathbb{B}_{32} & \wedge & H_n \in \mathbb{B}_{8}
\end{array}
\end{equation}

où
\begin{equation}
\mathbb{B}_n = \{ B: B \in \mathbb{B} \wedge \lVert B \rVert = n \}
\end{equation}

Nous avons maintenant une spécification rigoureuse pour la construction de la structure formelle d'un bloc. La fonction RLP $\texttt{\small RLP}$ (voir Annexe \ref{app:rlp}) fournit la méthode de référence pour transformer cette structure en une sequence d'octets prêts à la transmission ou au stockage local.

\subsubsection{Validation de l'en-tête de bloc}

On définit $P(B_H)$ comme le bloc parent de $B$, formellement:
\begin{equation}
P(H) \equiv B': \mathtt{\tiny KEC}(\mathtt{\tiny RLP}(B'_H)) = H_p
\end{equation}

Le numéro de bloc est le numéro du bloc parent incrémenté de un:
\begin{equation}
H_i \equiv {{P(H)_H}_i} + 1
\end{equation}

\newcommand{\mindifficulty}{D_0}
\newcommand{\frontiermod}{\ensuremath{\varsigma_1}}
\newcommand{\homesteadmod}{\ensuremath{\varsigma_2}}
\newcommand{\expdiffsymb}{\ensuremath{\epsilon}}
\newcommand{\diffadjustment}{x}

La difficulté de référence d'un bloc d'en-tête $H$ est défini comme $D(H)$:
\begin{equation}
D(H) \equiv \begin{dcases}
\mindifficulty & \text{si} \quad H_i = 0\\
\text{max}\!\left(\mindifficulty, {P(H)_H}_d + \diffadjustment\times\frontiermod + \expdiffsymb \right) & \text{si} \quad H_i<\firsthomesteadblock\\
\text{max}\!\left(\mindifficulty, {P(H)_H}_d + \diffadjustment\times\homesteadmod + \expdiffsymb \right) & \text{sinon}\\
\end{dcases}
\end{equation}
où:
\begin{equation}
\mindifficulty \equiv 131072
\end{equation}
\begin{equation}
\diffadjustment \equiv \left\lfloor\frac{{P(H)_H}_d}{2048}\right\rfloor
\end{equation}
\begin{equation}
\frontiermod \equiv \begin{cases}
1 & \text{si} \quad H_s < {P(H)_H}_s + 13 \\
-1 & \text{sinon} \\
\end{cases}
\end{equation}
\begin{equation}
\homesteadmod \equiv \text{max}\left( 1 - \left\lfloor\frac{H_s - {P(H)_H}_s}{10}\right\rfloor, -99 \right)
\end{equation}
\begin{equation}
\expdiffsymb \equiv \left\lfloor 2^{ \left\lfloor H_i \div 100000 \right\rfloor - 2 } \right\rfloor
\end{equation}

la limite de reférence de gaz $H_l$ d'un bloc d'en-tête $H$ doit être conforme à la relation:
\begin{eqnarray}
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l \geqslant 125000
\end{eqnarray}

$H_s$ est l'horodatage du bloc $H$ et doit être conforme à la relation:
\begin{equation}
H_s > {P(H)_H}_s
\end{equation}

Ce mécanisme renforce une homéostasie pour les intervalles de temps entre les blocs; une période de temps plus petite entre deux blocs entraîne une augmentation du niveau de difficulté et ainsi davantage de calcul, rallongeant d'autant la période suivante. inversement, si la période est trop large, la difficulté, et le temps attendu pour le bloc suivant, est réduit.

Le nonce $H_n$, doit satisfaire aux relations:
\begin{equation}
n \leqslant \frac{2^{256}}{H_d} \quad \wedge \quad m = H_m
\end{equation}
avec $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$.

Où $H_{\hcancel{n}}$ est le nouvel en-tête de bloc $H$, mais \textit{sans} le nonce et le mixhash, $\mathbf{d}$ étant le DAG courant, un grand ensemble de données utilisé pour calculer le mixhash, et $\mathtt{PoW}$ étant la fonction de preuve-de-travail (voir section \ref{ch:pow}): ceci est évalué en un tableau dont le premier item est le mixhash, pour preuve qu'un DAG correct a été utilisé, et le second item est un nombre pseudo-aléatoire cryptographiquement dependant de $H$ et $\mathbf{d}$. Étant donnée une distribution approximativement uniforme sur l'intervalle $[0, 2^{64}]$, le temps estimé pour trouver une solution est proportionnel à la difficulté $H_d$.

Ceci est le fondement de la sécurité de la chaîne de blocs et est la raison fondamentale pour laquelle un code malicieux ne peut pas propager des blocs nouvellement forgés qui pourraient autrement écraser (``réécrire'') l'historique. Parce que le nonce doit satisfaire cette condition, et parce que cette satisfaction dépend du contenu du bloc et des transactions qui le composent, créer de nouveaux blocs valides est difficile et, avec le temps, demande  approximativement la puissance de calcul totale de la partie de confiance parmi les pairs mineurs.

Ainsi on est en mesure de définir la fonction de validation de l'entête de bloc $V(H)$:
\begin{eqnarray}
V(H) & \equiv &  n \leqslant \frac{2^{256}}{H_d} \wedge m = H_m \quad \wedge \\
& & H_d = D(H) \quad \wedge \\
& & H_g \le H_l  \quad \wedge \\
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l \geqslant 125000  \quad \wedge \\
& & H_s > {P(H)_H}_s \quad \wedge \\
& & H_i = {P(H)_H}_i +1 \quad \wedge \\
& & \lVert H_x \rVert \le 32
\end{eqnarray}
où $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$

Notons que \textbf{extraData} doit être au plus de 32 octets.

\section{Gaz et paiement} \label{ch:payment}

Pour éviter d'avoir des problèmes d'abus du réseau et pour contourner les inévitables questions découlant de la complétude au sens de Turing, tout calcul programmable dans Ethereum est sujet à des frais. Le barème des frais est spécifié en unités de \textit{gas} (voir Annexe \ref{app:fees} pour les frais associés avec divers calculs). Ainsi tout fragment donné de calcul programmable (ceci inclut créer des contrats, lancer des messages d'appel, accéder et utiliser les données associées aux comptes, et exécuter des opérations sur la machine virtuelle) a un coût en gaz universellement approuvé.

Toute transaction a un montant spécifique de gaz qui lui est associé: \textbf{gasLimit}. C'est le montant en gaz qui est implicitement prélevé sur le compte de l'expéditeur. L'achat est fait à la valeur de \textbf{gasPrice}, également spécifié dans la transaction. La transaction est considérée comme invalide si le solde du compte ne peut assurer l'achat. Il est nommé \textbf{gasLimit} parce que toute quantité de gaz non utilisée est rendue (au même taux d'achat) au compte de l'expéditeur. Le gaz n'existe pas en dehors de l'exécution d'une transaction. Ainsi pour des comptes avec du code de confiance associé, une limite relativement haute de gaz peut être ainsi réservée.

En général, l'Ether utilisé pour acheter du gaz qui n'est pas rendu est délivré à l'adresse du \textit{bénéficiaire}, adresse typiquement sous le contrôle du mineur. Les contractants sont libres de spécifier tout \textbf{gasPrice} qui leur convienne, cependant les mineurs sont libres d'ignorer les transactions de leur choix. Un prix de gaz plus élevé pour une transaction coûtera davantage d'Ether à son expéditeur et donnera davantage au mineur, et donc elle sera plus aisément sélectionnée pour inclusion par davantage de mineurs. Les mineurs, en général, choisiront d'annoncer le prix du gaz minimum pour lequel ils exécuteront des transactions et les contractants seront libres de marchander ces prix en déterminant quel prix du gaz offrir. Comme il y aura une distribution (pondérée) des minima des prix du gaz, les contractants devront nécessairement marchander entre baisser le prix du gaz et maximiser les chances que leurs transactions seront minées avec rapidité.

%\subsubsection{Determining Computation Costs}

\section{Exécution de transaction} \label{ch:transactions}

L'exécution d'une transaction est la partie la plus complexe du protocole Ethereum: il définit la fonction de transition d'état $\Upsilon$. On suppose que toutes transactions exécutées passent d'abord les tests de validité intrinsèques. Les voici:

\begin{enumerate}
\item La transaction est un RLP bien formé sans octets additionnels à la fin;
\item La signature de transaction est valide;
\item Le nonce de transaction est valide (équivalent au nonce courant du compte de l'expéditeur);
\item La limite de gaz n'est pas plus petite que le gaz intrinsèque, $g_0$, utilisé par la transaction;
\item Le solde du compte de l'expéditeur contient au moins le coût, $v_0$, demandé comme paiement de départ.
\end{enumerate}

Formellement, nous considérons la fonction $\Upsilon$, $T$ étant une transaction et $\boldsymbol{\sigma}$ l'état:
\begin{equation}
\boldsymbol{\sigma}' = \Upsilon(\boldsymbol{\sigma}, T)
\end{equation}

$\boldsymbol{\sigma}'$ est donc l'état post-transactionnel. Nous définissons également $\Upsilon^g$ pour évaluer le montant de gaz utilisé dans l'exécution d'une transaction et $\Upsilon^\mathbf{l}$ pour évaluer les items de logs ajoutés, les deux étant formellement définis plus loin.

\subsection{Sous-état}
Pendant l'exécution d'une transaction, nous voyons s'accroître certaines informations sur lesquelles on agit immédiatement à la suite de la transaction. Nous appelons ceci \textit{sous-état de transaction} et le représentons par $A$, qui est un tuple:
\begin{equation}
A \equiv (A_\mathbf{s}, A_\mathbf{l}, A_r)
\end{equation}

Le contenu du tuple comprend $A_\mathbf{s}$, l'ensemble de suicide: un ensemble de comptes qui sera mis au rebut après la fin de la transaction. $A_\mathbf{l}$ est la série de logs: il s'agit d'une série de `points de contrôles' dans l'exécution du code de la VM qui permet de facilement tracer les appels de contrats par des observateurs extérieurs au monde Ethereum (comme des frontaux d'applications décentralisées). Enfin, il y a $A_r$, le solde de remboursement, accru par l'utilisation de l'instruction {\small SSTORE} afin de remettre la mémoire de stockage à zéro à partir d'une valeur différente de zéro. Bien qu'il ne soit pas immédiatement remboursé, il lui est permis de compenser partiellement les coûts totaux d'exécution.

Dans un souci de concision, nous définissons le sous-état vide $A^0$ comme n'ayant pas de suicide, pas de logs et un solde de remboursement à zéro:
\begin{equation}
A^0 \equiv (\varnothing, (), 0)
\end{equation}

\subsection{Exécution}
Nous définissons le gaz $g_0$, le montant de gaz que cette transaction demande pour être payée avant exécution, comme suit:
\begin{align}
g_0 \equiv {} & \sum_{i \in T_\mathbf{i}, T_\mathbf{d}} \begin{cases} G_{txdatazero} & \text{si} \quad i = 0 \\ G_{txdatanonzero} & \text{sinon} \end{cases} \\
{} & + \begin{cases} G_\text{txcreate} & \text{si} \quad T_t = \varnothing \wedge H_i \geq \firsthomesteadblock \\ 0 & \text{sinon} \end{cases} \\
{} & + G_{transaction}
\end{align}

où $T_\mathbf{i},T_\mathbf{d}$ signifie la série d'octets des données et du code EVM associés à la transaction, selon que la transaction sert à une création de contrat ou un a un appel de message. $G_\text{txcreate}$ est ajouté si la transaction crée un message mais ce n'est pas le cas s'il s'agit d'un résultat de code EVM ou avant la {\it transition Homestead}. $G$ est totalement défini à l'Annexe  \ref{app:fees}.

%todo Explain g_d reason?

Le coût de départ $v_0$ est calculé par:
\begin{equation}
v_0 \equiv T_g T_p + T_v
\end{equation}

La validité est déterminée comme:
\begin{equation}
\begin{array}[t]{rcl}
S(T) & \neq & \varnothing \quad \wedge \\
\boldsymbol{\sigma}[S(T)] & \neq & \varnothing \quad \wedge \\
T_n & = & \boldsymbol{\sigma}[S(T)]_n \quad \wedge \\
g_0 & \leqslant & T_g \quad \wedge \\
v_0 & \leqslant & \boldsymbol{\sigma}[S(T)]_b \quad \wedge \\
T_g & \leqslant & {B_H}_l - \ell(B_\mathbf{R})_u
\end{array}
\end{equation}

On note la condition finale: la somme de la limite en gaz de la transaction, $T_g$, et le gaz auparavant utilisé dans ce bloc, donné par $\ell(B_\mathbf{R})_u$, ne doit pas être plus grand que la \textbf{gasLimit}, ${B_H}_l$ du bloc.

L'exécution d'une transaction valide commence par un changement irrévocable de l'état: le nonce du compte de l'expéditeur, $S(T)$, est incrémenté et le solde est réduit par une partie du coût de départ, $T_gT_p$. Le gaz disponible pour le calcul en cours, $g$, est défini par $T_g - g_0$. Le calcul, qu'il s'agisse d'une création de contrat ou d'un appel de message, donne un état final (qui peut être légalement équivalent à l'état courant), dont le changement est déterministe et jamais invalide: il ne peut y avoir de transaction invalide à partir de ce point.

Nous définissons l'état au point de contrôle $\boldsymbol{\sigma}_0$:
\begin{eqnarray}
\boldsymbol{\sigma}_0 & \equiv & \boldsymbol{\sigma} \quad \text{except\,:} \\
\boldsymbol{\sigma}_0[S(T)]_b & \equiv & \boldsymbol{\sigma}[S(T)]_b - T_g T_p \\
\boldsymbol{\sigma}_0[S(T)]_n & \equiv & \boldsymbol{\sigma}[S(T)]_n + 1
\end{eqnarray}

L'évaluation de $\boldsymbol{\sigma}_P$ à partir de $\boldsymbol{\sigma}_0$ dépend du type de la transaction, création de contrat ou appel de message; nous définissons le tuple: état provisionnel de post-exécution $\boldsymbol{\sigma}_P$, gaz restant $g'$ et sous-état $A$:
\begin{equation}
(\boldsymbol{\sigma}_P, g', A) \equiv \begin{cases}
\Lambda(\boldsymbol{\sigma}_0, S(T), T_o, &\\ \quad\quad g, T_p, T_v, T_\mathbf{i}, 0) & \text{si} \quad T_t = \varnothing \\
\Theta_{3}(\boldsymbol{\sigma}_0, S(T), T_o, &\\ \quad\quad T_t, T_t, g, T_p, T_v, T_v, T_\mathbf{d}, 0) & \text{sinon}
\end{cases}
\end{equation}

où $g$ est le montant de gaz restant après avoir déduit le montant de base demandé pour payer pour l'existence de la transaction:
\begin{equation}
g \equiv T_g - g_0
\end{equation}
et $T_o$ est l'auteur originel de la transaction, qui peut différer de l'expéditeur dans le cas d'un appel de message ou d'une création de contact qui n'a pas été directement déclenché par une transaction mais qui vient de l'exécution de code EVM.

On remarque que nous utilisons $\Theta_{3}$ pour noter le fait que seuls les trois premiers composants de la valeur de la fonction sont pris; le composant final représente la valeur de sortie d'un appel de message (un tableau d'octets) et est inutilisé dans le contexte de l'évaluation d'une transaction.

Après le traitement de l'appel de message ou de la création de contrat, l'état est finalisé en déterminant le montant à rembourser, $g^*$, du gaz restant, $g'$, plus un certain montant du compteur de remboursement, à l'expéditeur du taux d'origine.
\begin{equation}
g^* \equiv g' + \min \{ \Big\lfloor \dfrac{T_g - g'}{2} \Big\rfloor, A_r \}
\end{equation}

Le montant total à rembourser est le gaz légitimement restant $g'$, ajouté à $A_r$, ce dernier composant étant limité à un maximum de la moitié (tronquée) du montant total utilisé $T_g - g'$.

L'Ether du gaz est donné au mineur dont l'adresse est spécifiée comme bénéficiaire du bloc présent $B$. Nous définissons donc l'état pré-final $\boldsymbol{\sigma}^*$ en termes d'état provisionnel  $\boldsymbol{\sigma}_P$:
\begin{eqnarray}
\boldsymbol{\sigma}^* & \equiv & \boldsymbol{\sigma}_P \quad \text{except} \\
\boldsymbol{\sigma}^*[S(T)]_b & \equiv & \boldsymbol{\sigma}_P[S(T)]_b + g^* T_p \\
\boldsymbol{\sigma}^*[m]_b & \equiv & \boldsymbol{\sigma}_P[m]_b + (T_g - g^*) T_p \\
m & \equiv & {B_H}_c
\end{eqnarray}

L'état final, $\boldsymbol{\sigma}'$, est atteint après la suppression de tous les comptes qui apparaissent dans la liste de suicide:
\begin{eqnarray}
\boldsymbol{\sigma}' & \equiv & \boldsymbol{\sigma}^* \quad \text{except} \\
\forall i \in A_\mathbf{s}: \boldsymbol{\sigma}'[i] & \equiv & \varnothing
\end{eqnarray}

Et finalement, nous spécifions $\Upsilon^g$, le gaz total utilisé dans cette transaction et $\Upsilon^\mathbf{l}$, les logs créés par cette transaction:
\begin{eqnarray}
\Upsilon^g(\boldsymbol{\sigma}, T) & \equiv & T_g - g' \\
\Upsilon^\mathbf{l}(\boldsymbol{\sigma}, T) & \equiv & A_\mathbf{l}
\end{eqnarray}

Ils sont utilisés pour aider à définir le reçu de la transaction qui sera détaillé plus bas.

%In the case that $s = m$ then we simply return the Ether back to the sender/miner, collapsing the exception into:
%\begin{eqnarray}
%\boldsymbol{\sigma}'[s]_b & \equiv & \boldsymbol{\sigma}_P[s]_b + g
%\end{eqnarray}

\section{Création de contrat} \label{ch:create}

Il existe un certain nombre de paramètres intrinsèques utilisés quand on crée un compte: expéditeur ($s$), \textbf{\textit{transactor}} originel ($o$), prix du gaz ($p$), dotation ($v$) assemblés avec un tableau d'octets de longueur variable, $\mathbf{i}$, le code EVM d'initialisation et enfin la profondeur actuelle de la pile d'appel de message/création de contrat ($e$)

Nous définissons formellement la fonction de création comme la fonction $\Lambda$ qui évalue, à partir de ces valeurs et de l'état $\boldsymbol{\sigma}$, le tuple contenant le nouvel état, le gaz restant et le substrat de transaction augmenté $(\boldsymbol{\sigma}', g', A)$, comme en section  \ref{ch:transactions}:
\begin{equation}
(\boldsymbol{\sigma}', g', A) \equiv \Lambda(\boldsymbol{\sigma}, s, o, g, p, v, \mathbf{i}, e)
\end{equation}

L'adresse du nouveau compte est défini comme étant les 160 bits de droite de l'empreinte Keccak de l'encodage RLP de la structure ne contenant que l'expéditeur et le nonce. Nous définissons donc l'adresse résultante pour le nouveau compte $a$:
\begin{equation}
a \equiv \mathcal{B}_{96..255}\Big(\mathtt{\tiny KEC}\Big(\mathtt{\tiny RLP}\big(\;(s, \boldsymbol{\sigma}[s]_n - 1)\;\big)\Big)\Big)
\end{equation}

où $\mathtt{\tiny KEC}$ est la fonction de hachage Keccak sur 256 bits, $\mathtt{\tiny RLP}$ est la fonction d'encodage RLP, $\mathcal{B}_{a..b}(X)$ donne une valeur binaire contenant les bits des indices dans l'intervalle $[a, b]$ des données binaires $X$ et $\boldsymbol{\sigma}[x]$ est l'état de l'adresse de $x$ ou $\varnothing$ si aucun n'existe. Notons que nous utilisons un de moins que la valeur du nonce de l'expéditeur; nous alléguons que nous avons incrémenté le nonce du compte de l'expéditeur avant cet appel et la valeur utilisée est donc celle du début de la transaction ou de l'opération de VM responsable.

Le nonce du compte est initialement défini à zéro, le solde à la valeur passée, la mémoire de stockage à vide et l'empreinte du code à l'empreinte Keccak sur 256 bits de la chaîne vide; la valeur passée est également défalquée du solde de l'expéditeur. Donc, l'état modifié devient $\boldsymbol{\sigma}^*$:
\begin{equation}
\boldsymbol{\sigma}^* \equiv \boldsymbol{\sigma} \quad \text{except:}
\end{equation}
\begin{eqnarray}
\boldsymbol{\sigma}^*[a] &\equiv& \big( 0, v + v', \mathtt{\tiny TRIE}(\varnothing), \mathtt{\tiny KEC}\big(()\big) \big) \\
\boldsymbol{\sigma}^*[s]_b &\equiv& \boldsymbol{\sigma}[s]_b - v
\end{eqnarray}

où $v'$ est la valeur préexistante du compte le cas échéant:
\begin{equation}
v' \equiv \begin{cases}
0 & \text{si} \quad \boldsymbol{\sigma}[a] = \varnothing\\
\boldsymbol{\sigma}[a]_b & \text{sinon}
\end{cases}
\end{equation}

%It is asserted that the state database will also change such that it defines the pair $(\mathtt{\tiny KEC}(\mathbf{b}), \mathbf{b})$.

Enfin, le compte est initialisé par l'exécution du code EVM d'initialisation $\mathbf{i}$ d'après le modèle d'exécution (voir la section \ref{ch:model}). L'exécution du code peut engendrer plusieurs événements qui ne sont pas internes à l'état d'exécution: la mémoire de stockage peut être altérée, des comptes supplémentaires peuvent être créés et d'autres appels de message peuvent être lancés. En tant que telle, la fonction d'exécution de code $\Xi$ donne un tuple de l'état résultant $\boldsymbol{\sigma}^{**}$, du gaz disponible restant $g^{**}$, du substrat accru $A$ et du code du corps du compte $\mathbf{o}$.

\begin{equation}
(\boldsymbol{\sigma}^{**}, g^{**}, A, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}^*, g, I) \\
\end{equation}
où $I$ contient les paramètres de l'environnement d'exécution tels que définis en section \ref{ch:model}, c'est-à-dire:
\begin{eqnarray}
I_a & \equiv & a \\
I_o & \equiv & o \\
I_p & \equiv & p \\
I_\mathbf{d} & \equiv & () \\
I_s & \equiv & s \\
I_v & \equiv & v \\
I_\mathbf{b} & \equiv & \mathbf{i} \\
I_e & \equiv & e
\end{eqnarray}

$I_\mathbf{d}$ donne le tuple vide puisqu'il n'y a pas de données en entrée de cet appel. $I_H$ n'a pas de traitement spécial et est déterminé à partir de la blockchain.

L'exécution du code diminue le gaz, lequel ne peut pas descendre en-dessous de zéro, donc l'exécution peut sortir avant que le code ne soit arrivé à un état d'arrêt. Dans ces cas exceptionnel (et dans plusieurs autres), nous disons qu'une exception \textit{Out-of-Gas} (panne d'essence) s'est produite: l'état évalué est défini comme étant l'ensemble vide, $\varnothing$, et l'opération de création dans son intégralité ne doit avoir aucun effet sur l'état, le laissant dans les faits tel qu'il était immédiatement avant la tentative de création.

Si le code d'initialisation se termine avec succès, un coût final de création de contrat est payé, le coût de dépôt du code, $c$, étant proportionnel à la taille du code du contrat créé:
\begin{equation}
c \equiv G_{codedeposit} \times |\mathbf{o}|
\end{equation}

S'il n'y a pas assez de gaz restant pour payer ceci, c'est-à-dire $g^{**} < c$, alors nous déclarons également une exception Out-of-Gas.

Le gaz restant sera à zéro dans ces circonstances exceptionnelles, c'est-à-dire que si la création a été conduite à la réception d'une transaction, alors cela n'affecte pas le paiement du coût intrinsèque de la création du contrat; celui-ci est payé de toute manière. Cependant, la valeur de la transaction n'est pas transférée à l'adresse du contrat avorté quand nous sommes Out-of-Gas.

Si ce type d'exception ne se produit pas, alors le gaz restant est renvoyé à l'\textbf{\textit{originator}} et l'état maintenant altéré a le droit de persister. Nous pouvons donc formellement spécifier l'état, le gaz et le sous-état résultants par $(\boldsymbol{\sigma}', g', A)$ où:

\begin{align}
\quad g' &\equiv \begin{cases}
0 & \text{si} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
g^{**} & \text{si} \quad g^{**}<c \wedge H_i<\firsthomesteadblock \\
g^{**} - c & \text{sinon} \\
\end{cases} \\
\quad \boldsymbol{\sigma}' &\equiv  \begin{cases}
\boldsymbol{\sigma} & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} & \text{if} \quad g^{**}<c \wedge H_i<\firsthomesteadblock \\
\boldsymbol{\sigma}^{**} \quad \text{except:} & \\
\quad\boldsymbol{\sigma}'[a]_c = \texttt{\small KEC}(\mathbf{o}) & \text{sinon}
\end{cases}
\end{align}

L'exception dans la détermination de $\boldsymbol{\sigma}'$ dicte que $\mathbf{o}$, la séquence d'octets résultant de l'exécution du code d'initialisation, spécifie le code final du corps du compte nouvellement créé.

On remarque que l'intention à partir du bloc \firsthomesteadblock\  ({\it Homestead}) est que le résultat est soit un nouveau contrat créé avec succès avec sa dotation, soit aucun contrat et aucun transfert de valeur. Avant {\it Homestead}, s'il n'y avait pas assez de gaz pour payer $c$, un compte était créé à l'adresse du nouveau contrat, en même temps que tous les effets secondaires de l'initialisation, et la valeur était transférée mais aucun code de contrat n'était déployé.

\subsection{Subtilités}
Notons qu'alors que le code d'initialisation est en train de s'exécuter, l'adresse nouvellement crééee existe mais sans code de corps intrinsèque. Un appel de message qu'il reçoit pendant ce temps n'engendre donc aucune exécution de code. Si l'exécution de l'initialisation se termine par une instruction {\small SUICIDE}, cela importe peu puisque le compte est supprimé avant la fin de la transaction. Pour un code {\small STOP}, ou si le code renvoyé est vide, alors l'état reste avec un compte zombie et tout solde résiduel reste à jamais verrouillé dans ce compte.

\section{Appel de message} \label{ch:call}
Lors de l'exécution d'un appel de message, plusieurs paramètres sont requis: émetteur ($s$), créateur de la transaction ($o$), récepteur ($r$), le compte dont le code doit être exécuté ($c$, habituellement le même que le récepteur), le gaz disponible ($g$), valeur ($v$) et prix du gaz ($p$) ensemble avec un tableau d'octets de longueur arbitraire, $\mathbf{d}$, les données d'entrée de l'appel de message et finalement la hauteur actuelle de la pile du appel de message ou de la création de contrat ($e$).

À part l'évaluation de nouveaux états et de leurs sous-états, un appel de message a aussi un autre composant---les données de sortie désignées par le tableau d'octets $\mathbf{o}$. Il est ignoré durant les exécutions de transactions, cependant les appels de message peuvent être lancés par l'exécution de code dans la VM et dans ce cas cette information est utilisée.
\begin{equation}
(\boldsymbol{\sigma}', g', A, \mathbf{o}) \equiv \Theta(\boldsymbol{\sigma}, s, o, r, c, g, p, v, \tilde{v}, \mathbf{d}, e)
\end{equation}
Notons que nous devons différencier la valeur qui doit être transférée $v$, de la valeur apparente dans le contexte d'execution $\tilde{v}$, pour l'instruction {\small DELEGATECALL}.

On définit $\boldsymbol{\sigma}_1$, le premier état de transition comme l'état original mais avec la valeur transférée de l'émetteur au récepteur:
\begin{equation}
\boldsymbol{\sigma}_1[r]_b \equiv \boldsymbol{\sigma}[r]_b + v \quad\wedge\quad \boldsymbol{\sigma}_1[s]_b \equiv \boldsymbol{\sigma}[s]_b - v
\end{equation}

Au long du présent travail, il est admis que $\boldsymbol{\sigma}_1[r]$ était indéfini à l'origine, il va être créé comme un compte sans code ou état et avec zéro solde ou nonce. ainsi la précédente équation doit être interprétée comme suit:
\begin{equation}
\boldsymbol{\sigma}_1 \equiv \boldsymbol{\sigma}_1' \quad \text{except:} \\
\end{equation}
\begin{equation}
\boldsymbol{\sigma}_1[s]_b \equiv \boldsymbol{\sigma}_1'[s]_b - v
\end{equation}
\begin{equation}
\text{and}\quad \boldsymbol{\sigma}_1' \equiv \boldsymbol{\sigma} \quad \text{except:} \\
\end{equation}
\begin{equation}
\begin{cases}
\boldsymbol{\sigma}_1'[r] \equiv (v, 0, \mathtt{\tiny KEC}(()), \mathtt{\tiny TRIE}(\varnothing)) & \text{if} \quad \boldsymbol{\sigma}[r] = \varnothing \\
\boldsymbol{\sigma}_1'[r]_b \equiv \boldsymbol{\sigma}[r]_b + v & \text{otherwise}
\end{cases}
\end{equation}

Le code associé au compte (identifié comme le fragment dont l'empreinte Keccack $\boldsymbol{\sigma}[c]_c$) est exécuté conformément au modèle d'exécution (voir section \ref{ch:model}). Comme avec la création de contrat, si l'exécution cesse pour cause d'anomalie (i.e. à cause de l'épuisement de la fourniture en gaz, épuisement de la pile, saut invalide ou instruction invalide), alors l'appelant n'est pas remboursé et l'état est remis au point immédiatement avant le transfert de solde (i.e. $\boldsymbol{\sigma}$).

\begin{eqnarray}
\boldsymbol{\sigma}' & \equiv & \begin{cases}
\boldsymbol{\sigma} & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} & \text{otherwise}
\end{cases} \\
(\boldsymbol{\sigma}^{**}, g', \mathbf{s}, \mathbf{o}) & \equiv & \begin{cases}
\Xi_{\mathtt{ECREC}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 1 \\
\Xi_{\mathtt{SHA256}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 2 \\
\Xi_{\mathtt{RIP160}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 3 \\
\Xi_{\mathtt{ID}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 4 \\
\Xi(\boldsymbol{\sigma}_1, g, I) & \text{otherwise} \end{cases} \\
I_a & \equiv & r \\
I_o & \equiv & o \\
I_p & \equiv & p \\
I_\mathbf{d} & \equiv & \mathbf{d} \\
I_s & \equiv & s \\
I_v & \equiv & \tilde{v} \\
I_e & \equiv & e \\
\text{Let} \; \mathtt{\tiny KEC}(I_\mathbf{b}) & = & \boldsymbol{\sigma}[c]_c
\end{eqnarray}

On suppose que le client aura stocké la paire $(\mathtt{\tiny KEC}(I_\mathbf{b}), I_\mathbf{b})$ préalablement pour pouvoir déterminer $I_\mathbf{b}$.

Comme on pourra voir, il y a quatre exceptions au framework général d'exécution $\Xi$ lors de l'évaluation d'un appel de message: ce sont les quatre contrats `précompilés', compris comme des éléments d'architecture préliminaires qui pourront ultérieurement devenir des \textit{extensions natives}. Les quatre contrats aux adresses 1, 2, 3 et 4 executent la fonction de récupération de la clé publique de courbe elliptique, le schema d'empreinte SHA2 256-bit, le schema d'empreinte RIPEMD 160-bit et la fonction d'identité respectivement.

Leur définition formelle complète est dans l'Annexe \ref{app:precompiled}.

\section{Modèle d'exécution} \label{ch:model}

Le modèle d'exécution spécifie la façon dont l'état du système est altéré étant donné une série d'instructions de bytecode et un petit tuple de données environnementales. On le spécifie par un modèle formel d'une machine à état nommée Ethereum Virtual Machine (EVM). Il s'agit d'une machine de Turing quasi-complète; la qualification de \textit{quasi} vient de ce que le traitement est intrinsèquement borné par un paramètre, \textit{gas} (gaz), qui limite le traitement total effectué.

\subsection{Fondamentaux}

L'EVM est une architecture simple basée sur une pile. La taille des mots de la machine (et donc la taille de l'élément de la pile) est de 256 bits. Ce choix est destiné à faciliter le mécanisme d'empreinte Keccak-256 et les calculs de courbes elliptiques. Le modèle mémoire est un simple tableau d'octets adressé par mots. La pile a une taille maximale de $1024$. La machine comporte également un modèle de stockage indépendant, conceptuellement similaire à celui de la mémoire mais, au lieu d'un tableau d'octets, il s'agit d'un tableau de mots adressé par mots. Au contraire de la mémoire, qui est volatile, le stockage est non volatil et est maintenu comme partie de l'état système. Tous les emplacements tant en stockage qu'en mémoire sont définis à zéro à l'initialisation.

La machine n'est pas conçue selon l'architecture standard de Von Neumann. Au lieu de stocker le code des programmes dans une mémoire transitoire ou permanente générique, il est mis à part dans une ROM virtuelle avec laquelle seule une instruction spécialisée peut interagir.

La machine peut entrer dans une exécution exceptionnelles pour plusieurs raisons, comme un dépassement de dépilage et des instructions invalides. Comme l'exception \textit{out-of-gas} (OOG), elles ne laissent pas les changements d'état intacts. La machine s'arrête immédiatement et rapporte le problème à l'agent d'exécution (soit le processeur de transactions, soit, récursivement, l'environnement d'exécution du lancement) qui le gèrera de son côté.

\subsection{Aperçu des frais}

Les \textit{fees} (frais), chiffrés en gaz, sont décomptés en trois circonstances distinctes, toutes trois étant des prérequis à l'exécution d'une opération. D'abord et le plus fréquemment, les frais intrinsèques au calcul de l'opération (voir Appendice \ref{app:fees}). Ensuite le gaz peut être déduit afin de constituer le paiement d'un appel de message ou d'une création de contrat subordonné; cela fait partie du paiement de {\small CREATE}, {\small CALL} et {\small CALLCODE}. Enfin, le gaz peut être payé en raison de l'augmentation de l'utilisation de la mémoire.

Pendant l'exécution d'un compte,
% l'exécution appartement à un compte ?
les frais totaux dûs pour l'utilisation de la mémoire sont proportionnels au plus petit multiple de 32 octets qui est requis tel que tous les index mémoire (en lecture ou en écriture) sont inclus dans l'intervalle. Le paiement se fait en juste-à-temps; le référencement d'une zone de mémoire plus grande d'au moins 32 octets que la mémoire précédemment référencée résulte avec certitude en des frais d'utilisation mémoire supplémentaires. Ces frais rendent extrêmement improbable un adressage dépassant la limite de 32 bits. Cela dit, les implémentations doivent être capables de gérer cette éventualité.

Les frais de stockage se comportent de manière légèrement différente. Pour inciter à minimiser l'utilisation du stockage (qui correspond directement à une base de données d'état plus grande sur tous les n\oe{}uds, les frais d'exécution d'une opération supprimant une entrée dans le stockage ne sont pas seulement abandonnés mais un remboursement explicite est effectué; dans les faits, ce remboursement est payé immédiatement puisque l'utilisation initiale d'un emplacement mémoire coûte bien plus qu'une utilisation courante.

%More formally, given an instruction, it is possible to calculate the gas cost of executing it as follows:
%
%\begin{itemize}
%\item {\small SHA3} costs $G_{sha3}$ gas
%\item {\small SLOAD} costs $G_{sload}$ gas
%\item {\small BALANCE} costs $G_{balance}$ gas
%\item {\small SSTORE} costs $d.G_{sstore}$ gas where:
%\begin{itemize}
%\item $d = 2$ if the new value of the storage is non-zero and the old is zero;
%\item $d = 0$ if the new value of the storage is zero and the old is non-zero;
%\item $d = 1$ otherwise.
%\end{itemize}
%\item {\small CALL} costs $G_{call}$, though additional gas may be taken for the execution of the account's associated code, if non-empty.
%\item {\small CREATE} costs $G_{create}$, though additional gas may be taken for the execution of the account initialisation code.
%\item {\small STOP} costs $G_{stop}$ gas
%\item {\small SUICIDE} costs $G_{suicide}$ gas
%\item All other operations cost $G_{step}$ gas.
%\end{itemize}
%
%Additionally, when memory is accessed with {\small MSTORE}, {\small MSTORE8}, {\small MLOAD}, {\small CALLDATACOPY}, {\small CODECOPY}, {\small RETURN}, {\small SHA3}, {\small CREATE} or {\small CALL}, the memory should be enlarged to the smallest multiple of words such that all addressed bytes now fit in it.

Voir l'appendice \ref{app:vm} pour une définition rigoureuse du coût en gaz de l'EVM.

%Whenever a higher memory index is referenced, the fee difference to take it to the higher usage from the original (lower) usage is charged. Notably, because {\small MSTORE} and {\small MLOAD} operate on word lengths, they implicitly increase the highest-accessed index to 31 greater than their target index.

\subsection{Environnement d'exécution}

En plus de l'état du système $\boldsymbol{\sigma}$ et du gaz restant pour le traitement $g$, l'agent d'exécution doit fournir plusieurs informations importantes utilisées dans l'environnement d'exécution, qui sont contenues dans le tuple $I$:

\begin{itemize}
\item $I_a$, l'adresse du compte qui possède le code en cours d'exécution.
\item $I_o$, l'adresse de l'expéditeur de la transaction d'où provient cette exécution.
\item $I_p$, le prix du gaz dans la transaction d'où provient cette exécution.
\item $I_\mathbf{d}$, le tableau d'octets qui constitue les données d'entrée pour cette exécution; si l'agent d'exécution est une transaction, il s'agit des données de transaction.
\item $I_s$, l'adresse du compte qui a provoqué l'exécution du code; si l'agent d'exécution est une transaction, il s'agit de l'expéditeur de la transaction.
\item $I_v$, la valeur, en Wei, passée à ce compte comme faisant partie de la même procédure que l'exécution; si l'agent d'exécution est une transaction, c'est la valeur de la transaction.
\item $I_\mathbf{b}$, le tableau d'octets qui est le code machine à exécuter.
\item $I_H$, l'en-tête de bloc du bloc actuel.
\item $I_e$, la profondeur de l'appel de message actuel ou de la création de contrat actuelle (c.à.d. le nombre de {\small CALL} ou de {\small CREATE} exécutés à ce moment).
\end{itemize}

Le modèle d'exécution définit la fonction $\Xi$, qui peut calculer l'état résultant $\boldsymbol{\sigma}'$, le gaz restant $g'$, la liste de suicide $\mathbf{s}$, la série de logs $\mathbf{l}$, les remboursements $r$ et la sortie résultante, $\mathbf{o}$, étant données ces définitions:
\begin{equation}
(\boldsymbol{\sigma}', g', \mathbf{s}, \mathbf{l}, r, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}, g, I)
\end{equation}

\subsection{Aperçu de l'exécution}

Nous devons maintenant définir la fonction $\Xi$. Dans la plupart des implémentations concrètes, elle sera conçue comme une progression itérative de la paire comprenant l'état complet du système, $\boldsymbol{\sigma}$ et de l'état de la machine,  $\boldsymbol{\mu}$. Formellement, nous la définissons récursivement avec une fonction $X$, qui utilise une fonction itératrice $O$ (qui définit le résultat d'un cycle unique de la machine à état) avec les fonctions $Z$, qui détermine si l'état actuel est un état d'arrêt exceptionnel de la machine, et $H$, spécifiant les données de sortie de l'instruction si et seulement si l'état actuel est un état d'arrêt normal de la machine.

La séquence vide, notée $()$, n'est pas égale à l'ensemble vide, noté $\varnothing$; c'est important au moment d'interpréter la sortie de $H$, qui donne $\varnothing$ quand l'exécution doit continuer mais une série (potentiellement vide) quand l'exécution doit s'arrêter.
\begin{eqnarray}
\Xi(\boldsymbol{\sigma}, g, I) & \equiv & X_{0,1,2,4}\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A^0, I)\big) \\
\boldsymbol{\mu}_g & \equiv & g \\
\boldsymbol{\mu}_{pc} & \equiv & 0 \\
\boldsymbol{\mu}_\mathbf{m} & \equiv & (0, 0, ...) \\
\boldsymbol{\mu}_i & \equiv & 0 \\
\boldsymbol{\mu}_\mathbf{s} & \equiv & ()
\end{eqnarray}
\begin{equation}
X\big( (\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \big) \equiv \begin{cases}
\big(\varnothing, \boldsymbol{\mu}, A^0, I, ()\big) & \text{si} \quad Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I)\\
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \cdot \mathbf{o} & \text{si} \quad \mathbf{o} \neq \varnothing\\
X\big(O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) & \text{sinon}\\
\end{cases}
\end{equation}

où
\begin{eqnarray}
\mathbf{o} & \equiv & H(\boldsymbol{\mu}, I) \\
(a, b, c) \cdot d & \equiv & (a, b, c, d)
\end{eqnarray}

On remarque que nous devons omettre la quatrième value du tuple renvoyé par $X$ pour évaluer correctement $\Xi$, d'où la notation $X_{0,1,2,4}$.

On cycle donc dans $X$ (ici, récursivement, mais on s'attend généralement à ce que les implémentations emploient une simple boucle itérative) jusqu'à ce que soit $Z$ devienne vrai, indiquant ainsi que l'état actuel est exceptionnel et que la machine doit être arrêtée en revenant sur toutes les modifications, ou jusqu'à ce que $H$ devienne une série (au lieu de l'ensemble vide) indiquant que la machine a atteint un arrêt contrôlé.

\subsubsection{État de la machine}
L'état de la machine $\boldsymbol{\mu}$ est défini par le tuple $(g, pc, \mathbf{m}, i, \mathbf{s})$ qui sont le gaz disponible, le compteur de programme $pc \in \mathbb{P}_{256}$, le contenu de la mémoire, le nombre de mots actifs en mémoire (en comptant en continu depuis la position 0) et le contenu de la pile. Le contenu de la mémoire $\boldsymbol{\mu}_\mathbf{m}$ est une série de zéros de taille $2^{256}$.

Dans un but de lisibilité, les mnémoniques d'instructions, écrites en petites capitales (comme {\small ADD}), doivent être interprétées comme leurs équivalents numériques; la table complète des instructions et de leurs spécificités est donnée à l'Appendice \ref{app:vm}.

Dans le but de définir $Z$, $H$ et $O$, nous définissons $x$ comme l'opération actuelle à exécuter:
\begin{equation}\label{eq:currentoperation}
w \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_{pc}] & \text{si} \quad \boldsymbol{\mu}_{pc} < \lVert I_\mathbf{b} \rVert \\
\text{\small STOP} & \text{sinon}
\end{cases}
\end{equation}

Nous supposons également les montants fixes de $\mathbf{\delta}$ et $\mathbf{\alpha}$, en spécifiant les éléments de la pile qui ont été supprimés et ajoutés, les deux étant \textit{subscriptables} sur l'instruction et une fonction de coût d'instruction $C$ qui donne le coût total, en gaz, de l'exécution de l'instruction donnée.
%We also assume the fixed amounts of $\mathbf{\delta}$ and $\mathbf{\alpha}$, specifying the stack items removed and added, both subscriptable on the instruction and an instruction cost function $C$ evaluating to the full cost, in gas, of executing the given instruction.

\subsubsection{Arrêt exceptionnel}

La fonction d'arrêt exceptionnel $Z$ est définie par:
\begin{equation}
Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \equiv
\begin{array}[t]{l}
\boldsymbol{\mu}_g < C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \quad \vee \\
\mathbf{\delta}_w = \varnothing \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert < \mathbf{\delta}_w \quad \vee \\
( w \in \{ \text{\small JUMP}, \text{\small JUMPI} \} \quad \wedge \\ \quad \boldsymbol{\mu}_\mathbf{s}[0] \notin D(I_\mathbf{b}) ) \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert - \mathbf{\delta}_w + \mathbf{\alpha}_w > 1024 \quad
\end{array}
\end{equation}

Cela établit que l'éxécution se trouve dans un état d'arrêt exceptionnel s'il n'y a pas assez de gaz, si l'instruction est invalide (et donc son \textit{subscript} est indéfini), s'il n'y a pas suffisamment d'éléments de pile, si une destination de {\small JUMP}/{\small JUMPI} est invalide ou si la nouvelle taille de la pile serait supérieure à 1024. Le lecteur attentif aura compris que cela signifie également qu'aucune instruction ne peut, par son exécution, provoquer un arrêt exceptionnel.

\subsubsection{Validité d'une destination de saut}

Nous avons auparavant utilisé $D$ comme fonction pour déterminer l'ensemble des destinations de saut valides étant donné le code en train de tourner. Nous définission ceci comme toute position dans le code occupée par une instruction {\small JUMPDEST}.

Toutes ces positions doivent se trouver sur des limites d'instruction valides au lieu d'occuper la partie de données des opération {\small PUSH} et doivent apparaître dans la portion explicitement définie du code (et non dans les opérations {\small STOP} implicitement définies qui les suivent).

Formellement:
\begin{equation}
D(\mathbf{c}) \equiv D_J(\mathbf{c}, 0)
\end{equation}

où:
\begin{equation}
D_J(\mathbf{c}, i) \equiv \begin{cases}
\{\} & \text{si} \quad i \geqslant |\mathbf{c}|  \\
\{ i \} \cup D_J(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{if} \quad \mathbf{c}[i] = \text{\small JUMPDEST} \\
D_J(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{sinon} \\
\end{cases}
\end{equation}

où $N$ est la position de l'instruction valide suivante dans le code, en sautant les données d'une instruction {\small PUSH} le cas échéant:
\begin{equation}
N(i, w) \equiv \begin{cases}
i + w - \text{\small PUSH1} + 2 & \text{si} \quad w \in [\text{\small PUSH1}, \text{\small PUSH32}] \\
i + 1 & \text{sinon} \end{cases}
\end{equation}

\subsubsection{Arrêt normal}

La fonction d'arrêt normal $H$ est définie par:
\begin{equation}
H(\boldsymbol{\mu}, I) \equiv \begin{cases}
H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) & \text{si} \quad w = \text{\small RETURN} \\
() & \text{if} \quad w \in \{ \text{\small STOP}, \text{\small SUICIDE} \} \\
\varnothing & \text{sinon}
\end{cases}
\end{equation}

L'opération d'arrêt renvoyant les données, \text{\small RETURN}, a une fonction spéciale $H_{\text{\tiny RETURN}}$, définie à l'Appendice \ref{app:vm}.

\subsection{Le cycle d'exécution}

Les éléments de la pile sont ajoutés ou retirés de la partie la plus à gauche et dont l'index est le plus bas de la série; tous les autres éléments restent inchangés:
\begin{eqnarray}
O\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) & \equiv & (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \\
\Delta & \equiv & \mathbf{\alpha}_w - \mathbf{\delta}_w \\
\lVert\boldsymbol{\mu}'_\mathbf{s}\rVert & \equiv & \lVert\boldsymbol{\mu}_\mathbf{s}\rVert + \Delta \\
\quad \forall x \in [\mathbf{\alpha}_w, \lVert\boldsymbol{\mu}'_\mathbf{s}\rVert): \boldsymbol{\mu}'_\mathbf{s}[x] & \equiv & \boldsymbol{\mu}_\mathbf{s}[x+\Delta]
\end{eqnarray}

Le gaz est réduit du coût en gaz de l'instruction et, pour la plupart des instructions, le compteur de programme s'incrémente à chaque cycle, pour les trois exceptions, nous posons une fonction $J$, \textit{subscripted} par une ou deux instructions, qui donne les valeurs en accord avec:
\begin{eqnarray}
\quad \boldsymbol{\mu}'_{g} & \equiv & \boldsymbol{\mu}_{g} - C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \\
\quad \boldsymbol{\mu}'_{pc} & \equiv & \begin{cases}
J_{\text{JUMP}}(\boldsymbol{\mu}) & \text{si} \quad w = \text{\small JUMP} \\
J_{\text{JUMPI}}(\boldsymbol{\mu}) & \text{si} \quad w = \text{\small JUMPI} \\
N(\boldsymbol{\mu}_{pc}, w) & \text{sinon}
\end{cases}
\end{eqnarray}

En général, nous supposons que la mémoire, la liste de suicide et l'état du système ne changent pas:
\begin{eqnarray}
\boldsymbol{\mu}'_\mathbf{m} & \equiv & \boldsymbol{\mu}_\mathbf{m} \\
\boldsymbol{\mu}'_i & \equiv & \boldsymbol{\mu}_i \\
A' & \equiv & A \\
\boldsymbol{\sigma}' & \equiv & \boldsymbol{\sigma}
\end{eqnarray}

Cependant, les instructions altèrent typiquement une ou plusieurs composantes de ces valeurs. Les composantes altérées listées par instruction sont notées à l'Appendice \ref{app:vm}, accompagnées des valeurs de $\alpha$ et de $\delta$ avec une description formelle des exigences en gaz.

\section{De l'arbre des blocs à la chaîne des blocs} \label{ch:ghost}

La blockchain typique est un chemin de la racine jusqu'à la feuille à travers toute l'arborescence des blocs. Pour atteindre le consensus sur ce chemin, conceptuellement, nous identifions celui où le plus de calculs ont été effectués, c'est-à-dire le chemin dont \textit{le poids est le plus élevé}. L'un des facteurs qui permettent de déterminer le chemin dont poids le plus élevé est clairement le numéro de bloc de la feuille, qui est équivalent au nombre de blocs sans compter le bloc \textit{genesis} non miné, dans le chemin. Plus le chemin est long, plus l'effort nécessaire pour arriver à la feuille a été grand. Ce principe est comparable à d'autres, comme ceux employés dans les protocoles dérivés de Bitcoin.

Comme un en-tête de bloc inclut la difficulté, il suffit à lui seul à valider le calcul effectué. Chaque bloc contribue au calcul total, ou à la \textit{diffulté totale} d'une chaîne.

En conséquence, nous définissons récursivement la difficulté totale du bloc $B$ comme suit:
\begin{eqnarray}
B_t & \equiv & B'_t + B_d \\
B' & \equiv & P(B_H)
\end{eqnarray}

Cela implique qu'étant donné un bloc $B$, $B_t$ est sa difficulté totale, $B'$ est son bloc parent et $B_d$ est sa difficulté.

\section{Block Finalisation} \label{ch:finalisation}

Le traitement de finalisation d'un bloc comporte quatre étapes:

\begin{enumerate}
\item Valider (ou, pour du minage, déterminer) les \textit{ommers} (oncles);
\item Valider (ou, pour du minage, déterminer) les transactions;
\item Appliquer les récompenses;
\item Vérifier (ou, pour du minage, calculer) l'état et le nonce.
\end{enumerate}

\subsection{Validation des oncles}

La validation des en-têtes des oncles ne signifie rien de plus que la vérification que chaque en-tête d'oncle est un en-tête valide et qu'il satisfait la relation de l'oncle de $N$ième génération au bloc actuel où $N \leq 6$. Le maximum d'en-têtes d'oncles est deux. Formellement:
\begin{equation}
\lVert B_\mathbf{U} \rVert \leqslant 2 \bigwedge_{U \in B_\mathbf{U}} V(U) \; \wedge \; k(U, P(B_H)_H, 6)
\end{equation}

où $k$ note la propriété ``is-kin'':
\begin{equation}
k(U, H, n) \equiv \begin{cases} false & \text{si} \quad n = 0 \\
s(U, H) &\\
\quad \vee \; k(U, P(H)_H, n - 1) & \text{sinon}
\end{cases}
\end{equation}

et $s$ note la propriété ``is-sibling'':
\begin{equation}
s(U, H) \equiv (P(H) = P(U)\; \wedge \; H \neq U \; \wedge \; U \notin B(H)_\mathbf{U})
\end{equation}
où $B(H)$ est le bloc de l'en-tête correspondant $H$.

\subsection{Validation de transaction}

%where $s[i]$ equals the root of the state trie immediately after the execution of the transaction $B_\mathbf{T}[i]$, and $g[i]$ the total gas used immediately after said transaction.

Le \textbf{gasUsed} donné doit correspondre fidèlement aux transactions listées:  ${B_H}_g$, le gaz total  utilisé dans le bloc doit être égal au gaz accumulé utilisé d'après la transaction finale:
\begin{equation}
{B_H}_g = \ell(\mathbf{R})_u
\end{equation}

\subsection{Application des récompenses}

L'application des récompenses à un bloc implique d'augmenter le solde des comptes de l'adresse du bénéficiaire du bloc et de chaque oncle d'un certain montant. Nous ajoutons $R_b$ au compte du bénéficiaire; pour chaque oncle, nous ajoutons un $\frac{1}{32}$ supplémentaire de la récompense du bloc à celui du bénéficiaire du bloc et le bénéficiaire de l'oncle est récompensé en fonction du numéro de bloc. Formellement, nous définissons la fonction $\Omega$:
\begin{eqnarray}
\Omega(B, \boldsymbol{\sigma}) & \equiv & \boldsymbol{\sigma}': \boldsymbol{\sigma}' = \boldsymbol{\sigma} \quad \text{excepté:} \\
\boldsymbol{\sigma}'[{B_H}_c]_b & = & \boldsymbol{\sigma}[{B_H}_c]_b + (1 + \frac{\lVert B_\mathbf{U}\rVert}{32})R_b \\
\forall_{U \in B_\mathbf{U}}: \\ \nonumber
 \boldsymbol{\sigma}'[U_c]_b & = & \boldsymbol{\sigma}[U_c]_b + (1 + \frac{1}{8} (U_i - {B_H}_i)) R_b
\end{eqnarray}

S'il existe des collision des adresses de bénéficiaires entre les oncles et le bloc (c'est-à-dire deux oncles ave la même adresse de bénéficiaire ou un oncle avec la même adresse de bénéficiaire que celle du bloc actuel), les additions sont appliquées de manière cumulative.

Nous définissons la récompense de bloc qui est de 5 Ether:
\begin{equation}
\text{Let} \quad R_b = 5 \times 10^{18}
\end{equation}

\subsection{Validation de l'état et du nonce}\label{sec:statenoncevalidation}

Nous pouvons maintenant définir la fonction, $\Gamma$, qui fait correspond un bloc $B$ à son état d'initialisation:
\begin{equation}
\Gamma(B) \equiv \begin{cases}
\boldsymbol{\sigma}_0 & \text{si} \quad P(B_H) = \varnothing \\
\boldsymbol{\sigma}_i: \mathtt{\small TRIE}(L_S(\boldsymbol{\sigma}_i)) = {P(B_H)_H}_r & \text{sinon}
\end{cases}
\end{equation}

Ici, $\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma}_i))$ signifie l'empreinte du n\oe{}ud racine du trie (arbre préfixe) d'état $\boldsymbol{\sigma}_i$; on supose que les implémentations le stockerdont dans la base d'état, ce qui est trivial et efficient puisque le trie est par nature une structure de données immuable.

Et nous définissons finalement $\Phi$, la fonction de transition de bloc, qui fait correspondre un bloc incomplet $B$ à un bloc complet $B'$:
\begin{eqnarray}
\Phi(B) & \equiv & B': \quad B' = B^* \quad \text{excepté:} \\
B'_n & = & n: \quad x \leqslant \frac{2^{256}}{H_d} \\
B'_m & = & m \quad \text{avec } (x, m) = \mathtt{PoW}(B^*_{\hcancel{n}}, n, \mathbf{d}) \\
B^* & \equiv & B \quad \text{excepté:} \quad B^*_r = r(\Pi(\Gamma(B), B))
\end{eqnarray}
$\mathbf{d}$ étant un ensemble de données tel que spécifié à l'appendice \ref{app:ethash}.

Comme on l'a spécifié au début du présent travail, $\Pi$ est la fonction de transition d'état, qui est définie en termes de $\Omega$, la fonction de finalisation de bloc, et de $\Upsilon$, la fonction d'évaluation d'état, toutes deux maintenant bien définies.

Comme on l'a détaillé précédemment, $\mathbf{R}[n]_{\boldsymbol{\sigma}}$, $\mathbf{R}[n]_\mathbf{l}$ et $\mathbf{R}[n]_u$ sont les $n$ièmes états, logs et gaz cumulé correspondants utilisés après chaque transaction ($\mathbf{R}[n]_b$, le quatrième composant du tuple, a déjà été défini en termes de logs). Le précédent  est simplement défini comme l'état résultant de l'application de la transaction correspondante à l'état résultant de la transaction précédente (ou l'état initial du bloc dans le cas d'un première transaction de ce type):
\begin{equation}
\mathbf{R}[n]_{\boldsymbol{\sigma}} = \begin{cases} \Gamma(B) & \text{si} \quad n < 0 \\ \Upsilon(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n]) & \text{sinon} \end{cases}
\end{equation}

Dans le cas de $B_\mathbf{R}[n]_u$, nous prenons une approche similaire en définissant chaque élément comme le gaz utilisé en évaluant la transaction correspondante ajouté à l'élément précédent (ou zéro s'il s'agit du premier), nous donnant un total en cours;
\begin{equation}
\mathbf{R}[n]_u = \begin{cases} 0 & \text{si} \quad n < 0 \\
\begin{array}[b]{l}
\Upsilon^g(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n])\\ \quad + \mathbf{R}[n-1]_u
\end{array}
 & \text{sinon} \end{cases}
\end{equation}

Pour $\mathbf{R}[n]_\mathbf{l}$, nous utilisons la fonction $\Upsilon^\mathbf{l}$ que nous avons commodément définie dans la fonction d'exécution de transaction.
\begin{equation}
\mathbf{R}[n]_\mathbf{l} =
\Upsilon^\mathbf{l}(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n])
\end{equation}

Enfin, nous définissons $\Pi$ comme le nouvel état étant donnée la fonction de récompense de bloc $\Omega$ appliquée à l'état résultant de la transaction finale, $\ell(B_\mathbf{R})_{\boldsymbol{\sigma}}$:
\begin{equation}
\Pi(\boldsymbol{\sigma}, B) \equiv \Omega(B, \ell(\mathbf{R})_{\boldsymbol{\sigma}})
\end{equation}

Donc le mécanisme de transition de bloc, moins  $\mathtt{PoW}$, la fonction de preuve de travail, est défini.

\subsection{Preuve de travail de minage} \label{ch:pow}


La preuve de travail de minage (PoW) existe comme nonce cryptographique sécurisé nonce qui prouve au-delà du doute raisonnable qu'un montant particulier de calcul a été dépensé dans la détermination de telle valeur $n$ d'un token. Elle est utilisée pour renforcer la sécurité de la blockchain en donnant signification et crédibilité à la notion de difficulté (et, par extension, à la difficulté totale). Cependant, comme miner de nouveaux blocs apporte une récompense, la preuve de travail ne fonctionne pas seulement comme méthode de de sécurisation de la confiance dans le statut normatif de la blockchain pour le futur, mais aussi un moyen de distribution de la richesse.

Pour ces deux raisons, il y a deux buts importants assignés à la preuve de travail; premièrement, elle doit être aussi accessible que possible au plus grand nombre de personnes possibles. Le besoin de, ou rétribution par, des matériels spécialisés et spécifiques doit être minimisé. Ceci rend le modèle de distribution aussi ouvert que possible, et, dans l'idéal, fait de l'acte de miner une simble transformation de l'électricité en Ether à un taux grossièrement le même partout dans le monde.

Deuxièmement, il ne doit pas être possible de réaliser des profits surlinéaires, spécialement avec une barrière à l'entrée importante. Un tel mécanisme accorde à un adversaire fortuné un gain déséquilibrant de pouvoir de minage sur le réseau total et ainsi lui donne une récompense surlinéaire (et détourne de ce fait la distribution en sa faveur), réduisant en outre la sécurité du réseau.

Un fléau du monde Bitcoin est dû aux équipements ASIC. Ce sont des équipements informatiques spécialisés qui sont conçus pour effectuer une tâche unique. Dans le cas de Bitcoin cette tâche est la fonction SHA256. Comme les ASICs existent pour une fonction de preuve de travail, les deux objectifs ci-dessus sont menacés. Pour cette raison, une fonction de preuve de travail ASIC-resistante (i.e. difficile ou economiquement inefficace à implémenter dans ces équipements informatiques spécialisés) est identifiée à la proverbiale "silver bullet".

Il y a deux moyens d'obtenir l'ASIC-résistance; le premier est de le rendre sépquentiel par exigence en mémoire, i.e. composer la fonction de façon à ce que la détermination du nonce requière une telle quantité de mémoire et de bande passante que la mémoire ne puisse être utilisée en parallèle pour découvrir simultanément de multiples nonces. Le second est de rendre le type de calcul demandé d'ordre général ; la signification de "matériel spécialisé" pour un calcul d'ordre général est, naturellement, matériel généraliste et on peut escompter que les ordinateurs de bureau entrent dans une catégorie proche. Pour la version 1.0 d'Ethereum nous avons choisi le premier moyen.

Plus formellement, la fonction de preuve de travail prend la forme de $\mathtt{PoW}$ telle que:
\begin{equation}
m = H_m \quad \wedge \quad n \leqslant \frac{2^{256}}{H_d} \quad \text{with} \quad (m, n) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})
\end{equation}

Où $H_{\hcancel{n}}$ est le nouvel en-tête de bloc mais \textit{sans} le nonce et les composants mix-hash; $H_n$ est le nonce du header; $\mathbf{d}$ est un grand ensemble de données nécessaire pour calculer le mix-hash et $H_d$ est la difficulté du nouveau block (i.e. la difficulté de la section \ref{ch:ghost}). $\mathtt{PoW}$ iPoW est la fonction preuve de travail qui produit un tableau avec le premier élément comme mixhash et le deuxième élément un nombre pseudo-aléatoire cryptographiquement dépendant de $H$ et $\mathbf{d}$. L'algorithme sous-jacent se nomme Ethahsh et est décrit ci-dessous.

\subsubsection{Ethash}
Ethash est l'algorithme de preuve de travail pour la version 1.0 d'Ethereum. C'est la dernière version du Dagger-Hashimoto, présenté par \cite{dagger} et \cite{hashimoto}, malgre qu'il ne peut plus être appelé ainsi puisque nombre des fonctionnalités de ces deux algorithmes ont été grandement changées ces derniers mois de recherche et développement. Le comportement général de l'algorithme est le suivant: 

Il existe une graine qui peut être calculée pour chaque bloc en scannant son en-tête jusqu'à ce point. A pertir de la graine, on peut calculer un cache pseudo-aléatoire, de $J_{cacheinit}$ octets de taille initiale. Les clients légers stockent le cache. Depuis le cache on peut générer un ensemble de données, de $J_{datasetinit}$ octets de taille initiale, avec la propriété que chaque élément de l'ensemble de données dépend de seulement un petit nombre d'éléments du cache. Les clients complets et les mineurs stockent l'ensemble des données. L'ensemble des données croît linéairement avec le temps. 


Le minage consiste en sélectionnant des tranches de l'ensemble des données et en faisant des empreintes de leurs combinaisons. La vérification peut être faite avec peu de mémoire en utilisant le cache pour régénérer les éléments spécifiques de l'ensemble des données dont vous avez besoin, et ainsi vous n'avez besoin que de stocker le cache. L'ensemble des données est mis à jour tous les $J_{epoch}$ blocs, donc la grande majorité de l'effort de minage sera de lire les données, et non de les changer. les paramètres cités comme l'algorithme lui-même sont décrits en annexe \ref{app:ethash}.

\section{Implémentation des contrats}

IL existe plusieurs modèles d'ingénierie des contrats qui autorisent des fonctionnalités particulièrement utiles; je vais brièvement traiter de deux d'entre eux, les \textit{data feeds} (soures de données) et les nombres aléatoires.

\subsection{Sources de données}
Un contrat de source de données fournit un simple service: il donne accès à des informations du monde extérieur depuis Ethereum. L'exactitude en qualité et en temps de ces informations ne sont pas garanties et c'est la tâche d'un auteur de contrat secondaire -- le contrat qui utilise la source de données -- de déterminer la confiance qui peut être placée dans une source de données. 

Le modèle général implique un unique contrat dans Ethereum qui, à réception d'un appel de message, répond par une information en temps voulu concernant un phénomène extérieur, par exemple la température à New York. Cela peut être implémenté par un contrat qui renvoie cette valeur depuis un point connu dans la mémoire de stockage. Ce dernier doit être bien entendu maintenu avec la température correcte et la seconde partie du modèle implique donc un serveur externe faisant tourner un n\oe{}ud Ethereum qui, au moment précis de la découverte d'un nouveau bloc, crée une nouvelle transaction valide, envoyée au contrat, mettant la valeur en question dans la mémoire de stockage. Le code du contrat n'accepterait de mises à jour que depuis l'identité contenue dans le serveur.

\subsection{Nombre aléatoires}
La fourniture de nombres aléatoire au sein d'un système déterministe relève naturellement de l'impossible. Nous pouvons cependant aboutir à une approximation en utilisant des données qui sont généralement inconnues au moment de la transaction. Ces données comprennent l'empreinte du bloc, son horodatage et l'adresse de son bénéficiaire. Afin de compliquer le contrôle éventuel de ces valeurs par un mineur malveillant, il faudrait employer l'opération {\small BLOCKHASH} pour utiliser des empreintes des 256 blocs précédents comme nombres pseudo-aléatoires. Pour une série de ces nombres, une solution triviale consiste à y ajouter un montant constant et à prendre l'empreinte du résultat.

\section{Future Directions} \label{ch:future}

The state database won't be forced to maintain all past state trie structures into the future. It should maintain an age for each node and eventually discard nodes that are neither recent enough nor checkpoints; checkpoints, or a set of nodes in the database that allow a particular block's state trie to be traversed, could be used to place a maximum limit on the amount of computation needed in order to retrieve any state throughout the blockchain.

Blockchain consolidation could be used in order to reduce the amount of blocks a client would need to download to act as a full, mining, node. A compressed archive of the trie structure at given points in time (perhaps one in every 10,000th block) could be maintained by the peer network, effectively recasting the genesis block. This would reduce the amount to be downloaded to a single archive plus a hard maximum limit  of blocks.

Finally, blockchain compression could perhaps be conducted: nodes in state trie that haven't sent/received a transaction in some constant amount of blocks could be thrown out, reducing both Ether-leakage and the growth of the state database.

\subsection{Scalability}

Scalability remains an eternal concern. With a generalised state transition function, it becomes difficult to partition and parallelise transactions to apply the divide-and-conquer strategy. Unaddressed, the dynamic value-range of the system remains essentially fixed and as the average transaction value increases, the less valuable of them become ignored, being economically pointless to include in the main ledger. However, several strategies exist that may potentially be exploited to provide a considerably more scalable protocol.

Some form of hierarchical structure, achieved by either consolidating smaller lighter-weight chains into the main block or building the main block through the incremental combination and adhesion (through proof-of-work) of smaller transaction sets may allow parallelisation of transaction combination and block-building. Parallelism could also come from a prioritised set of parallel blockchains, consolidated each block and with duplicate or invalid transactions thrown out accordingly.

Finally, verifiable computation, if made generally available and efficient enough, may provide a route to allow the proof-of-work to be the verification of final state.

\section{Conclusion} \label{ch:conclusion}

I have introduced, discussed and formally defined the protocol of Ethereum. Through this protocol the reader may implement a node on the Ethereum network and join others in a decentralised secure social operating system. Contracts may be authored in order to algorithmically specify and autonomously enforce rules of interaction.

\section{Acknowledgements}

Many thanks to Aeron Buchanan for authoring the Homestead revisions, Christoph Jentzsch for authoring the Ethash algorithm and Yoichi Hirai for doing most of the EIP-150 changes. Important maintenance, useful corrections and suggestions were provided by a number of others from the Ethereum DEV organisation and Ethereum community at large including Gustav Simonsson, Pawe\l{} Bylica, Jutta Steiner, Nick Savers, Viktor Tr\'{o}n, Marko Simovic, Giacomo Tazzari and, of course, Vitalik Buterin.

\bibliography{Biblio}
\bibliographystyle{plainnat}

\end{multicols}

\appendix

\section{Terminologie}

\begin{description}
\item[Acteur externe (\textit{external actor})\,]
  Une personne ou une entité susceptible de s'interfacer à un n\oe{}ud Ethereum, mais extérieur au monde d'Ethereum. Il peut interagir avec Ethereum en déposant des Transactions signées et en inspectant la blockchain et son état associé. Possède un Compte intrinsèque ou plus.

\item[Adresse (\textit{address})\,]
  Un code sur 160 bits utilisé pour identifier les Comptes.

\item[Compte (\textit{account})\,]
  Les Comptes ont une balance intrinsèque et un compteur de transactions maintenu dans l'état d'Ethereum. Ils ont également du Code EVM (éventuellement vide) et un État de stockage qui leur est associé. Bien qu'homogènes, il est admis de distinguer deux types de comptes: ceux avec un Code EVM vide (et dont le solde est contrôlé le cas échéant par une entité externe) et ceux dont le Code EVM associé n'est pas vide (le compte représente donc un Objet autonome. Chaque compte a une adresse unique qui l'identifie.
  
\item[Transaction\,]
  Des données, signées par un Acteur externe. Elle représente soit un Message soit un nouvel Objet autonome. Les transactions sont enregistrées dans chaque bloc de la blockchain.

\item[Objet autonome (\textit{autonomous object})\,]
  Un objet théorique qui n'existe que dans l'état hypothétique d'Ethereum. Possède une adresse intrinsèque et donc un compte associé; le compte aura un Code EVM associé non vide. N'est incorporé que comme État de stockage de ce compte.

\item[État de stockage (\textit{storage state})\,]
  L'information spécifique à un Compte donné qui est conservée entre les occurrences de lancement du Code EVM associé au Compte.

\item[Message\,]
  Données (en tant qu'ensemble d'octets) et Valeur (spécifiée en Ether) qui sont passées entre deux Comptes, soit par l'opération déterministe d'un Objet autonome, soit par la signature sécurisée cryptographiquement de la Transaction.

\item[Appel de message (\textit{message call})\,]
  L'acte de passer un message d'un Compte vers un autre. Si le compte de destination est associé à du Code EVM non vide, alors la VM sera démarrée avec l'état de l'objet en question et le Message donnera lieu à une action. Si l'expéditeur du message est un Objet autonome, l'Appel passe toute donnée renvoyée de l'opération de la VM.

\item[Gaz (\textit{gas})\,]
  L'unité de coût fondamentale du réseau. Payée exclusivement en Ether (au momnet du PoC-4), qui est librement converti en Gaz et inversement selon les besoins. Le Gaz n'existe pas hors du moteur de calcul interne d'Ethereum; son prix est fixé par la Transaction et les mineurs sont libres d'ignorer les Transactions dont le prix en Gaz est trop bas.

\item[Contrat (\textit{contract})\,]
  Terme informel employé pour signifier à la fois un bout de Code EV qui peut être associé à un compte, et un Objet autonome.

\item[Objet (\textit{object})\,]
  Synonyme d'Objet autonome.

\item[App\,]
  Une application visible de l'utilisateur hébergée dans le Navigateur Ethereum.

\item[Navigateur Ethereum (\textit{Ethereum Browser})\,]
  (alias \textit{Ethereum Reference Client}) Une interface utilisateur graphique similaire à un navigateur simplifié (à la Chrome) capable d'héberger des applications en mode bac à sable dont la base arrière est purement sur le protocole Ethereum.

\item[Ethereum Virtual Machine\,]
  (alias EVM) La machine virtuelle qui forme la partie essentielle du modèle d'exécution du Code EVM associé à un Compte.

\item[Ethereum Runtime Environment\,]
  (alias ERE) L'environnement qui est fourni à un Objet autonome en train de s'exécuter dans l'EM. Comprend l'EVM mais aussi la structure de l'état du monde sur laquelle l'EVM se base pour certaines instruction d'E/S, y compris CALL et CREATE.

\item[Code EVM\,]
  Le bytecode que l'EVM peut exécuter nativement. Utilisé pour spécifier formellement la signification et les ramifications d'un message vers un Compte.

\item[Assembleur EVM (\textit{EVM assembly})\,]
  La forme humainement lisible du Code EVM.

\item[LLL\,] \
  textit{Lisp-like Low-level Language}, un langage humainement utilisable pour créer des contrats simples et une boîte à outils de lanage généraliste de bas niveau vers laquelle on transcompile.

\end{description}

\section{\textit{Recursive Length Prefix}}\label{app:rlp}
Il s'agit d'une méthode de sérialisation pour encoder des données binaires quelle que soit leur structure (tableaux d'octets).

Nous définissons l'ensemble des structures possibles $\mathbb{T}$:
\begin{eqnarray}
\mathbb{T} & \equiv & \mathbb{L} \cup \mathbb{B} \\
\mathbb{L} & \equiv & \{ \mathbf{t}: \mathbf{t} = ( \mathbf{t}[0], \mathbf{t}[1], ... ) \; \wedge \; \forall_{n < \lVert \mathbf{t} \rVert} \; \mathbf{t}[n] \in \mathbb{T} \} \\
\mathbb{B} & \equiv & \{ \mathbf{b}: \mathbf{b} = ( \mathbf{b}[0], \mathbf{b}[1], ... ) \; \wedge \; \forall_{n < \lVert \mathbf{b} \rVert} \; \mathbf{b}[n] \in \mathbb{O} \}
\end{eqnarray}

où $\mathbb{O}$ est l'ensemble d'octets. $\mathbb{B}$  est donc l'ensemble de toutes les séquences d'octets (connues par ailleurs sous le nom de tableaux d'octets (et une feuille si on l'imagine comme un arbre), $\mathbb{L}$ est l'ensemble de tous les (sous-)structures arborescentes qui ne sont pas une feuille unique (un n\oe{}ud de branches si on l'imagine comme un arbre) et  $\mathbb{T}$ est l'ensemble de tous les tableaux d'octets et les séquences structurales similaires.

Nous définissons la fonction RLP par $\mathtt{\tiny RLP}$ grâce à deux sous-fonctions, la première gérant l'instance quand la valeur est un tableau d'octets, la seconde quand elle est une séquence de valeurs ultérieures:
\begin{equation}
\mathtt{\tiny RLP}(\mathbf{x}) \equiv \begin{cases} R_b(\mathbf{x}) & \text{si} \quad \mathbf{x} \in \mathbb{B} \\ R_l(\mathbf{x}) & \text{sinon} \end{cases}
\end{equation}

Si la valeur à sérialiser est un tableau d'octets, la sérialisation RLP prend l'une de ces trois formes:

\begin{itemize}
\item
  Si le tableau d'octets ne contient qu'un octet unique et que cet octet est inférieur à 128, l'entrée est exactement égale à la sortie.
\item
  Si le tableau d'octets contient moins de 56 octets, la sortie est égale à l'entrée préfixée par l'octet égal à la longueur du tableau d'octets plus 128.
\item
  Sinon, la sortie est égale à l'entrée préfixée par le tableau d'octets de longueur minimale qui, quand interprété comme un entier gros-boutien, est égal à la longueur du tableau d'octets en entrée, lui-même préfixé par le nombre d'octets requis pour encoder fidèlement la valeur de cette longueur plus 183.
\end{itemize}

Formellement, nous définissons $R_b$:
\begin{eqnarray}
R_b(\mathbf{x}) & \equiv & \begin{cases}
\mathbf{x} & \text{si} \quad \lVert \mathbf{x} \rVert = 1 \wedge \mathbf{x}[0] < 128 \\
(128 + \lVert \mathbf{x} \rVert) \cdot \mathbf{x} & \text{sinon et si} \quad \lVert \mathbf{x} \rVert < 56 \\
\big(183 + \big\lVert \mathtt{\tiny BE}(\lVert \mathbf{x} \rVert) \big\rVert \big) \cdot \mathtt{\tiny BE}(\lVert \mathbf{x} \rVert) \cdot \mathbf{x} & \text{sinon}
\end{cases} \\
\mathtt{\tiny BE}(x) & \equiv & (b_0, b_1, ...): b_0 \neq 0 \wedge x = \sum_{n = 0}^{n < \lVert \mathbf{b} \rVert} b_n \cdot 256^{\lVert \mathbf{b} \rVert - 1 - n} \\
(a) \cdot (b, c) \cdot (d, e) & = & (a, b, c, d, e)
\end{eqnarray}

Donc $\mathtt{\tiny BE}$ est la fonction d'expansion d'une valeur entière positive vers un tableau d'octets gros-boutien de longueur minimale et l'opérateur point effectue la concaténation de la séquence.

Si en revanche la valeur à sérialiser est une séquence d'éléments autres, la sérialisatoin RLP prend l'une de ces deux formes:

\begin{itemize}
\item
  Si les sérialisations concaténées de chaque élément contenu fait moins de 56 octets de longueur, la sortie est égale à cette concaténation préfixée par l'octet égal à la longueur de ce tableau d'octets plus 192.
\item
  Sinon, la sortie est égale aux sérialisations concaténées préfixées par le tableau d'octets de longueur minimale qui, quand on l'interprète comme un entier gros-boutien, est égal à la longueur du tableau d'octets des sérialisations concaténées, lui-même préfixé par le nombre d'octets requi pour encoder fidèlement la valeur de cette longueur plus 247.
\end{itemize}

Nous terminons donc en définissant formellement $R_l$:
\begin{eqnarray}
R_l(\mathbf{x}) & \equiv & \begin{cases}
(192 + \lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) & \text{si} \quad \lVert s(\mathbf{x}) \rVert < 56 \\
\big(247 + \big\lVert \mathtt{\tiny BE}(\lVert s(\mathbf{x}) \rVert) \big\rVert \big) \cdot \mathtt{\tiny BE}(\lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) & \text{sinon}
\end{cases} \\
s(\mathbf{x}) & \equiv & \mathtt{\tiny RLP}(\mathbf{x}_0) \cdot \mathtt{\tiny RLP}(\mathbf{x}_1) ...
\end{eqnarray}

Si RLP est utilisé pour encoder un scalaire, défini comme un entier positif ($\mathbb{P}$ ou tout $x$ pour $\mathbb{P}_x$), il doit être spécifié comme le plus petit tableau d'octets tel que son interprétation gros-boutienne est égale. Donc, le RLP d'un entier positif $i$ est défini par:
\begin{equation}
\mathtt{\tiny RLP}(i : i \in \mathbb{P}) \equiv \mathtt{\tiny RLP}(\mathtt{\tiny BE}(i))
\end{equation}

Quand on interprète les données RLP, si un fragment inattendu est décodé comme un scalaire et que des zéros préfixent une séquence d'octets, les clients doivent le considérer comme non-canonique et le traiter de la même manière que les autres données RLP invalides en le rejetant complètement.

Il n'existe pas de format d'encodage canonique pour les valeurs signées ou en virgule flottante.

\section{Hex-Prefix Encoding}\label{app:hexprefix}
Hex-prefix encoding is an efficient method of encoding an arbitrary number of nibbles as a byte array. It is able to store an additional flag which, when used in the context of the trie (the only context in which it is used), disambiguates between node types.

It is defined as the function $\mathtt{\tiny HP}$ which maps from a sequence of nibbles (represented by the set $\mathbb{Y}$) together with a boolean value to a sequence of bytes (represented by the set $\mathbb{B}$):

\begin{eqnarray}
\mathtt{\tiny HP}(\mathbf{x}, t): \mathbf{x} \in \mathbb{Y} & \equiv & \begin{cases}
(16f(t), 16\mathbf{x}[0] + \mathbf{x}[1], 16\mathbf{x}[2] + \mathbf{x}[3], ...) &
\text{if} \quad \lVert \mathbf{x} \rVert \; \text{is even} \\
(16(f(t) + 1) + \mathbf{x}[0], 16\mathbf{x}[1] + \mathbf{x}[2], 16\mathbf{x}[3] + \mathbf{x}[4], ...) &
\text{otherwise}
\end{cases} \\
f(t) & \equiv & \begin{cases} 2 & \text{if} \quad t \neq 0 \\ 0 & \text{otherwise} \end{cases}
\end{eqnarray}

Thus the high nibble of the first byte contains two flags; the lowest bit encoding the oddness of the length and the second-lowest encoding the flag $t$. The low nibble of the first byte is zero in the case of an even number of nibbles and the first nibble in the case of an odd number. All remaining nibbles (now an even number) fit properly into the remaining bytes.

\section{Modified Merkle Patricia Tree}\label{app:trie}
The modified Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary data (byte arrays). It is defined in terms of a mutable data structure to map between 256-bit binary fragments and arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms of the protocol specification is to provide a single value that identifies a given set of key-value pairs, which may be either a 32 byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the structure of the trie in a manner the allows effective and efficient realisation of the protocol.

Formally, we assume the input value $\mathfrak{I}$, a set containing pairs of byte sequences:
\begin{equation}
\mathfrak{I} = \{ (\mathbf{k}_0 \in \mathbb{B}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1 \in \mathbb{B}, \mathbf{v}_1 \in \mathbb{B}), ... \}
\end{equation}

When considering such a sequence, we use the common numeric subscript notation to refer to a tuple's key or value, thus:
\begin{equation}
\forall_{I \in \mathfrak{I}} I \equiv (I_0, I_1)
\end{equation}

Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-specific notation; here we assume big-endian. Thus:
\begin{eqnarray}
y(\mathfrak{I}) & = & \{ (\mathbf{k}_0' \in \mathbb{Y}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1' \in \mathbb{Y}, \mathbf{v}_1 \in \mathbb{B}), ... \} \\
\forall_n \quad \forall_{i: i < 2\lVert\mathbf{k}_n\rVert} \quad \mathbf{k}_n'[i] & \equiv &
\begin{cases}
\lfloor \mathbf{k}_n[i \div 2] \div 16 \rfloor & \text{if} \; i \; \text{is even} \\
\mathbf{k}_n[\lfloor i \div 2 \rfloor] \bmod 16 & \text{otherwise}
\end{cases}
\end{eqnarray}

We define the function $\texttt{\small TRIE}$, which evaluates to the root of the trie that represents this set when encoded in this structure:
\begin{equation}
\texttt{\small TRIE}(\mathfrak{I}) \equiv \texttt{\small KEC}(c(\mathfrak{I}, 0))
\end{equation}

We also assume a function $n$, the trie's node cap function. When composing a node, we use RLP to encode the structure. As a means of reducing storage complexity, for nodes whose composed RLP is fewer than 32 bytes, we store the RLP directly; for those larger we assert prescience of the byte array whose Keccak hash evaluates to our reference. Thus we define in terms of $c$, the node composition function:
\begin{equation}
n(\mathfrak{I}, i) \equiv \begin{cases}
() & \text{if} \quad \mathfrak{I} = \varnothing \\
c(\mathfrak{I}, i) & \text{if} \quad \lVert c(\mathfrak{I}, i)\rVert < 32 \\
\texttt{\small KEC}(c(\mathfrak{I}, i)) & \text{otherwise}
\end{cases}
\end{equation}

In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair. The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree). Unlike a radix tree, in the case of multiple keys sharing the same prefix or in the case of a single key having a unique suffix, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each of the other two node types, extension and leaf. There are three kinds of nodes in the trie:
\begin{description}
\item[Leaf] A two-item structure whose first item corresponds to the nibbles in the key not already accounted for by the accumulation of keys and branches traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be $true$.
\item[Extension] A two-item structure whose first item corresponds to a series of nibbles of size greater than one that are shared by at least two distinct keys past the accumulation of nibbles keys and branches as traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be $false$.
\item[Branch] A 17-item structure whose first sixteen items correspond to each of the sixteen possible nibble values for the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and thus a key being ended at this point in its traversal.
\end{description}

A branch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We may formally define this structure with the structural composition function $c$:
\begin{equation}
c(\mathfrak{I}, i) \equiv \begin{cases}
\texttt{\small RLP}\Big( \big(\texttt{\small HP}(I_0[i .. (\lVert I_0\rVert - 1)], true), I_1 \big) \Big) & \text{if} \quad \lVert \mathfrak{I} \rVert = 1 \quad \text{where} \; \exists I: I \in \mathfrak{I} \\
\texttt{\small RLP}\Big( \big(\texttt{\small HP}(I_0[i .. (j - 1)], false), n(\mathfrak{I}, j) \big) \Big) & \text{if} \quad i \ne j \quad \text{where} \; j = \arg \max_x : \exists \mathbf{l}: \lVert \mathbf{l} \rVert = x : \forall_{I \in \mathfrak{I}}: I_0[0 .. (x - 1)] = \mathbf{l} \\
\texttt{\small RLP}\Big( (u(0), u(1), ..., u(15), v) \Big) & \text{otherwise} \quad \text{where} \begin{array}[t]{rcl}
u(j) & \equiv & n(\{ I : I \in \mathfrak{I} \wedge I_0[i] = j \}, i + 1) \\
v & = & \begin{cases}
I_1 & \text{if} \quad \exists I: I \in \mathfrak{I} \wedge \lVert I_0 \rVert = i \\
() & \text{otherwise}
\end{cases}
\end{array}
\end{cases}
\end{equation}

\subsection{Trie Database}
Thus no explicit assumptions are made concerning what data is stored and what is not, since that is an implementation-specific consideration; we simply define the identity function mapping the key-value set $\mathfrak{I}$ to a 32-byte hash and assert that only a single such hash exists for any $\mathfrak{I}$, which though not strictly true is accurate within acceptable precision given the Keccak hash's collision resistance. In reality, a sensible implementation will not fully recompute the trie root hash for each set.

A reasonable implementation will maintain a database of nodes determined from the computation of various tries or, more formally, it will memoise the function $c$. This strategy uses the nature of the trie to both easily recall the contents of any previous key-value set and to store multiple such sets in a very efficient manner. Due to the dependency relationship, Merkle-proofs may be constructed with an $O(\log N)$ space requirement that can demonstrate a particular leaf must exist within a trie of a given root hash.

\section{Precompiled Contracts}\label{app:precompiled}

For each precompiled contract, we make use of a template function, $\Xi_{\mathtt{PRE}}$, which implements the out-of-gas checking.
\begin{equation}
\Xi_{\mathtt{PRE}}(\boldsymbol{\sigma}, g, I) \equiv \begin{cases}
(\varnothing, 0, A^0, ()) & \text{if} \quad g < g_r \\
(\boldsymbol\sigma, g - g_r, A^0, \mathbf{o}) & \text{otherwise}\end{cases}
\end{equation}

The precompiled contracts each use these definitions and provide specifications for the $\mathbf{o}$ (the output data) and $g_r$, the gas requirements.

For the elliptic curve DSA recover VM execution function, we also define $\mathbf{d}$ to be the input data, well-defined for an infinite length by appending zeroes as required. Importantly in the case of an invalid signature ($\mathtt{\tiny ECDSARECOVER}(h, v, r, s) = \varnothing$), then we have no output.
\begin{eqnarray}
\Xi_{\mathtt{ECREC}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 3000\\
|\mathbf{o}| &=& \begin{cases} 0 & \text{if} \quad \mathtt{\tiny ECDSARECOVER}(h, v, r, s) = \varnothing\\ 32 & \text{otherwise} \end{cases}\\
\text{if} \quad |\mathbf{o}| = 32: &&\\
\mathbf{o}[0..11] &=& 0 \\
\mathbf{o}[12..31] &=& \mathtt{\tiny KEC}\big(\mathtt{\tiny ECDSARECOVER}(h, v, r, s)\big)[12..31] \quad \text{where:}\\
\mathbf{d}[0..(|I_\mathbf{d}|-1)] &=& I_\mathbf{d}\\
\mathbf{d}[|I_\mathbf{d}|..] &=& (0, 0, ...) \\
h &=& \mathbf{d}[0..31]\\
v &=& \mathbf{d}[32..63]\\
r &=& \mathbf{d}[64..95]\\
s &=& \mathbf{d}[96..127]
\end{eqnarray}

The two hash functions, RIPEMD-160 and SHA2-256 are more trivially defined as an almost pass-through operation. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.
\begin{eqnarray}
\Xi_{\mathtt{SHA256}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 60 + 12\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o}[0..31] &=& \mathtt{\tiny SHA256}(I_\mathbf{d})\\
\Xi_{\mathtt{RIP160}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 600 + 120\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o}[0..11] &=& 0 \\
\mathbf{o}[12..31] &=& \mathtt{\tiny RIPEMD160}(I_\mathbf{d})\\
\end{eqnarray}

For the purposes here, we assume we have well-defined standard cryptographic functions for RIPEMD-160 and SHA2-256 of the form:
\begin{eqnarray}
\mathtt{\small SHA256}(\mathbf{i} \in \mathbb{B}) & \equiv & o \in \mathbb{B}_{32} \\
\mathtt{\small RIPEMD160}(\mathbf{i} \in \mathbb{B}) & \equiv & o \in \mathbb{B}_{20}
\end{eqnarray}

Finally, the fourth contract, the identity function $\Xi_{\mathtt{ID}}$ simply defines the output as the input:
\begin{eqnarray}
\Xi_{\mathtt{ID}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 15 + 3\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o} &=& I_\mathbf{d}
\end{eqnarray}


\section{Signing Transactions}\label{app:signing}

The method of signing transactions is similar to the `Electrum style signatures'; it utilises the SECP-256k1 curve as described by \cite{gura2004comparing}.

It is assumed that the sender has a valid private key $p_r$, which is a randomly selected positive integer (represented as a byte array of length 32 in big-endian form) in the range \hbox{$[1, \mathtt{\tiny secp256k1n} - 1]$}.

We assert the functions $\mathtt{\small ECDSASIGN}$, $\mathtt{\small ECDSARESTORE}$ and $\mathtt{\small ECDSAPUBKEY}$. These are formally defined in the literature.
\begin{eqnarray}
\mathtt{\small ECDSAPUBKEY}(p_r \in \mathbb{B}_{32}) & \equiv & p_u \in \mathbb{B}_{64} \\
\mathtt{\small ECDSASIGN}(e \in \mathbb{B}_{32}, p_r \in \mathbb{B}_{32}) & \equiv & (v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) \\
\mathtt{\small ECDSARECOVER}(e \in \mathbb{B}_{32}, v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) & \equiv & p_u \in \mathbb{B}_{64}
\end{eqnarray}

Where $p_u$ is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive integers each $< 2^{256}$) and $p_r$ is the private key, a byte array of size 32 (or a single positive integer in the aforementioned range). It is assumed that $v$ is the `recovery id', a 1 byte value specifying the sign and finiteness of the curve point; this value is in the range of $[27, 30]$, however we declare the upper two possibilities, representing infinite values, invalid.

\newcommand{\slimit}{\ensuremath{\text{s-limit}}}

We declare that a signature is invalid unless all the following conditions are true:
\begin{align}
0 < r &< \mathtt{\tiny secp256k1n} \\
0 < s &< \begin{dcases}
\mathtt{\tiny secp256k1n} & \text{if} \quad H_i < \firsthomesteadblock \\
\mathtt{\tiny secp256k1n} \div 2 & \text{otherwise} \\
\end{dcases} \\
 v &\in \{27,28\}
\end{align}
where:
\begin{align}
\mathtt{\tiny secp256k1n} &= 115792089237316195423570985008687907852837564279074904382605163141518161494337
%\mathtt{\tiny secp256k1p} &= 2^{256} - 2^{32} - 977\\
\end{align}

For a given private key, $p_r$, the Ethereum address $A(p_r)$ (a 160-bit value) to which it corresponds is defined as the right most 160-bits of the Keccak hash of the corresponding ECDSA public key:
\begin{equation}
A(p_r) = \mathcal{B}_{96..255}\big(\mathtt{\tiny KEC}\big( \mathtt{\small ECDSAPUBKEY}(p_r) \big) \big)
\end{equation}

The message hash, $h(T)$, to be signed is the Keccak hash of the transaction without the latter three signature components, formally described as $T_r$, $T_s$ and $T_w$:
\begin{eqnarray}
L_S(T) & \equiv & \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}) & \text{if} \; T_t = 0\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}) & \text{otherwise}
\end{cases} \\
h(T) & \equiv & \mathtt{\small KEC}( L_S(T) )
\end{eqnarray}

The signed transaction $G(T, p_r)$ is defined as:
\begin{eqnarray}
G(T, p_r) \equiv T \quad \text{except:} \\
(T_w, T_r, T_s) = \mathtt{\small ECDSASIGN}(h(T), p_r)
\end{eqnarray}

We may then define the sender function $S$ of the transaction as:
\begin{equation}
S(T) \equiv \mathcal{B}_{96..255}\big(\mathtt{\tiny KEC}\big( \mathtt{\small ECDSARECOVER}(h(T), T_w, T_r, T_s) \big) \big)
\end{equation}

The assertion that the sender of the a signed transaction equals the address of the signer should be self-evident:
\begin{equation}
\forall T: \forall p_r: S(G(T, p_r)) \equiv A(p_r)
\end{equation}

\section{Fee Schedule}\label{app:fees}

The fee schedule $G$ is a tuple of 31 scalar values corresponding to the relative costs, in gas, of a number of abstract operations that a transaction may effect.

\begin{tabular*}{\columnwidth}[h]{lrl}
\toprule
Name & Value & Description* \\
\midrule
$G_{zero}$ & 0 & Nothing paid for operations of the set {\small $W_{zero}$}. \\
$G_{base}$ & 2 & Amount of gas to pay for operations of the set {\small $W_{base}$}. \\
$G_{verylow}$ & 3 & Amount of gas to pay for operations of the set {\small $W_{verylow}$}. \\
$G_{low}$ & 5 & Amount of gas to pay for operations of the set {\small $W_{low}$}. \\
$G_{mid}$ & 8 & Amount of gas to pay for operations of the set {\small $W_{mid}$}. \\
$G_{high}$ & 10 & Amount of gas to pay for operations of the set {\small $W_{high}$}. \\
$G_{extcode}$ & 700 & Amount of gas to pay for operations of the set {\small $W_{extcode}$}. \\
$G_{balance}$ & 400 & Amount of gas to pay for a {\small BALANCE} operation. \\
$G_{sload}$ & 200 & Paid for a {\small SLOAD} operation. \\
$G_{jumpdest}$ & 1 & Paid for a {\small JUMPDEST} operation. \\
$G_{sset}$ & 20000 & Paid for an {\small SSTORE} operation when the storage value is set to non-zero from zero. \\
$G_{sreset}$ & 5000 & Paid for an {\small SSTORE} operation when the storage value's zeroness remains unchanged or is set to zero. \\
$R_{sclear}$ & 15000 & Refund given (added into refund counter) when the storage value is set to zero from non-zero. \\
$R_{suicide}$ & 24000 & Refund given (added into refund counter) for suiciding an account. \\
$G_{suicide}$ & 5000 & Amount of gas to pay for a {\small SUICIDE} operation. \\
$G_{create}$ & 32000 & Paid for a {\small CREATE} operation. \\
$G_{codedeposit}$ & 200 & Paid per byte for a {\small CREATE} operation to succeed in placing code into state. \\
$G_{call}$ & 700 & Paid for a {\small CALL} operation. \\
$G_{callvalue}$ & 9000 & Paid for a non-zero value transfer as part of the {\small CALL} operation. \\
$G_{callstipend}$ & 2300 & A stipend for the called contract subtracted from $G_{callvalue}$ for a non-zero value transfer. \\
$G_{newaccount}$ & 25000 & Paid for a {\small CALL} or {\small SUICIDE} operation which creates an account. \\
$G_{exp}$ & 10 & Partial payment for an {\small EXP} operation. \\
$G_{expbyte}$ & 10 & Partial payment when multiplied by $\lceil\log_{256}(exponent)\rceil$ for the {\small EXP} operation. \\
$G_{memory}$ & 3 & Paid for every additional word when expanding memory. \\
$G_\text{txcreate}$ & 32000 & Paid by all contract-creating transactions after the {\it Homestead transition}.\\
$G_{txdatazero}$ & 4 & Paid for every zero byte of data or code for a transaction. \\
$G_{txdatanonzero}$ & 68 & Paid for every non-zero byte of data or code for a transaction. \\
$G_{transaction}$ & 21000 & Paid for every transaction. \\
$G_{log}$ & 375 & Partial payment for a {\small LOG} operation. \\
$G_{logdata}$ & 8 & Paid for each byte in a {\small LOG} operation's data. \\
$G_{logtopic}$ & 375 & Paid for each topic of a {\small LOG} operation. \\
$G_{sha3}$ & 30 & Paid for each {\small SHA3} operation. \\
$G_{sha3word}$ & 6 & Paid for each word (rounded up) for input data to a {\small SHA3} operation. \\
$G_{copy}$ & 3 & Partial payment for {\small *COPY} operations, multiplied by words copied, rounded up. \\
$G_{blockhash}$ & 20 & Payment for {\small BLOCKHASH} operation. \\

%extern u256 const c_copyGas;			///< Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.
\bottomrule
\end{tabular*}

\section{Virtual Machine Specification}\label{app:vm}

When interpreting 256-bit binary values as integers, the representation is big-endian.

When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE) 20 bytes are used and the left most 12 are discarded or filled with zeroes, thus the integer values (when the bytes are interpreted as big-endian) are equivalent.

\subsection{Gas Cost}

The general gas cost function, $C$, is defined as:

\begin{equation}
C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \equiv C_{mem}(\boldsymbol{\mu}'_i)-C_{mem}(\boldsymbol{\mu}_i) + \begin{cases}
C_\text{\tiny SSTORE}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small SSTORE} \\
G_{exp} & \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_\mathbf{s}[1] = 0 \\
G_{exp} + G_{expbyte}\times(1+\lfloor\log_{256}(\boldsymbol{\mu}_\mathbf{s}[1])\rfloor) & \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_\mathbf{s}[1] > 0 \\
G_{verylow} + G_{copy}\times\lceil\boldsymbol{\mu}_\mathbf{s}[2] \div 32\rceil & \text{if} \quad w = \text{\small CALLDATACOPY} \lor \text{\small CODECOPY} \\
G_{extcode} + G_{copy}\times\lceil\boldsymbol{\mu}_\mathbf{s}[3] \div 32\rceil & \text{if} \quad w = \text{\small EXTCODECOPY} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1] & \text{if} \quad w = \text{\small LOG0} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+G_{logtopic} & \text{if} \quad w = \text{\small LOG1} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+2G_{logtopic} & \text{if} \quad w = \text{\small LOG2} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+3G_{logtopic} & \text{if} \quad w = \text{\small LOG3} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+4G_{logtopic} & \text{if} \quad w = \text{\small LOG4} \\
C_\text{\tiny CALL}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small CALL} \lor \text{\small CALLCODE} \lor \text{\small DELEGATECALL} \\
C_\text{\tiny SUICIDE}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small SUICIDE} \\
G_{create} & \text{if} \quad w = \text{\small CREATE}\\
G_{sha3}+G_{sha3word} \lceil \mathbf{s}[1] \div 32 \rceil & \text{if} \quad w = \text{\small SHA3}\\
G_{jumpdest} & \text{if} \quad w = \text{\small JUMPDEST}\\
G_{sload} & \text{if} \quad w = \text{\small SLOAD}\\
G_{zero} & \text{if} \quad w \in W_{zero}\\
G_{base} & \text{if} \quad w \in W_{base}\\
G_{verylow} & \text{if} \quad w \in W_{verylow}\\
G_{low} & \text{if} \quad w \in W_{low}\\
G_{mid} & \text{if} \quad w \in W_{mid}\\
G_{high} & \text{if} \quad w \in W_{high}\\
G_{extcode} & \text{if} \quad w \in W_{extcode}\\
G_{balance} & \text{if} \quad w = \text{\small BALANCE}\\
G_{blockhash} & \text{if} \quad w = \text{\small BLOCKHASH}\\
\end{cases}
\end{equation}
\begin{equation}
w \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_{pc}] & \text{if} \quad \boldsymbol{\mu}_{pc} < \lVert I_\mathbf{b} \rVert\\
\text{\small STOP} & \text{otherwise}
\end{cases}
\end{equation}

where:
\begin{equation}
C_{mem}(a) \equiv G_{memory} \cdot a + \Big\lfloor \dfrac{a^2}{512} \Big\rfloor
\end{equation}

with $C_\text{\tiny CALL}$, $C_\text{\tiny SUICIDE}$ and $C_\text{\tiny SSTORE}$ as specified in the appropriate section below. We define the following subsets of instructions:

$W_{zero}$ = \{{\small STOP}, {\small RETURN}\}

$W_{base}$ = \{{\small ADDRESS}, {\small ORIGIN}, {\small CALLER}, {\small CALLVALUE}, {\small CALLDATASIZE}, {\small CODESIZE}, {\small GASPRICE}, {\small COINBASE},\newline \noindent\hspace*{1cm} {\small TIMESTAMP}, {\small NUMBER}, {\small DIFFICULTY}, {\small GASLIMIT}, {\small POP}, {\small PC}, {\small MSIZE}, {\small GAS}\}

$W_{verylow}$ = \{{\small ADD}, {\small SUB}, {\small NOT}, {\small LT}, {\small GT}, {\small SLT}, {\small SGT}, {\small EQ}, {\small ISZERO}, {\small AND}, {\small OR}, {\small XOR}, {\small BYTE}, {\small CALLDATALOAD}, \newline \noindent\hspace*{1cm} {\small MLOAD}, {\small MSTORE}, {\small MSTORE8}, {\small PUSH*}, {\small DUP*}, {\small SWAP*}\}

$W_{low}$ = \{{\small MUL}, {\small DIV}, {\small SDIV}, {\small MOD}, {\small SMOD}, {\small SIGNEXTEND}\}

$W_{mid}$ = \{{\small ADDMOD}, {\small MULMOD}, {\small JUMP}\}

$W_{high}$ = \{{\small JUMPI}\}

$W_{extcode}$ = \{{\small EXTCODESIZE}\}

Note the memory cost component, given as the product of $G_{memory}$ and the maximum of 0 \& the ceiling of the number of words in size that the memory must be over the current number of words, $\boldsymbol{\mu}_i$ in order that all accesses reference valid memory whether for read or write. Such accesses must be for non-zero number of bytes.

Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory to be extended to the beginning of the range. $\boldsymbol{\mu}'_i$ is defined as this new maximum number of words of active memory; special-cases are given where these two are not equal.

Note also that $C_{mem}$ is the memory cost function (the expansion function being the difference between the cost before and after). It is a polynomial, with the higher-order coefficient divided and floored, and thus linear up to 724B of memory used, after which it costs substantially more.

While defining the instruction set, we defined the memory-expansion for range function, $M$, thus:

\begin{equation}
M(s, f, l) \equiv \begin{cases}
s & \text{if} \quad l = 0 \\
\max(s, \ceil{ (f + l) \div 32 }) & \text{otherwise}
\end{cases}
\end{equation}

Another useful function is ``all but one 64th'' function~$L$ defined as:

\begin{equation}
L(n) \equiv n - \lfloor n / 64 \rfloor
\end{equation}

\subsection{Instruction Set}

As previously specified in section \ref{ch:model}, these definitions take place in the final context there. In particular we assume $O$ is the EVM state-progression function and define the terms pertaining to the next cycle's state $(\boldsymbol{\sigma}', \boldsymbol{\mu}')$ such that:
\begin{equation}
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \equiv (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \quad \text{with exceptions, as noted}
\end{equation}

Here given are the various exceptions to the state transition rules given in section \ref{ch:model} specified for each instruction, together with the additional instruction-specific definitions of $J$ and $C$. For each instruction, also specified is $\alpha$, the additional items placed on the stack and $\delta$, the items removed from stack, as defined in section \ref{ch:model}.

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{0s: Stop and Arithmetic Operations}} \\
\multicolumn{5}{l}{All arithmetic is modulo $2^{256}$ unless otherwise noted.} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x00 & {\small STOP} & 0 & 0 & Halts execution. \\
\midrule
0x01 & {\small ADD} & 2 & 1 & Addition operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x02 & {\small MUL} & 2 & 1 & Multiplication operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x03 & {\small SUB} & 2 & 1 & Subtraction operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] - \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x04 & {\small DIV} & 2 & 1 & Integer division operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \lfloor\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]\rfloor & \text{otherwise}\end{cases}$  \\
\midrule
0x05 & {\small SDIV} & 2 & 1 & Signed integer division operation (truncated). \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ -2^{255} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = -2^{255} \wedge \quad \boldsymbol{\mu}_\mathbf{s}[1] = -1\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]) \lfloor |\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]| \rfloor & \text{otherwise}\end{cases}$  \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
&&&& Note the overflow semantic when $-2^{255}$ is negated.\\
\midrule
0x06 & {\small MOD} & 2 & 1 & Modulo remainder operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \boldsymbol{\mu}_\mathbf{s}[0] \bmod \boldsymbol{\mu}_\mathbf{s}[1] & \text{otherwise}\end{cases}$  \\
\midrule
0x07 & {\small SMOD} & 2 & 1 & Signed modulo remainder operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0]) |\boldsymbol{\mu}_\mathbf{s}[0]| \bmod |\boldsymbol{\mu}_\mathbf{s}[1]| & \text{otherwise}\end{cases}$  \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x08 & {\small ADDMOD} & 3 & 1 & Modulo addition operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}$  \\
&&&& All intermediate calculations of this operation are not subject to the $2^{256}$ modulo. \\
\midrule
0x09 & {\small MULMOD} & 3 & 1 & Modulo multiplication operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}$  \\
&&&& All intermediate calculations of this operation are not subject to the $2^{256}$ modulo. \\
\midrule
0x0a & {\small EXP} & 2 & 1 & Exponential operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] ^ {\boldsymbol{\mu}_\mathbf{s}[1] }$ \\
\midrule
0x0b & {\small SIGNEXTEND} & 2 & 1 & Extend length of two's complement signed integer. \\
&&&& $ \forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_t &\text{if} \quad i \leqslant t \quad \text{where} \; t = 256 - 8(\boldsymbol{\mu}_\mathbf{s}[0] + 1) \\ \boldsymbol{\mu}_\mathbf{s}[1]_i &\text{otherwise} \end{cases}$ \\
\multicolumn{5}{l}{$\boldsymbol{\mu}_\mathbf{s}[x]_i$ gives the $i$th bit (counting from zero) of $\boldsymbol{\mu}_\mathbf{s}[x]$} \vspace{5pt} \\
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{10s: Comparison \& Bitwise Logic Operations}} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x10 & {\small LT} & 2 & 1 & Less-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x11 & {\small GT} & 2 & 1 & Greater-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x12 & {\small SLT} & 2 & 1 & Signed less-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x13 & {\small SGT} & 2 & 1 & Signed greater-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x14 & {\small EQ} & 2 & 1 & Equality comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x15 & {\small ISZERO} & 1 & 1 & Simple not operator. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = 0 \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x16 & {\small AND} & 2 & 1 & Bitwise AND operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \wedge \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x17 & {\small OR} & 2 & 1 & Bitwise OR operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \vee \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x18 & {\small XOR} & 2 & 1 & Bitwise XOR operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \oplus \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x19 & {\small NOT} & 1 & 1 & Bitwise NOT operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0]_i = 0 \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x1a & {\small BYTE} & 2 & 1 & Retrieve single byte from word. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_{(i + 8\boldsymbol{\mu}_\mathbf{s}[0])} & \text{if} \quad i < 8 \wedge \boldsymbol{\mu}_\mathbf{s}[0] < 32 \\ 0 & \text{otherwise} \end{cases} $\\
&&&& For Nth byte, we count from the left (i.e. N=0 would be the most significant in big endian). \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{20s: SHA3}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x20 & {\small SHA3} & 2 & 1 & Compute Keccak-256 hash. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \mathtt{\tiny Keccak}(\boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])$ \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{30s: Environmental Information}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x30 & {\small ADDRESS} & 0 & 1 & Get address of currently executing account. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_a$ \\
\midrule
0x31 & {\small BALANCE} & 1 & 1 & Get balance of the given account. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}\boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0]]_b& \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}] \neq \varnothing\\0&\text{otherwise}\end{cases}$ \\
\midrule
0x32 & {\small ORIGIN} & 0 & 1 & Get execution origination address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_o$ \\
&&&& This is the sender of original transaction; it is never an account with non-empty \\
&&&& associated code. \\
\midrule
0x33 & {\small CALLER} & 0 & 1 & Get caller address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_s$ \\
&&&& This is the address of the account that is directly responsible for this execution. \\
\midrule
0x34 & {\small CALLVALUE} & 0 & 1 & Get deposited value by the instruction/transaction responsible for this execution. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_v$ \\
\midrule
0x35 & {\small CALLDATALOAD} & 1 & 1 & Get input data of current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_\mathbf{d}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \quad \text{with} \quad I_\mathbf{d}[x] = 0 \quad \text{if} \quad x \geqslant \lVert I_\mathbf{d} \rVert$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x36 & {\small CALLDATASIZE} & 0 & 1 & Get size of input data in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{d} \rVert$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x37 & {\small CALLDATACOPY} & 3 & 0 & Copy input data in current environment to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv
\begin{cases} I_\mathbf{d}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{d} \rVert \\ 0 & \text{otherwise} \end{cases}$\\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[2])$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x38 & {\small CODESIZE} & 0 & 1 & Get size of code running in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{b} \rVert$ \\
\midrule
0x39 & {\small CODECOPY} & 3 & 0 & Copy code running in current environment to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv
\begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{b} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}$\\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\midrule
0x3a & {\small GASPRICE} & 0 & 1 & Get price of gas in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_p$ \\
&&&& This is gas price specified by the originating transaction.\\
\midrule
0x3b & {\small EXTCODESIZE} & 1 & 1 & Get size of an account's code. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert \boldsymbol{\sigma}[\boldsymbol{\mu}_s[0] \mod 2^{160}]_c \rVert$ \\
\midrule
0x3c & {\small EXTCODECOPY} & 4 & 0 & Copy an account's code to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[3] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[1] + i ] \equiv
\begin{cases} \mathbf{c}[\boldsymbol{\mu}_\mathbf{s}[2] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] + i < \lVert \mathbf{c} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}$\\
&&&& where $\mathbf{c} \equiv \boldsymbol{\sigma}[\boldsymbol{\mu}_s[0] \mod 2^{160}]_c$ \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[1], \boldsymbol{\mu}_\mathbf{s}[3])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{40s: Block Information}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x40 & {\small BLOCKHASH} & 1 & 1 & Get the hash of one of the 256 most recent complete blocks. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv P(I_{H_p}, \boldsymbol{\mu}_\mathbf{s}[0], 0)$ \\
&&&& where $P$ is the hash of a block of a particular number, up to a maximum age.\\
&&&& 0 is left on the stack if the looked for block number is greater than the current block number \\
&&&& or more than 256 blocks behind the current block. \\
&&&& $P(h, n, a) \equiv \begin{cases} 0 & \text{if} \quad n > H_i \vee a = 256 \vee h = 0 \\ h & \text{if} \quad n = H_i \\ P(H_p, n, a + 1) & \text{otherwise} \end{cases}$ \\
&&&& and we assert the header $H$ can be determined as its hash is the parent hash \\
&&&& in the block following it. \\
\midrule
0x41 & {\small COINBASE} & 0 & 1 & Get the block's beneficiary address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_c$ \\
\midrule
0x42 & {\small TIMESTAMP} & 0 & 1 & Get the block's timestamp. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_s$ \\
\midrule
0x43 & {\small NUMBER} & 0 & 1 & Get the block's number. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_i$ \\
\midrule
0x44 & {\small DIFFICULTY} & 0 & 1 & Get the block's difficulty. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_d$ \\
\midrule
0x45 & {\small GASLIMIT} & 0 & 1 & Get the block's gas limit. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_l$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{50s: Stack, Memory, Storage and Flow Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x50 & {\small POP} & 1 & 0 & Remove item from stack. \\
\midrule
0x51 & {\small MLOAD} & 1 & 1 & Load word from memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ]$ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })$ \\
&&&& The addition in the calculation of $\boldsymbol{\mu}'_i$ is not subject to the $2^{256}$ modulo. \\
\midrule
0x52 & {\small MSTORE} & 2 & 0 & Save word to memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })$ \\
&&&& The addition in the calculation of $\boldsymbol{\mu}'_i$ is not subject to the $2^{256}$ modulo. \\
\midrule
0x53 & {\small MSTORE8} & 2 & 0 & Save byte to memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv (\boldsymbol{\mu}_\mathbf{s}[1] \bmod 256) $ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 1) \div 32 })$ \\
&&&& The addition in the calculation of $\boldsymbol{\mu}'_i$ is not subject to the $2^{256}$ modulo. \\
\midrule
0x54 & {\small SLOAD} & 1 & 1 & Load word from storage. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]]$ \\
\midrule
0x55 & {\small SSTORE} & 2 & 0 & Save word to storage. \\
&&&& $\boldsymbol{\sigma}'[I_a]_\mathbf{s}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv \boldsymbol{\mu}_\mathbf{s}[1] $ \\
&&&& $C_{\text{\tiny SSTORE}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{sset} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \; \wedge \; \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]] = 0 \\
G_{sreset} & \text{otherwise}
\end{cases}$ \\
&&&& $A'_{r} \equiv A_{r} + \begin{cases}
R_{sclear} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0 \; \wedge \; \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
\midrule
0x56 & {\small JUMP} & 1 & 0 & Alter the program counter. \\
&&&& $J_{\text{\tiny JUMP}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{s}[0] $ \\
&&&& This has the effect of writing said value to $\boldsymbol{\mu}_{pc}$. See section \ref{ch:model}. \\
\midrule
0x57 & {\small JUMPI} & 2 & 0 & Conditionally alter the program counter. \\
&&&& $J_{\text{\tiny JUMPI}}(\boldsymbol{\mu}) \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[0] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \\ \boldsymbol{\mu}_{pc} + 1 & \text{otherwise} \end{cases} $ \\
&&&& This has the effect of writing said value to $\boldsymbol{\mu}_{pc}$. See section \ref{ch:model}. \\
\midrule
0x58 & {\small PC} & 0 & 1 & Get the value of the program counter \textit{prior} to the increment \\
&&&&  corresponding to this instruction. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{pc}$ \\
\midrule
0x59 & {\small MSIZE} & 0 & 1 & Get the size of active memory in bytes. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv 32\boldsymbol{\mu}_{i}$ \\
\midrule
0x5a & {\small GAS} & 0 & 1 & Get the amount of available gas, including the corresponding reduction \\
&&&& for the cost of this instruction. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{g}$ \\
\midrule
0x5b & {\small JUMPDEST} & 0 & 0 & Mark a valid destination for jumps. \\
&&&& This operation has no effect on machine state during execution. \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{60s \& 70s: Push Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x60 & {\small PUSH1} & 0 & 1 & Place 1 byte item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv c(\boldsymbol{\mu}_{pc} + 1)$ \\
&&&& $\text{where} \quad c(x) \equiv \begin{cases} I_\mathbf{b}[x] & \text{if} \quad x < \lVert I_\mathbf{b} \rVert \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& The bytes are read in line from the program code's bytes array. \\
&&&& The function $c$ ensures the bytes default to zero if they extend past the limits.\\
&&&& The byte is right-aligned (takes the lowest significant place in big endian). \\
\midrule
0x61 & {\small PUSH2} & 0 & 1 & Place 2-byte item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 2) \big)$ \\
&&&& with $\boldsymbol{c}(\boldsymbol{x}) \equiv (c(\boldsymbol{x}_0), ..., c(\boldsymbol{x}_{\lVert x \rVert -1})) $ with $c$ as defined as above. \\
&&&& The bytes are right-aligned (takes the lowest significant place in big endian). \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x7f & {\small PUSH32} & 0 & 1 & Place 32-byte (full word) item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big((\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 32) \big)$ \\
&&&& where $\boldsymbol{c}$ is defined as above. \\
&&&& The bytes are right-aligned (takes the lowest significant place in big endian). \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{80s: Duplication Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x80 & {\small DUP1} & 1 & 2 & Duplicate 1st stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
0x81 & {\small DUP2} & 2 & 3 & Duplicate 2nd stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x8f & {\small DUP16} & 16 & 17 & Duplicate 16th stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[15]$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{90s: Exchange Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x90 & {\small SWAP1} & 2 & 2 & Exchange 1st and 2nd stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[1] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
0x91 & {\small SWAP2} & 3 & 3 & Exchange 1st and 3rd stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[2]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[2] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x9f & {\small SWAP16} & 17 & 17 & Exchange 1st and 17th stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[16]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[16] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{a0s: Logging Operations}} \vspace{5pt} \\
\multicolumn{5}{l}{For all logging operations, the state change is to append an additional log entry on to the substate's log series:}\\
\multicolumn{5}{l}{$A'_\mathbf{l} \equiv A_\mathbf{l} \cdot (I_a, \mathbf{t}, \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])$}\\
\multicolumn{5}{l}{The entry's topic series, $\mathbf{t}$, differs accordingly:}\vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0xa0 & {\small LOG0} & 2 & 0 & Append log record with no topics. \\
&&&& $\mathbf{t} \equiv ()$ \\
\midrule
0xa1 & {\small LOG1} & 3 & 0 & Append log record with one topic. \\
&&&& $\mathbf{t} \equiv (\boldsymbol{\mu}_\mathbf{s}[2])$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0xa4 & {\small LOG4} & 6 & 0 & Append log record with four topics. \\
&&&& $\mathbf{t} \equiv (\boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[3], \boldsymbol{\mu}_\mathbf{s}[4], \boldsymbol{\mu}_\mathbf{s}[5])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{f0s: System operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0xf0 & {\small CREATE} & 3 & 1 & Create a new account with associated code. \\
&&&& $\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[1] \dots (\boldsymbol{\mu}_\mathbf{s}[1] + \boldsymbol{\mu}_\mathbf{s}[2] - 1) ]$ \\
&&&& $(\boldsymbol{\sigma}', \boldsymbol{\mu}'_g, A^+) \equiv \begin{cases}\Lambda(\boldsymbol{\sigma}^*, I_a, I_o, L(\boldsymbol{\mu}_g), I_p, \boldsymbol{\mu}_\mathbf{s}[0], \mathbf{i}, I_e + 1) & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024\\ \big(\boldsymbol{\sigma}, \boldsymbol{\mu}_g, \varnothing\big) & \text{otherwise} \end{cases}$ \\
&&&& $\boldsymbol{\sigma}^* \equiv \boldsymbol{\sigma} \quad \text{except} \quad \boldsymbol{\sigma}^*[I_a]_n = \boldsymbol{\sigma}[I_a]_n + 1$ \\
&&&& $A' \equiv A \Cup A^+$ which implies: $A'_\mathbf{s} \equiv A_\mathbf{s} \cup A^+_\mathbf{s} \quad \wedge \quad A'_\mathbf{l} \equiv A_\mathbf{l} \cdot A^+_\mathbf{l} \quad \wedge \quad A'_\mathbf{r} \equiv A_\mathbf{r} + A^+_\mathbf{r}$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\
&&&& where $x=0$ if the code execution for this operation failed due to an exceptional halting \\
&&&& $Z(\boldsymbol{\sigma}^*, \boldsymbol{\mu}, I) = \top$ or $I_e = 1024$ \\
&&&& (the maximum call depth limit is reached) or $\boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\sigma}[I_a]_b$ (balance of the caller is too \\
&&&& low to fulfil the value transfer); and otherwise $x=A(I_a, \boldsymbol{\sigma}[I_a]_n)$, the address of the newly \\
&&&& created account, otherwise. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[1], \boldsymbol{\mu}_\mathbf{s}[2])$ \\
&&&& Thus the operand order is: value, input offset, input size. \\
\midrule
0xf1 & {\small CALL} & 7 & 1 & Message-call into an account. \\
&&&& $\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[3] \dots (\boldsymbol{\mu}_\mathbf{s}[3] + \boldsymbol{\mu}_\mathbf{s}[4] - 1) ]$ \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}, I_a, I_o, t, t,\\ \quad C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}), I_p, \boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge \\ \quad\quad I_e < 1024\end{array}\\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& $n \equiv \min(\{ \boldsymbol{\mu}_\mathbf{s}[6], |\mathbf{o}|\})$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[5] \dots (\boldsymbol{\mu}_\mathbf{s}[5] + n - 1) ] = \mathbf{o}[0 \dots (n - 1)]$ \\
&&&& $\boldsymbol{\mu}'_g \equiv \boldsymbol{\mu}_g + g'$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\
&&&& $A' \equiv A \Cup A^+$ \\
&&&& $t \equiv \boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}$ \\
&&&& where $x=0$ if the code execution for this operation failed due to an exceptional halting \\
&&&& $Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) = \top$ or if  \\
&&&& $\boldsymbol{\mu}_\mathbf{s}[2] > \boldsymbol{\sigma}[I_a]_b$ (not enough funds) or $I_e = 1024$ (call depth limit reached); $x=1$ \\
&&&& otherwise. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[3], \boldsymbol{\mu}_\mathbf{s}[4]), \boldsymbol{\mu}_\mathbf{s}[5], \boldsymbol{\mu}_\mathbf{s}[6])$ \\
&&&& Thus the operand order is: gas, to, value, in offset, in size, out offset, out size. \\
&&&& $C_{\text{\tiny CALL}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) + C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$ \\
&&&& $C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv  \begin{cases}
C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) + G_{callstipend} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \neq 0 \\
C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
\min\{ L(\boldsymbol{\mu}_g - C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu})), \boldsymbol{\mu}_{\mathbf{s}}[0] \} & \text{if} \quad \boldsymbol{\mu}_g \ge C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu})\\
\boldsymbol{\mu}_{\mathbf{s}}[0] & \text{otherwise}
\end{cases}$\\
&&&& $C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv G_{call} + C_{\text{\tiny XFER}}(\boldsymbol{\mu}) + C_{\text{\tiny NEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$\\
&&&& $C_{\text{\tiny XFER}}(\boldsymbol{\mu}) \equiv \begin{cases}
G_{callvalue} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny NEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{newaccount} & \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}] = \varnothing \\
0 & \text{otherwise}
\end{cases}$ \\
\midrule
0xf2 & {\small CALLCODE} & 7 & 1 & Message-call into this account with an alternative account's code. \\
&&&& Exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_a, I_o, I_a, t,\\\quad C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}), I_p, \boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\\ \quad\quad{}I_e < 1024\end{array} \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the change in the fourth parameter to the call $\Theta$ from the 2nd stack value $\boldsymbol{\mu}_\mathbf{s}[1]$\\
&&&& (as in {\small CALL}) to the present address $I_a$. This means that the recipient is in fact the\\
&&&& same account as at present, simply that the code is overwritten.\\
\midrule
0xf3 & {\small RETURN} & 2 & 0 & Halt execution returning output data. \\
&&&& $H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots ( \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1 ) ]$ \\
&&&& This has the effect of halting the execution at this point with output defined.\\
&&&& See section \ref{ch:model}. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\midrule
0xf4 & {\small DELEGATECALL} & 6 & 1 & Message-call into this account with an alternative account's code, but persisting\\
&&&& the current values for {\it sender} and {\it value}. \\
<<<<<<< HEAD
&&&& Exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_s, I_o, I_a, t,\\\quad \boldsymbol{\mu}_\mathbf{s}[0], I_p, 0, \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024 \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the changes (in addition to that of the fourth parameter) to the second and eighth\\
&&&& parameters to the call $\Theta$.\\
=======
&&&& Compared with {\small CALL}, {\small DELEGATECALL} takes one fewer arguments.  The omitted\\
&&&& argument is $\boldsymbol{\mu}_\mathbf{s}[2]$. As a result, $\boldsymbol{\mu}_\mathbf{s}[3]$, $\boldsymbol{\mu}_\mathbf{s}[4]$, $\boldsymbol{\mu}_\mathbf{s}[5]$ and $\boldsymbol{\mu}_\mathbf{s}[6]$ in the definition of {\small CALL} \\
&&&& should respectively be replaced with $\boldsymbol{\mu}_\mathbf{s}[2]$, $\boldsymbol{\mu}_\mathbf{s}[3]$, $\boldsymbol{\mu}_\mathbf{s}[4]$ and $\boldsymbol{\mu}_\mathbf{s}[5]$. \\
&&&& Otherwise exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_s, I_o, I_a, t,\\\quad \boldsymbol{\mu}_\mathbf{s}[0], I_p, 0, I_v, \mathbf{i}, I_e + 1)\end{array} & \text{if} \quad I_v \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024 \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the changes (in addition to that of the fourth parameter) to the second \\
&&&& and ninth parameters to the call $\Theta$.\\
>>>>>>> upstream/master
&&&& This means that the recipient is in fact the same account as at present, simply\\
&&&& that the code is overwritten {\it and} the context is almost entirely identical.\\
\midrule
0xff & {\small SUICIDE} & 1 & 0 & Halt execution and register account for later deletion. \\
&&&& $A'_\mathbf{s} \equiv A_\mathbf{s} \cup \{ I_a \}$ \\
&&&& $\boldsymbol{\sigma}'[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_b \equiv \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_b + \boldsymbol{\sigma}[I_a]_b$ \\
&&&& $\boldsymbol{\sigma}'[I_a]_b \equiv 0$ \\
&&&& $A'_{r} \equiv A_{r} + \begin{cases}
R_{suicide} & \text{if} \quad I_a \notin A_\mathbf{s} \\
0 & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny SUICIDE}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv G_{suicide} + \begin{cases}
G_{newaccount} & \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}] = \varnothing \\
0 & \text{otherwise}
\end{cases}$ \\
\bottomrule
\end{tabular*}

%\section{Low-level Lisp-like Language}\label{app:lll}
%The Low-level Lisp-like Language is a language created in order to efficiently author low-level programs (contracts) without having to resort to EVM-Assembly.

\section{Genesis Block}\label{app:genesis}

The genesis block is 15 items, and is specified thus:
\begin{equation}
\big( \big( 0_{256}, \mathtt{\tiny KEC}\big(\mathtt{\tiny RLP}\big( () \big)\big), 0_{160}, stateRoot, 0, 0, 0_{2048}, 2^{17}, 0, 0, 3141592, time, 0, 0_{256},  \mathtt{\tiny KEC}\big( (42) \big) \big), (), () \big)
\end{equation}

Where $0_{256}$ refers to the parent hash, a 256-bit hash which is all zeroes; $0_{160}$ refers to the beneficiary address, a 160-bit hash which is all zeroes; $0_{2048}$ refers to the log bloom, 2048-bit of all zeros; $2^{17}$ refers to the difficulty; the transaction trie root, receipt trie root, gas used, block number and extradata are both $0$, being equivalent to the empty byte array. The sequences of both ommers and transactions are empty and represented by $()$. $\mathtt{\tiny KEC}\big( (42) \big)$ refers to the Keccak hash of a byte array of length one whose first and only byte is of value 42, used for the nonce. $\mathtt{\tiny KEC}\big(\mathtt{\tiny RLP}\big( () \big)\big)$ value refers to the hash of the ommer lists in RLP, both empty lists.

The proof-of-concept series include a development premine, making the state root hash some value $stateRoot$. Also $time$ will be set to the intial timestamp of the genesis block. The latest documentation should be consulted for those values.

\section{Ethash}\label{app:ethash}
\subsection{Definitions}
We employ the following definitions:

\begin{tabular*}{\columnwidth}[h]{lrl}
\toprule
Name & Value & Description \\
\midrule
$J_{wordbytes}$ & 4  & Bytes in word. \\
$J_{datasetinit}$ & $2^{30}$ & Bytes in dataset at genesis. \\
$J_{datasetgrowth}$ & $2^{23}$ & Dataset growth per epoch. \\
$J_{cacheinit}$ & $2^{24}$ & Bytes in cache at genesis. \\
$J_{cachegrowth}$ & $2^{17}$ & Cache growth per epoch. \\
$J_{epoch}$ & 30000 & Blocks per epoch. \\
$J_{mixbytes}$ & 128 & mix length in bytes. \\
$J_{hashbytes}$ & 64 & Hash length in bytes. \\
$J_{parents}$ & 256 & Number of parents of each dataset element. \\
$J_{cacherounds}$ & 3 & Number of rounds in cache production. \\
$J_{accesses}$ & 64 & Number of accesses in hashimoto loop. \\
\bottomrule
\end{tabular*}

\subsection{Size of dataset and cache}
The size for Ethash's cache $\mathbf{c} \in \mathbb{B}$  and dataset $\mathbf{d} \in \mathbb{B}$ depend on the epoch, which in turn depends on the block number.
\begin{equation}
 E_{epoch}(H_i) = \left\lfloor\frac{H_i}{J_{epoch}}\right\rfloor
\end{equation}
The size of the dataset growth by $J_{datasetgrowth}$ bytes, and the size of the cache by $J_{cachegrowth}$ bytes, every epoch. In order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a multiple of $J_{mixbytes}$, for the dataset, and $J_{hashbytes}$ for the cache.
Let $d_{size} = \lVert \mathbf{d} \rVert$ be the size of the dataset. Which is calculated using
\begin{equation}
 d_{size} = E_{prime}(J_{datasetinit} + J_{datasetgrowth} \cdot E_{epoch} - J_{mixbytes}, J_{mixbytes})
\end{equation}
The size of the cache, $c_{size}$, is calculated using
\begin{equation}
 c_{size} = E_{prime}(J_{cacheinit} + J_{cachegrowth} \cdot E_{epoch} - J_{hashbytes}, J_{hashbytes})
\end{equation}
\begin{equation}
 E_{prime}(x, y) = \begin{cases}
x & \text{if} \quad x / y \in \mathbb{P} \\
E_{prime}(x - 1 \cdot y, y) & \text{otherwise}
\end{cases}
\end{equation}
\subsection{Dataset generation}
In order the generate the dataset we need the cache $\mathbf{c}$, which is an array of bytes. It depends on the cache size  $c_{size}$ and the seed hash $\mathbf{s} \in \mathbb{B}_{32}$.
\subsubsection{Seed hash}
The seed hash is different for every epoch. For the first epoch it is the Keccak-256 hash of a series of 32 bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:
\begin{equation}
 \mathbf{s} = C_{seedhash}(H_i)
\end{equation}
\begin{equation}
 C_{seedhash}(H_i) = \begin{cases}
\texttt{KEC}(\mathbf{0}_{32}) & \text{if} \quad E_{epoch}(H_i) = 0 \quad  \\
\texttt{KEC}(C_{seedhash}(H_i - J_{epoch})) & \text{otherwise}
\end{cases}
\end{equation}
With $\mathbf{0}_{32}$ being 32 bytes of zeros.

\subsubsection{Cache}
The cache production process involves using the seed hash to first sequentially filling up $c_{size}$ bytes of memory, then performing $J_{cacherounds}$ passes of the RandMemoHash algorithm created by \cite{lerner2014randmemohash}. The intial cache $\mathbf{c'}$, being an array of arrays of single bytes, will be constructed as follows.

We define the array $\mathbf{c}_{i}$, consisting of 64 single bytes,  as the $i$th element of the intial cache:
\begin{equation}
 \mathbf{c}_{i} = \begin{cases}
\texttt{KEC512}(\mathbf{s}) & \text{if} \quad i = 0 \quad  \\
\texttt{KEC512}(\mathbf{c}_{i-1}) & \text{otherwise}
\end{cases}
\end{equation}
Therefore $ \mathbf{c'}$ can be defined as
\begin{equation}
 \mathbf{c'}[i] = \mathbf{c}_{i} \quad \forall \quad i < n
\end{equation}
\begin{equation}
 n = \left\lfloor\frac{c_{size}}{J_{hashbytes}}\right\rfloor
\end{equation}
The cache is calculated by performing $J_{cacherounds}$ rounds of the RandMemoHash algorithm to the inital cache $\mathbf{c'}$:
\begin{equation}
 \mathbf{c} = E_{cacherounds}(\mathbf{c'}, J_{cacherounds})
\end{equation}
\begin{equation}
 E_{cacherounds}(\mathbf{x}, y) = \begin{cases}
\mathbf{x} & \text{if} \quad y = 0 \quad  \\
E_\text{\tiny RMH}(\mathbf{x}) & \text{if} \quad y = 1 \quad  \\
E_{cacherounds}(E_\text{\tiny RMH}(\mathbf{x}), y -1 ) & \text{otherwise}
\end{cases}
\end{equation}
Where a single round modifies each subset of the cache as follows:
\begin{equation}
 E_\text{\tiny RMH}(\mathbf{x}) = \big( E_{rmh}(\mathbf{x}, 0), E_{rmh}(\mathbf{x}, 1), ... , E_{rmh}(\mathbf{x}, n - 1) \big)
\end{equation}
\begin{multline}
  E_{rmh}(\mathbf{x}, i) = \texttt{KEC512}(\mathbf{x'}[(i - 1 + n) \mod n] \oplus \mathbf{x'}[\mathbf{x'}[i][0] \mod n]) \\
  \text{with} \quad \mathbf{x'} = \mathbf{x} \quad \text{except} \quad \mathbf{x'}[j] = E_{rmh}(\mathbf{x}, j) \quad \forall \quad j < i
\end{multline}

\subsubsection{Full dataset calculation} \label{dataset}
Essentially, we combine data from $J_{parents}$ pseudorandomly selected cache nodes, and hash that to compute the dataset. The entire dataset is then generated by a number of items, each $J_{hashbytes}$ bytes in size:
\begin{equation}
 \mathbf{d}[i] = E_{datasetitem}(\mathbf{c}, i) \quad \forall \quad i < \left\lfloor\frac{d_{size}}{J_{hashbytes}}\right\rfloor
\end{equation}
In order to calculate the single item we use an algorithm inspired by the FNV hash (\cite{FowlerNollVo1991FNVHash}) in some cases as a non-associative substitute for XOR.
\begin{equation}
 E_\text{\tiny FNV}(\mathbf{x}, \mathbf{y}) = (\mathbf{x} \cdot (\mathrm{0x01000193} \oplus \mathbf{y})) \mod 2^{32}
\end{equation}
The single item of the dataset can now be calculated as:
\begin{equation}
 E_{datasetitem}(\mathbf{c}, i) = E_{parents}(\mathbf{c}, i, -1, \varnothing)
\end{equation}
\begin{equation}
  E_{parents}(\mathbf{c}, i, p, \mathbf{m}) = \begin{cases}
E_{parents}(\mathbf{c}, i, p +1, E_{mix}(\mathbf{m}, \mathbf{c}, i, p + 1)) & \text{if} \quad p < J_{parents} -2 \\
E_{mix}(\mathbf{m}, \mathbf{c}, i, p + 1) & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
 E_{mix}(\mathbf{m}, \mathbf{c}, i, p) = \begin{cases}
\texttt{KEC512}(\mathbf{c}[i \mod c_{size}] \oplus i) & \text{if} \quad p = 0 \\
E_\text{\tiny FNV}\big(\mathbf{m}, \mathbf{c}[E_\text{\tiny FNV}(i \oplus p, \mathbf{m}[p \mod \lfloor J_{hashbytes} / J_{wordbytes} \rfloor]) \mod c_{size}] \big) & \text{otherwise}
\end{cases}
\end{equation}

\subsection{Proof-of-work function}
Essentially, we maintain a "mix" $J_{mixbytes}$ bytes wide, and repeatedly sequentially fetch $J_{mixbytes}$ bytes from the full dataset and use the $E_\text{\tiny FNV}$ function to combine it with the mix. $J_{mixbytes}$ bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.

If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of \texttt{KEC} at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes. It also serves to provide statistical assurance that the result is an unbiased, 256 bit number.

The PoW-function returns an array with the compressed mix as its first item and the Keccak-256 hash of the concatenation of the compressed mix with the seed hash as the second item:
\begin{equation}
 \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d}) = \lbrace \mathbf{m}_c(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n, \mathbf{d}), \texttt{KEC}(\mathbf{s}_h(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n) + \mathbf{m}_c(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n, \mathbf{d})) \rbrace
\end{equation}
With $H_{\hcancel{n}}$ being the hash of the header without the nonce. The compressed mix $\mathbf{m}_c$ is obtained as follows:
\begin{equation}
 \mathbf{m}_c(\mathbf{h}, \mathbf{n}, \mathbf{d}) = E_{compress}(E_{accesses}(\mathbf{d}, \sum_{i = 0}^{n_{mix}} \mathbf{s}_h(\mathbf{h}, \mathbf{n}), \mathbf{s}_h(\mathbf{h}, \mathbf{n}), -1), -4)
\end{equation}

The seed hash being:
\begin{equation}
 \mathbf{s}_h(\mathbf{h}, \mathbf{n}) = \texttt{KEC512}(\mathbf{h} + E_{revert}(\mathbf{n}))
\end{equation}
$E_{revert}(\mathbf{n})$ returns the reverted bytes sequence of the nonce $\mathbf{n}$:
\begin{equation}
 E_{revert}(\mathbf{n})[i] = \mathbf{n}[\lVert \mathbf{n} \rVert -i]
\end{equation}
We note that the ``$+$''-operator between two byte sequences results in the concatenation of both sequences.

The dataset $\mathbf{d}$ is obtained as described in section \ref{dataset}.

The number of replicated sequences in the mix is:
\begin{equation}
 n_{mix} =  \left\lfloor\frac{J_{mixbytes}}{J_{hashbytes}}\right\rfloor
\end{equation}
In order to add random dataset nodes to the mix, the $E_{accesses}$ function is used:
\begin{equation}
 E_{accesses}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = \begin{cases}
E_{mixdataset}(\mathbf{d}, \mathbf{m},  \mathbf{s}, i) & \text{if} \quad i = J_{accesses} -2 \\
E_{accesses}(E_{mixdataset}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i), \mathbf{s}, i + 1) & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
 E_{mixdataset}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = E_\text{\tiny FNV}(\mathbf{m}, E_{newdata}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)
\end{equation}
$E_{newdata}$ returns an array with $n_{mix}$ elements:
\begin{equation}
 E_{newdata}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)[j] = \mathbf{d}[E_\text{\tiny FNV}(i \oplus \mathbf{s}[0], \mathbf{m}[i \mod \left\lfloor\frac{J_{mixbytes}}{J_{wordbytes}}\right\rfloor]) \mod \left\lfloor\frac{d_{size} / J_{hashbytes}}{n_{mix}}\right\rfloor \cdot n_{mix} + j] \quad \forall \quad j < n_{mix}
\end{equation}
The mix is compressed as follows:
\begin{equation}
 E_{compress}(\mathbf{m}, i) = \begin{cases}
\mathbf{m} & \text{if} \quad i \geqslant \lVert \mathbf{m} \rVert - 8 \\
E_{compress}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(\mathbf{m}[i + 4], \mathbf{m}[i + 5]), \mathbf{m}[i + 6]), \mathbf{m}[i + 7]), i + 8) & \text{otherwise}
\end{cases}
\end{equation}

\end{document}
