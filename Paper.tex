\documentclass[9pt,oneside]{amsart}
%\usepackage{tweaklist}
\usepackage{url}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}
\usepackage[utf8x]{inputenc}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%

\definecolor{lightyellow}{rgb}{1,0.98,0.9}
\definecolor{lightpink}{rgb}{1,0.94,0.95}

\newcommand{\firsthomesteadblock}{\ensuremath{N_H}}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title{Ethereum: Un registre de transactions généraliste, sécurisé et décentralisé\\ {\smaller \textbf{révision EIP-150}}}

\author{
    Dr. Gavin Wood\\
    Fondateur, Ethereum \& Ethcore\\
    gavin@ethcore.io
}
\begin{document}

\pagecolor{lightyellow}
%\pagecolor{lightpink}

\begin{abstract}
Le paradigme de la blockchain, lorsqu'il est couplé à un mécanisme de transaction sécurisé par la cryptographie, a prouvé son utilité non seulement avec Bitcoin mais aussi dans de nombreux de projets. Chacun de ces projets peut être vu comme une simple application basée sur une ressource de calcul décentralisée mais unitaire. Nous pouvons appeler ce paradigme une machine transactionnelle unique à état partagé.

Ethereum implémente ce paradigme de façon généraliste. De plus, Ethereum permet une pluralité de telles ressources, chacune possédant un état distinct et un code fonctionnel, mais néanmoins susceptibles d'interagir via un framework d'échange de messages. Nous discuterons de sa conception, des problèmes d'implémentation, des opportunités que cela fournit et des obstacles que nous anticipons.
\end{abstract}

\maketitle

\setlength{\columnsep}{20pt}
\begin{multicols}{2}

\section{Introduction}\label{sec:introduction}

Internet étant présent dans les plupart des endroits de la planète, la transmission de l'information est globalement devenue incroyablement bon marché. Les innovations technologiques telles que Bitcoin ont démontré, par le pouvoir d'un mécanisme de consensus et de respect volontaire d'un contrat social, qu'il était possible d'utiliser Internet pour créer un système décentralisé de transfert de valeurs, partagé à travers le monde et quasiment gratuit à utiliser. Ce système peut être décrit comme une version très spécifique d'une machine a états basée sur des transactions et sécurisée par la cryptographie. Des systèmes de suivi tels que Namecoin ont adapté ce système original d' ``application monétaire’‘  à d'autres applications quoiqu’elles furent plutôt simples.

Ethereum est un projet qui cherche à créer une version généraliste de cette technologie; technologie sur laquelle tous les concepts de machine transactionnelle à états pourraient être construits. De plus Ethereum a pour but de fournir au développeur final un système intégré de bout en bout afin de construire des logiciels basés sur un paradigme de calcul jusque-là inexploré : un framework de confiance pour la messagerie, le calcul et les objets.

\subsection{Principes directeurs} \label{ch:driving}

Ce projet a beaucoup d’objectifs; un des principaux est de faciliter les transactions entre deux individus consentants qui n'auraient sans cela aucun moyen de se faire confiance l'un à l'autre. Cela peut être dû à une séparation géographique, une difficulté d'interaction, ou peut-être à l'incompatibilité, l'incompétence, la réticence, le coût, l'incertitude, la gêne ou encore la corruption des systèmes légaux existants. En définissant un système de changement d'état à travers un langage riche et non ambigu, et de plus en architecturant un système tel que nous pouvons raisonnablement en attendre qu'un accord soit assuré de manière autonome, nous pouvons fournir un moyen à cette fin.

Les opérations dans le système proposé pourraient avoir beaucoup d'attributs qui souvent n'existent pas dans le monde réel. L'incorruptibilité d'appréciation, souvent difficile à trouver, est naturelle lorsqu'elle vient d'un interpréteur algorithmique désintéressé. La transparence, ou capacité à voir exactement comment un état ou un jugement s'est produit au travers des journaux et règles d'une transaction ou des codes d'instructions, n'est jamais parfaitement atteinte dans les systèmes basés sur l'humain, parce que le langage naturel est nécessairement vague, que de l'information manque souvent et que des préjudices antérieurs sont difficiles à démêler.

De manière générale, je souhaite fournir un système dans lequel les utilisateurs peuvent être sûrs que peu importe avec quels autres individus, systèmes ou organisations ils interagissent, ils peuvent le faire en ayant une confiance absolue dans les résultats possibles et les règles guidant l'obtention de ces résultats.

\subsection{Travaux antérieurs} \label{ch:previous}

\cite{buterin2013ethereum} a proposé initialement le noyau de ce travail fin Novembre 2013. Bien qu'elle ait maintenant évolué sur de nombreux points, la fonctionnalité clé d'une blockchain possédant un langage Turing-complet et une capacité illimitée de stockage inter-transaction fonctionnelle demeure inchangée.

\cite{dwork92pricingvia} a fourni le premier travail d'usage de la preuve cryptographique d’effort de calcul (``proof-of-work, ou preuve de travail'') ayant pour but de transmettre un signal de valeur à travers Internet. Le signal de valeur était utilisé ici comme un mécanisme de dissuasion de spam plutôt que comme une forme de monnaie, mais a démontré de manière décisive le potentiel d'un canal de données basique à porter un \textit{signal économique fort}, autorisant un récepteur à faire une vérification physique sans avoir à s'en remettre à une forme de \textit{confiance}. \cite{back2002hashcash} a plus tard produit un système dans la même veine.

Le premier exemple d'utilisation de la preuve de travail en tant que signal économique fort pour sécuriser une monnaie a été utilisé par \cite{vishnumurthy03karma:a}. Dans cet exemple, le jeton était utilisé pour contrôler l'échange de fichiers en pair to pair et permettait aux ``consommateurs'' de procéder à des micro-paiements aux ``fournisseurs'' pour leurs services. Le modèle de sécurité apporté par la preuve de travail était augmenté avec les signatures digitales et un registre dans le but de protéger l'historique des enregistrements contre la corruption, et contre des actes malicieux tels que la falsification des paiements ou les plaintes abusives. Cinq ans plus tard, \cite{nakamoto2008bitcoin} introduisit un autre jeton de valeur basé sur une preuve de travail sécurisée avec une portée plus large. Le fruit de ce projet, Bitcoin, est devenu le premier registre global décentralisé de transactions à être largement adopté.

D'autres projets construits à partir de Bitcoin ont réussi; les altcoins, ou monnaies alternatives, ont introduit de nombreuses autres monnaies en modifiant le protocole. Quelques-unes des plus connues sont Litecoin et Primecoin, citées par \cite{sprankel2013technical}. D'autres projets ont su prendre la valeur essentielle contenue dans le mécanisme du protocole et de la réappliquer; \cite{aron2012bitcoin} a décrit, par exemple, du projet Namecoin qui a pour but de fournir un système de résolution de nom décentralisé.

D'autres projets visent toujours à construire par-dessus le réseau Bitcoin lui-même, tirant profit de l’importante valeur placée dans le système et de la très grande puissance de calcul destinée au mécanisme de consensus. Le projet Mastercoin, proposé initialement par \cite{mastercoin2013willett}, vise à construire un protocole plus riche, impliquant beaucoup de fonctionnalités de haut niveau par-dessus le protocole Bitcoin à travers l'utilisation d'un grand nombre de parties auxiliaires au protocole de base. Le projet Colored Coins, proposé par \cite{colouredcoins2012rosenfeld}, a une stratégie similaire mais plus simple, agrémentant les règles d'une transaction afin de casser la fongibilité de la monnaie de base Bitcoin et autoriser la création  et le suivi des jetons à travers un ``chroma-wallet'', une surcouche logicielle fonctionnant avec le protocole.

Des travaux supplémentaires ont été effectués avec pour idée d'écarter les fondements de la décentralisation; Ripple, décrit par \cite{boutellier2014pirates}, a cherché à créer un système fédéré pour l'échange de devises constituant effectivement un nouveau système de compensation financière. Cela a démontré que de gros gains d'efficience peuvent être faits si le principe de la décentralisation est rejeté.

Antérieurement un travail sur les smart contracts a été effectué par \cite{szabo1997formalizing} et \cite{miller1997future}. Autour des années 90 il est devenu clair que la résolution par un algorithmique des accords entre humains pourrait devenir une force significative dans la coopération. Bien qu'aucun système spécifique n'ait été proposé pour implémenter un tel système, il a été présumé que le futur du droit soit profondément affecté par ce genre de résolution. Dans cette optique, Ethereum peut être vu comme une implémentation généraliste d'un tel système de \textit{droit cryptographique}.

%E language?

\section{Le paradigme de la blockchain} \label{ch:overview}

Ethereum, pris dans son ensemble, peut être vu comme une machine à état basée sur des transactions: nous commençons avec un état originel, et exécutons des transactions de manière incrémentale pour le transformer en un état final. C'est cet état final que nous acceptons comme la ``version'' canonique du monde d'Ethereum. L'état peut inclure des informations telles que les soldes de comptes, la réputation, des accords de confiance, des données portant sur l'information du monde physique; en résumé, tout ce qui peut actuellement être représenté par un ordinateur est admissible. Les transactions représentent ainsi une passerelle valide entre deux états; l’aspect `valide' est importante---il existe beaucoup plus de changements d'état invalides que de changements d'état valides. Les changements d'état invalides pourraient par exemple être des choses telles que réduire le solde d'un compte sans compenser ailleurs d'un montant équivalent. Un changement d'état valide est un changement produit par le truchement d’une transaction. Formellement: 
\begin{equation}
\boldsymbol{\sigma}_{t+1} \equiv \Upsilon(\boldsymbol{\sigma}_t, T)
\end{equation}


où $\Upsilon$ est la fonction de transition d'état d’Ethereum. Dans Ethereum, $\Upsilon$, combiné avec $\boldsymbol{\sigma}$ sont considérablement plus puissants que tous les systèmes comparables existants; $\Upsilon$ autorise les composants à effectuer des calculs arbitraires, alors que $\boldsymbol{\sigma}$ autorise les composants à stocker des états arbitraires entre les transactions.

Les transactions sont regroupées dans des blocs; les blocs sont chaînés les uns aux autres en utilisant un haché cryptographique comme technique de référencement. Les blocs fonctionnent comme un journal, enregistrant une série de transactions ainsi que le bloc précédant et un identifiant pour l'état final (l'état final n'est cependant pas stocké lui-même---cela serait beaucoup trop volumineux). Ils ponctuent également la série de transaction avec une incitation pour les n\oe{}uds à \textit{miner}.

Miner est le processus consistant à dédier de l'effort (du travail) pour soutenir une série de transactions (un bloc) contre n'importe quel autre bloc concurrent. Cela est mis en \oe{}uvre grâce à une preuve cryptographique sécurisée. Ce schéma est connu comme preuve de travail (proof-of-work), et est étudié en détail dans la section \ref{ch:pow}.


Formellement, on développe ainsi:
\begin{eqnarray}
\boldsymbol{\sigma}_{t+1} & \equiv & \Pi(\boldsymbol{\sigma}_t, B) \\
B & \equiv & (..., (T_0, T_1, ...) ) \\
\Pi(\boldsymbol{\sigma}, B) & \equiv & \Omega(B, \Upsilon(\Upsilon(\boldsymbol{\sigma}, T_0), T_1) ...)
\end{eqnarray}


Où $\Omega$ est la fonction de changement d'état finalisant le bloc (une fonction qui récompense un ensemble désigné); $B$ est ce bloc, qui inclut une série de transactions parmi d'autres éléments; et $\Pi$ est la fonction de changement d'état au niveau du bloc.

Ceci est la base du paradigme de la blockchain, un modèle qui forme la colonne vertébrale non seulement d'Ethereum, mais aussi de tous les systèmes de transactions décentralisés basés sur consensus à l'heure actuelle.

\subsection{Valeur}


Dans le but d'inciter à l’affectation de puissance de calcul à l'intérieur du réseau, il y a besoin de convenir d'une méthode pour transmettre la valeur. Pour régler ce problème, Ethereum a une monnaie intrinsèque, l'Ether, aussi connue comme {\small ETH}, et parfois en référence à l'Anglais Ancien \DH{} (prononcé Eth). La plus petite sous-unité de l'Ether, et celle dans laquelle toutes les valeurs entières de la monnaie sont comptées est le Wei. Un Ether représente $10^{18}$ Wei. Il existe d'autres unités dérivées de l'Ether:
\par
\begin{center}
\begin{tabular}{rl}
\toprule
Ordre de grandeur & Nom \\
\midrule
$10^0$ & Wei \\
$10^{12}$ & Szabo \\
$10^{15}$ & Finney \\
$10^{18}$ & Ether \\
\bottomrule
\end{tabular}
\end{center}
\par

Tout au long du présent document, toute référence à une valeur ou à l'Ether, comme monnaie, balance ou paiement, sera exprimée en Wei.

\subsection{Quel historique?}

Puisque le système est décentralisé et que toutes les parties ont une opportunité de créer un nouveau bloc sur un bloc préexistant, la structure résultante est nécessairement un arbre de blocs. Il est nécessaire de disposer d’un schéma de passage consensuelle dans cette structure, c’est-à-dire un chemin depuis la racine (le bloc originel) jusqu'à la feuille (le bloc contenant les transactions les plus récentes) qui fasse consensus à travers cette structure d'arbre connue sous le nom de blockchain. Si jamais il y avait un désaccord entre les n\oe{}uds sur quel des chemins de l'arbre des blocs constitue la `meilleure' blockchain, alors il y a fourche (fork en anglais).  

Cela voudrait dire que passé un point donné dans le temps (bloc), plusieurs états du système peuvent coexister: certains n\oe{}uds croyant qu'un bloc contient les transactions canoniques, tandis que d'autres n\oe{}uds croyant être canonique un autre bloc, celui-ci contenant potentiellement des transactions radicalement différentes ou incompatibles. Ceci est à éviter à tout prix, tout comme l'incertitude qui s'ensuivrait et qui pourrait tuer la confiance dans le système entier. 

Le schéma que nous utilisons pour générer un consensus est une version simplifiée du protocole GHOST, introduit par \cite{cryptoeprint:2013:881}. Ce processus est décrit en détail dans la section \ref{ch:ghost}.

\section{Conventions}\label{ch:conventions}

J'utilise un nombre de conventions typographiques pour les notations formelles, quelques-unes sont un peu particulières au document présent:

Les deux ensembles de haut niveau, hautement structurés, des valeurs d'état, sont notés en minuscules grecques en gras. Ces valeurs relèvent de la catégorie de l'état du monde noté $\boldsymbol{\sigma}$ (ou une variante de celui-ci) ou de celle de l'état de la machine, $\boldsymbol{\mu}$.

Les fonctions opérant sur ces valeurs hautement structurées sont notés en lettre Grecque majuscule, par exemple $\Upsilon$, la fonction de changement d'état d'Ethereum.

Pour la plupart des fonctions, une lettre majuscule est utilisée, par exemple $C$, la fonction de coût général. Elles peuvent être indicées pour dénoter des variantes spécifiée, par exemple $C_\text{\tiny SSTORE}$,
la fonction de coût pour l'opération {\tiny SSTORE}. Pour certaines fonctions spécialisées et éventuellement définies de manière externe, je peux utiliser une typographie particulière, par exemple la fonction de hachage Keccak-256 (la gagnante du concours SHA-3) est dénotée $\texttt{KEC}$ (et généralement référencée comme simple Keccak). Aussi, $\texttt{KEC512}$ fait référence à une fonction de hachage Keccak 512.

Les tuples sont typiquement notés en lettres majuscules, par exemple $T$ est utilisé pour noter une transaction Ethereum. Ce symbole peut, s’il est défini en conséquence, être indicée pour faire référence à un composant individuel, \eg $T_n$, dénote le nonce de ladite transaction. la forme de l'indice est utilisée pour dénoter son type; par exemple des indices en majuscule font référence à des tuples avec des composants indiçables.

Les scalaires et les séquences d'octets de taille fixe (analogue, les tableaux), sont notés avec une lettre normale minuscule, par exemple $n$ est utilisée pour représenter le nonce de telle transaction. Ceux qui ont une signification particulière peuvent être grecs, par exemple $\delta$, le nombre d'éléments requis dans la pile pour une opération donnée.

Des séquences de longueur arbitraire sont typiquement notés en lettre minuscule et en gras, par exemple $\mathbf{o}$ est utilisé pour représenter la séquence d'octets en sortie d'un appel de message. Pour les valeurs particulièrement importantes, une lettre en majuscule et en gras peut être utilisée.

Tout au long du document nous supposons que les valeurs scalaires sont des entiers positifs, et qu'elles appartiennent à l'ensemble $\mathbb{P}$. L'ensemble de toutes les séquences d'octets est $\mathbb{B}$, formellement défini dans l'annexe \ref{app:rlp}. Si un tel ensemble de séquences est restreint à celles d'une longueur particulière, cela est dénoté avec un indice, ainsi, l'ensemble de toutes les séquences d'octets de longueur $32$  est nommé $\mathbb{B}_{32}$ et l'ensemble de tous les entiers positifs plus petits que $2^{256}$ est nommé $\mathbb{P}_{256}$. Cela formalisé dans la section \ref{ch:block}.

Les crochets sont utilisés pour indexer et référencer les composants individuels ou les sous-séquences de séquences, par exemple $\boldsymbol{\mu}_\mathbf{s}[0]$ représente le premier objet dans la pile de la machine. Pour les sous-séquences, les ellipses sont utilisées pour spécifier la tranche attendue en incluant les éléments au deux limites, par exemple $\boldsymbol{\mu}_\mathbf{m}[0..31]$ représente les 32 premiers objets de la mémoire de la machine.

Dans le cas de l'état global $\boldsymbol{\sigma}$, qui est une séquence de comptes, eux-mêmes des tuples, les crochets sont utilisés pour référencer un compte individuel.

En considérant les variantes des valeurs existantes, je suis la règle qu'au sein d'un périmètre donné comme définition, si nous supposons que la valeur d'`input' non modifiée est désignée par le signe $\Box$ alors la valeur modifiée et utilisable est représentée comme $\Box'$, et les valeurs intermédiaires seraient alors $\Box^*$, $\Box^{**}$ etc. Dans des cas vraiment très particuliers, dans le but de maximiser la lisibilité et seulement si c'est d'un sens non ambigu, je peux utiliser des indices alphanumériques pour représenter des valeurs intermédiaires.		 

En considérant l'utilisation de fonctions existantes, une fonction $f$ étant donnée, la fonction $f^*$ représente une version similaire élément par élément, de la mise en correspondance (mapping) des éléments de la fonction plutôt qu'entre les séquences d’élements. Cela est précisément décrit dans la section \ref{ch:block}.

Je définis un nombre de fonctions utiles à travers ce document. Une des plus communes est $\ell$, qui évalue le dernier objet de la séquence donnée:

\begin{equation}
\ell(\mathbf{x}) \equiv \mathbf{x}[\lVert \mathbf{x} \rVert - 1]
\end{equation}

\section{Blocs, état et transactions} \label{ch:bst}

Ayant introduit les concepts de base d'Ethereum, nous allons discuter de la signification d'une transaction, d'un bloc et de l'état de manière plus détaillée.

\subsection{L'état du monde} \label{ch:state}

L'état du monde (\textit{l'état}), est une mise en correspondance (mapping) entre les adresses (identifiants de 160-bit) et l'état des comptes (une structure de données serialisée comme RLP (Recursive Length Prefix - Préfixe de Longueur Récursive), voir annexe \ref{app:rlp}). Bien que non stockée sur la blockchain, on suppose que l'implémentation va maintenir ce mapping dans un arbre radix merkle modifié (\textit{trie}, voir annexe \ref{app:trie}). Le trie nécessite une base de données en arrière-plan qui maintienne un mapping de tableau de bytes à tableau de bytes; nous nommons cette base de données sous jacente la base de données d'état. Elle a un grand nombre d'avantages; premièrement le n\oe{}uds racine de cette structure est cryptographiquement dépendant de toute les données internes et son haché peut être utilisé comme une identité sécurisée pour l'état du système entier. Deuxièmement, étant une structure de données immutable, elle permet à n'importe quel état précédent (dont le haché racine est connu) d’être appelé à nouveau en altérant simplement le haché racine en fonction. Comme nous stockons tous ces hachés racines dans la blockchain, nous sommes capables de revenir aux anciens états de manière triviale.

L'état d'un compte comprend les quatre champs suivants:	

\begin{description}
\item[nonce] Une valeur scalaire égale au nombre de transactions envoyées depuis cette adresse, ou, dans le cas d'un compte contenant du code, le nombre de contrats créés par ce compte. Pour les comptes ou les adresses $a$ dans l'état $\boldsymbol{\sigma}$, cela sera représenté par $\boldsymbol{\sigma}[a]_n$.
\item[balance] Une valeur scalaire égale au nombre de Wei possédés par cette adresse. Représentée par $\boldsymbol{\sigma}[a]_b$.
\item[storageRoot] Un haché de 256-bit du n\oe{}uds racine d'un arbre radix merkle qui encode le stockage des contenus du compte (un mapping entre des valeurs entières de 256 bits), encodés dans le trie comme un mapping entre le haché Keccak 256 bits des clés entières de 256 bits et les valeurs entières encodées par RLP de 256 bits. Le haché est noté $\boldsymbol{\sigma}[a]_s$.
\item[codeHash] Le haché du code EVM du compte---c'est le code qui est exécuté lorsque cette adresse reçoit un appel de message; il est immutable et ainsi, contrairement à tous les autres champs, ne peut pas être changé après construction. Tous ces fragments de code sont contenus dans la base de données d'état sous leur haché correspondant pour les récupérer plus tard. Ce haché est noté $\boldsymbol{\sigma}[a]_c$, et ainsi le code peut être représenté par $\mathbf{b}$, sachant que $\texttt{\small KEC}(\mathbf{b}) = \boldsymbol{\sigma}[a]_c$.
\end{description}

Comme je souhaite typiquement faire référence, non pas au haché racine du trie mais à l'ensemble des paires clé/valeur stockées à l'intérieur, je définis une équivalence pratique: 
\begin{equation}
\texttt{\small TRIE}\big(L_I^*(\boldsymbol{\sigma}[a]_\mathbf{s})\big) \equiv \boldsymbol{\sigma}[a]_s
\end{equation}

la fonction d'effondrement ordinale pour l'ensemble de paires de clé/valeur dans le trie, $L_I^*$, est définie comme la transformation élément par élément de la fonction de base $L_I$, définie par:
\begin{equation}
L_I\big( (k, v) \big) \equiv \big(\texttt{\small KEC}(k), \texttt{\small RLP}(v)\big)
\end{equation}

où:
\begin{equation}
k \in \mathbb{B}_{32} \quad \wedge \quad v \in \mathbb{P}
\end{equation}

Il faut comprendre ici que $\boldsymbol{\sigma}[a]_\mathbf{s}$ n'est pas un membre `physique' du compte et ne contribue pas a sa sérialisation ultérieure.

Si le champ \textbf{codeHash} est le haché Keccak-256 de la chaîne (de caractères) vide, i.e. $\boldsymbol{\sigma}[a]_c = \texttt{\small KEC}\big(()\big)$, alors le n\oe{}uds représente un simple compte, parfois dénommé compte ``non-contrat''.

Ainsi nous pouvons définir une fonction d'effondrement ordinale de l'état du monde $L_S$:
\begin{equation}
L_S(\boldsymbol{\sigma}) \equiv \{ p(a): \boldsymbol{\sigma}[a] \neq \varnothing \}
\end{equation}
où
\begin{equation}
p(a) \equiv  \big(\texttt{\small KEC}(a), \texttt{\small RLP}\big( (\boldsymbol{\sigma}[a]_n, \boldsymbol{\sigma}[a]_b, \boldsymbol{\sigma}[a]_s, \boldsymbol{\sigma}[a]_c) \big) \big)
\end{equation}

cette fonction , $L_S$, est utilisée tout au long de la fonction de trie pour fournir une identité courte (hash) à l'état du monde. Nous supposons:
\begin{equation}
\forall a: \boldsymbol{\sigma}[a] = \varnothing \; \vee \; (a \in \mathbb{B}_{20} \; \wedge \; v(\boldsymbol{\sigma}[a]))
\end{equation}
où $v$ est la fonction de validité de compte:
\begin{equation}
\quad v(x) \equiv x_n \in \mathbb{P}_{256} \wedge x_b \in \mathbb{P}_{256} \wedge x_s \in \mathbb{B}_{32} \wedge x_c \in \mathbb{B}_{32}
\end{equation}

\subsection{Homestead} \label{ch:homestead}

Un numéro de bloc significatif pour la compatibilité avec le réseau public est le bloc marquant la transition entre les phases {\it Frontier} et {\it Homestead} de la plateforme, que nous représentons avec le symbole \firsthomesteadblock, défini ainsi 
\begin{equation}
\firsthomesteadblock \equiv 1,\! 150,\! 000
\end{equation}
Le protocole a été mis à jour à ce bloc, donc ce symbole apparait dans quelques équations des comptes, pour les changements.

\subsection{La Transaction} \label{ch:transaction}

Une transaction ($T$) est une instruction de signature cryptographique unique construite par un acteur externe au périmètre d'Ethereum. Alors que nous supposons que l'ultime acteur externe sera humain par nature, des outils logiciels seront utilisés pour sa construction et sa propagation\footnote{Particulièrement, de tels `outils' pourraient en fin de compte devenir tellement disjoints de leur relation causale à une création humaine---ou bien les humains pourraient y devenir indifférents---qu'ils pourraient se comporter comme des agents autonomes. Par exemple les contrats pourraient offrir des primes aux humains pour avoir envoyé des transactions pour initier leur exécution.}. Il y a deux types de transactions: celles qui entraînent des appels de messages et celles qui entraînent la création de nouveaux comptes auxquels est associé du code (connues de manière informelle sous le nom de `créations de contrat'). Ces deux types de transaction spécifient un certain nombre de champs communs:

\begin{description}
\item[nonce] Une valeur scalaire égale au nombre de transactions émises par l'envoyeur $T_n$.
\item[gasPrice] Une valeur scalaire égale au nombre de Wei à payer par unité de \textit{gas} pour tous les coûts de calcul engagés comme résultat de l'exécution de cette transaction; $T_p$.
\item[gasLimit] Une valeur scalaire égale au montant maximum de gas qui peut être utilisé en exécutant cette transaction. Cela est payé en amont, avant que tout calcul soit fait et ne peut pas être augmenté plus tard; $T_g$.
\item[to] L'adresse de 160 bits du destinataire de l'appel de message ou, pour une transaction de création de contrat , $\varnothing$, utilisé ici pour noter le seul membre de $\mathbb{B}_0$ ; formellement $T_t$.
\item[value] Une valeur scalaire égale au nombre de Wei à transférer au destinataire de l'appel de message ou, dans le cas d'une création de contrat, comme une dotation pour le nouveau compte à créer; $T_v$.
\item[v, r, s] Les valeurs correspondantes à la signature de la transaction et utilisées pour déterminer l'emetteur de la transaction; formellement $T_w$, $T_r$ and $T_s$. Cela est détaillé dans l'annexe \ref{app:signing}.
\end{description}

De plus, une transaction de création de contrat contient:

\begin{description}
\item[init] Un tableau d'octets de taille illimitée contenant le code EVM pour la procédure d'initialisation du compte, $T_\mathbf{i}$.
\end{description}

\textbf{init} est un fragment de code EVM; il retourne le \textbf{body}, un second fragment de code qui s'exécute à chaque fois que le compte reçoit un appel de message (soit au travers d'une transaction, soit par l'exécution interne de code). \textbf{init} est exécuté une seule fois à la création du compte et reste écarté immédiatement après.

En revanche, une transaction d'appel de message contient:

\begin{description}
\item[data] Un tableau d'octets illimité spécifiant la donnée entrante de l'appel de message, $T_\mathbf{d}$.
\end{description}

L'annexe \ref{app:signing} décrit la fonction, $S$, qui fait correspondre les transactions au destinataire, et s'exécute à travers l'ECDSA de la courbe SECP-256k1, utilisant le hash de la transaction (excepté les trois derniers champs de signature) en tant que datum à signer. Pour le moment nous nous assurons seulement que l'émetteur d'une transaction donnée peut être représenté par $S(T)$.

\begin{equation}
L_T(T) \equiv \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}, T_w, T_r, T_s) & \text{if} \; T_t = \varnothing\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}, T_w, T_r, T_s) & \text{otherwise}
\end{cases}
\end{equation}

Ici, nous supposons que tous les composants sont interprétés par le RLP comme des valeurs entières, avec l'exception des tableaux d'octets de longueur arbitraire $T_\mathbf{i}$ et $T_\mathbf{d}$.

\begin{equation}
\begin{array}[t]{lclclc}
T_n \in \mathbb{P}_{256} & \wedge & T_v \in \mathbb{P}_{256} & \wedge & T_p \in \mathbb{P}_{256} & \wedge \\
T_g \in \mathbb{P}_{256} & \wedge & T_w \in \mathbb{P}_5 & \wedge & T_r \in \mathbb{P}_{256} & \wedge \\
T_s \in \mathbb{P}_{256} & \wedge & T_\mathbf{d} \in \mathbb{B} & \wedge & T_\mathbf{i} \in \mathbb{B}
\end{array}
\end{equation}
où
\begin{equation}
\mathbb{P}_n = \{ P: P \in \mathbb{P} \wedge P < 2^n \}
\end{equation}

Le hash de l'adresse $T_\mathbf{t}$ est légèrement différent: c'est soit le hash de 20 octets d'une adresse, ou, dans le cas d'une création de contrat (et ainsi formellement égal à $\varnothing$), c'est la série RLP d'octets vides et ainsi le membre de $\mathbb{B}_0$:

\begin{equation}
T_t \in \begin{cases} \mathbb{B}_{20} & \text{if} \quad T_t \neq \varnothing \\
\mathbb{B}_{0} & \text{otherwise}\end{cases}
\end{equation}

\subsection{Le Bloc} \label{ch:block}


Le bloc dans Ethereum est l'ensemble de morceaux d'information pertinents (connu comme \textit{l'en-tête} du bloc), $H$, ainsi que l'information correspondant aux transactions incluses, $\mathbf{T}$, et un ensemble d'autres en-têtes $\mathbf{U}$ qui sont connus pour avoir un parent égal au parent du parent du bloc actuel  (ce genre de blocs sont connus en tant que (TODO : traduire ommer, dans la suite du doc aussi) \textit{ommers}\footnote{\textit{ommer} est le terme, neutre au niveau du genre, le plus répandu pour représenter ``la fraternité du parent''; voir \url{http://nonbinary.org/wiki/Gender_neutral_language#Family_Terms}}). L'en-tête du bloc contient plusieurs parties d'information:


%\textit{TODO: Introduire les logs}

\begin{description}
\item[parentHash] Le hash Keccak de 256 bits de l'en-tête du bloc parent, dans son entièreté; $H_p$.
\item[ommersHash] Le hash Keccak de 256 bits de la section de liste de (TODO) ommers de ce bloc; $H_o$.
\item[beneficiary] L'addresse de 160 bits à laquelle seront envoyés tous les frais collectés par le minage réussi de ce bloc; $H_c$.
\item[stateRoot]  Le hash Keccak de 256 bits du noeud racine du trie d'état, après que toutes les transactions sont exécutées et que les finalisations sont appliquées; $H_r$.
\item[transactionsRoot] Le hash Keccak de 256 bits du noeud racine de la structure du trie, peuplé avec chaque transaction dans la section de la liste de transactions du bloc; $H_t$.
\item[receiptsRoot] Le hash Keccak de 256 bits du noeud racine de la structure de  (TODO : trie) trie, peuplée avec les reçus de chaque transaction dans la section de la liste de transactions du bloc; $H_e$.
\item[logsBloom] Le filtre de Bloom composé de l'information indexable (l'adresse du logger et les sujets de log) contenu dans chaque entrée de log depuis le reçu de chaque transaction dans la liste de transactions; $H_b$.
\item[difficulty] Une valeur scalaire correspondant au niveau de difficulté de ce bloc. Il peut être calculé à partir de la difficulté précédente et du timestamp; formally $H_d$.
\item[number] Une valeur scalaire égale au nombre de blocs ancêtre. Le bloc origine a un number de zéro; $H_i$.
\item[gasLimit] Une valeur scalaire égale à la limite courante d'usage de gaz par bloc; $H_l$.
\item[gasUsed] Une valeur scalaire égale au gaz total utilisé par les transactions dans ce bloc; $H_g$.
\item[timestamp] Une valeur scalaire égale à un timestamp Unix raisonnable (time()) pour la naissance de ce bloc; $H_s$.
\item[extraData] Un tableau d'octets de longueur arbitraire contenant des données relatives à ce bloc. Il doit être de 32 octets ou moins; $H_x$.
\item[mixHash] Un hash de 256 bits qui prouve, combiné avec le nonce, qu'une quantité suffisante de calcul informatique a été consacré à ce bloc; $H_m$.
\item[nonce] Un hash de 64 bits qui prouve, combiné avec mix-hash, qu'une quantité suffisante de calcul informatique a été consacré à ce bloc; $H_n$.
\end{description}

Les deux derniers composants dans le bloc sont simplement une liste d'en-têtes de blocs ommer (du même format que ci-dessus) et une liste des transactions. Formellement, on peut noter le bloc $B$:
\begin{equation}
B \equiv (B_H, B_\mathbf{T}, B_\mathbf{U})
\end{equation}

\subsubsection{Quittance de transaction}

De façon à pouvoir stocker l'information concernant une transaction, pour laquelle il peut être utile de fournir une preuve à divulgation nulle de connaissance, ou l'indexer à fins de recherche, nous encodons un récépissé de chaque transaction contenant des informations à propos de son exécution. Chaque récépissé, noté $B_\mathbf{R}[i]$ pour la $i$ème transaction, est placé dans un trie indexé et la racine est encodée dans son en-tête comme $H_e$.

Le récépissé de transaction est un tuple de quatre items comprenant l'état post-transaction $R_{\boldsymbol{\sigma}}$, la totalité du gaz consommé par le bloc contenant le récépissé de transaction comme celle usée immédiatement après sa ratification $R_u$, l'ensemble des journaux créés durant la transaction $R_\mathbf{l}$, et le filtre de Bloom constitué par l'information dans ces journaux $R_b$:
\begin{equation}
R \equiv (R_{\boldsymbol{\sigma}}, R_u, R_b, R_\mathbf{l})
\end{equation}

La fonction $L_R$ prépare simplement le récépissé de transaction à être transformé en un tableau d'octets ordonné RLP:
\begin{equation}
L_R(R) \equiv (\mathtt{\small TRIE}(L_S(R_{\boldsymbol{\sigma}})), R_u, R_b, R_\mathbf{l})
\end{equation}
ainsi l'état post-transaction $R_{\boldsymbol{\sigma}}$ est encodé dans une structure de trie, dont la racine est le premier item.

On définit $R_u$, le gaz consommé comme un entier positif et les journaux Bloom $R_b$, comme hash de taille 2048 bits (256 octets):
\begin{equation}
R_u \in \mathbb{P} \quad \wedge \quad R_b \in \mathbb{B}_{256}
\end{equation}

%Notably $B_\mathbf{T}$ does not get serialised into the block by the block preparation function $L_B$; it is merely a convenience equivalence.

Les rubriques de journalisation, $R_\mathbf{l}$, sont une série de traces, dénotées, par exemple, $(O_0, O_1, ...)$. Une trace $O$, est un tuple d'une adresse d'enregistreur $O_a$, d'une série de sujets de 32-octets de long $O_\mathbf{t}$, et d'un certain nombre d'octets de data, $O_\mathbf{d}$:
\begin{equation}
O \equiv (O_a, ({O_\mathbf{t}}_0, {O_\mathbf{t}}_1, ...), O_\mathbf{d})
\end{equation}
\begin{equation}
O_a \in \mathbb{B}_{20} \quad \wedge \quad \forall_{t \in O_\mathbf{t}}: t \in \mathbb{B}_{32} \quad \wedge \quad O_\mathbf{d} \in \mathbb{B}
\end{equation}

On définit la fonction filtre de Bloom $M$, comme réduction d'une rubrique de journal en une empreinte de 256 octets:
\begin{equation}
M(O) \equiv \bigvee_{t \in \{O_a\} \cup O_\mathbf{t}} \big( M_{3:2048}(t) \big)
\end{equation}

où $M_{3:2048}$ un filtre de Bloom spécialisé qui extrait trois bits de 2048, une série d'octets arbitraire étant donnée. Cela est fait en prenant les 11 bits de poids faible de chacune des trois premières paires d'octets dans une empreinte Keccak-256 de la série d'octets. Formellement:
\begin{eqnarray}
M_{3:2048}(\mathbf{x}: \mathbf{x} \in \mathbb{B}) & \equiv & \mathbf{y}: \mathbf{y} \in \mathbb{B}_{256} \quad \text{où:}\\
\mathbf{y} & = & (0, 0, ..., 0) \quad \text{excepté:}\\
\forall_{i \in \{0, 2, 4\}}&:& \mathcal{B}_{m(\mathbf{x}, i)}(\mathbf{y}) = 1\\
m(\mathbf{x}, i) &\equiv& \mathtt{\tiny KEC}(\mathbf{x})[i, i + 1] \bmod 2048
\end{eqnarray}

Où $\mathcal{B}$ est la fonction binaire telle que $\mathcal{B}_j(\mathbf{x})$ égale le bit d'index $j$ (indexé depuis 0) dans le tableau d'octets $\mathbf{x}$.

\subsubsection{Validation synergique}

On ne peut assurer la validité d'un bloc que s'il satisfait un certain nombre de conditions: il doit être cohérent avec le ommer et avec les empreintes de transactions du bloc, et les transactions données $B_\mathbf{T}$ (comme spécifié en section \ref{ch:finalisation}), exécutées dans l'ordre sur l'état de base $\boldsymbol{\sigma}$ (dérivé de l'état final du bloc parent), donnent comme résultat un nouvel état de l'identité $H_r$:
\begin{equation}
\begin{array}[t]{lclc}
H_r &\equiv& \mathtt{\small TRIE}(L_S(\Pi(\boldsymbol{\sigma}, B))) & \wedge \\
H_o &\equiv& \mathtt{\small KEC}(\mathtt{\small RLP}(L_H^*(B_\mathbf{U}))) & \wedge \\
H_t &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{T} \rVert, i \in \mathbb{P}: p(i, L_T(B_\mathbf{T}[i]))\}) & \wedge \\
H_e &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{R} \rVert, i \in \mathbb{P}: p(i, L_R(B_\mathbf{R}[i]))\}) & \wedge \\
H_b &\equiv& \bigvee_{\mathbf{r} \in B_\mathbf{R}} \big( \mathbf{r}_b \big)
\end{array}
\end{equation}

où $p(k, v)$ est simplement la paire RLP de l'index de la transaction dans le bloc d'une part, et du récépissé de la transaction d'autre part:
\begin{equation}
p(k, v) \equiv \big( \mathtt{\small RLP}(k), \mathtt{\small RLP}(v) \big)
\end{equation}

En outre:
\begin{equation}
\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma})) = {P(B_H)_H}_r
\end{equation}

Ainsi $\texttt{\small TRIE}(L_S(\boldsymbol{\sigma}))$ est l'empreinte du noeud racine de l'arbre merkle radix contenant les paires clé-valeur de l'état $\boldsymbol{\sigma}$ avec des valeurs encodées par RLP, et $P(B_H)$ est le bloc parent de $B$, défini directement.

Les valeurs provenant du calcul des transactions, spécialement les récépissés de transaction $B_\mathbf{R}$, et ceux définis par la fonction d'aggrégation d'états $\Pi$, sont formalisés plus loin dans la section \ref{sec:statenoncevalidation}.

\subsubsection{Sérialisation}

Les fonctions $L_B$ et $L_H$ Sont les fonctions préparatoires pour un bloc et un en-tête de bloc respectivement. De façon très semblable à la fonction de préparation du récépissé de transaction $L_R$, nous assumons que les types et ordre de la structure pour la transformation RLP sont:
\begin{eqnarray}
\quad L_H(H) & \equiv & (\begin{array}[t]{l}H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d,\\ H_i, H_l, H_g, H_s, H_x, H_m, H_n \; )\end{array} \\
\quad L_B(B) & \equiv & \big( L_H(B_H), L_T^*(B_\mathbf{T}), L_H^*(B_\mathbf{U}) \big)
\end{eqnarray}

Avec $L_T^*$ et $L_H^*$ comme transformations élément par élément de la séquence, ainsi:
\begin{equation}
f^*\big( (x_0, x_1, ...) \big) \equiv \big( f(x_0), f(x_1), ... \big) \quad \text{pour toute fonction} \; f
\end{equation}

Les composants type sont définis ainsi:
\begin{equation}
\begin{array}[t]{lclclcl}
H_p \in \mathbb{B}_{32} & \wedge & H_o \in \mathbb{B}_{32} & \wedge & H_c \in \mathbb{B}_{20} & \wedge \\
H_r \in \mathbb{B}_{32} & \wedge & H_t \in \mathbb{B}_{32} & \wedge & H_e \in \mathbb{B}_{32} & \wedge \\
H_b \in \mathbb{B}_{256} & \wedge & H_d \in \mathbb{P} & \wedge & H_i \in \mathbb{P} & \wedge \\
H_l \in \mathbb{P} & \wedge & H_g \in \mathbb{P} & \wedge & H_s \in \mathbb{P}_{256} & \wedge \\
H_x \in \mathbb{B} & \wedge & H_m \in \mathbb{B}_{32} & \wedge & H_n \in \mathbb{B}_{8}
\end{array}
\end{equation}

où
\begin{equation}
\mathbb{B}_n = \{ B: B \in \mathbb{B} \wedge \lVert B \rVert = n \}
\end{equation}

Nous avons maintenant une spécification rigoureuse pour la construction de la structure formelle d'un bloc. La fonction RLP $\texttt{\small RLP}$ (voir Annexe \ref{app:rlp}) fournit la méthode de référence pour transformer cette structure en une sequence d'octets prêts à la transmission ou au stockage local.

\subsubsection{Validation de l'en-tête de bloc}

On définit $P(B_H)$ comme le bloc parent de $B$, formellement:
\begin{equation}
P(H) \equiv B': \mathtt{\tiny KEC}(\mathtt{\tiny RLP}(B'_H)) = H_p
\end{equation}

Le numéro de bloc est le numéro du bloc parent incrémenté de un:
\begin{equation}
H_i \equiv {{P(H)_H}_i} + 1
\end{equation}

\newcommand{\mindifficulty}{D_0}
\newcommand{\frontiermod}{\ensuremath{\varsigma_1}}
\newcommand{\homesteadmod}{\ensuremath{\varsigma_2}}
\newcommand{\expdiffsymb}{\ensuremath{\epsilon}}
\newcommand{\diffadjustment}{x}

La difficulté de référence d'un bloc d'en-tête $H$ est défini comme $D(H)$:
\begin{equation}
D(H) \equiv \begin{dcases}
\mindifficulty & \text{si} \quad H_i = 0\\
\text{max}\!\left(\mindifficulty, {P(H)_H}_d + \diffadjustment\times\frontiermod + \expdiffsymb \right) & \text{si} \quad H_i<\firsthomesteadblock\\
\text{max}\!\left(\mindifficulty, {P(H)_H}_d + \diffadjustment\times\homesteadmod + \expdiffsymb \right) & \text{sinon}\\
\end{dcases}
\end{equation}
où:
\begin{equation}
\mindifficulty \equiv 131072
\end{equation}
\begin{equation}
\diffadjustment \equiv \left\lfloor\frac{{P(H)_H}_d}{2048}\right\rfloor
\end{equation}
\begin{equation}
\frontiermod \equiv \begin{cases}
1 & \text{si} \quad H_s < {P(H)_H}_s + 13 \\
-1 & \text{sinon} \\
\end{cases}
\end{equation}
\begin{equation}
\homesteadmod \equiv \text{max}\left( 1 - \left\lfloor\frac{H_s - {P(H)_H}_s}{10}\right\rfloor, -99 \right)
\end{equation}
\begin{equation}
\expdiffsymb \equiv \left\lfloor 2^{ \left\lfloor H_i \div 100000 \right\rfloor - 2 } \right\rfloor
\end{equation}

la limite de reférence de gaz $H_l$ d'un bloc d'en-tête $H$ doit être conforme à la relation:
\begin{eqnarray}
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l \geqslant 125000
\end{eqnarray}

$H_s$ est l'horodatage du bloc $H$ et doit être conforme à la relation:
\begin{equation}
H_s > {P(H)_H}_s
\end{equation}

Ce mécanisme renforce une homéostasie pour les intervalles de temps entre les blocs; une période de temps plus petite entre deux blocs entraîne une augmentation du niveau de difficulté et ainsi davantage de calcul, rallongeant d'autant la période suivante. inversement, si la période est trop large, la difficulté, et le temps attendu pour le bloc suivant, est réduit.

Le nonce $H_n$, doit satisfaire aux relations:
\begin{equation}
n \leqslant \frac{2^{256}}{H_d} \quad \wedge \quad m = H_m
\end{equation}
avec $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$.

Où $H_{\hcancel{n}}$ est le nouvel en-tête de bloc $H$, mais \textit{sans} le nonce et le mixhash, $\mathbf{d}$ étant le DAG courant, un grand ensemble de données utilisé pour calculer le mixhash, et $\mathtt{PoW}$ étant la fonction de preuve-de-travail (voir section \ref{ch:pow}): ceci est évalué en un tableau dont le premier item est le mixhash, pour preuve qu'un DAG correct a été utilisé, et le second item est un nombre pseudo-aléatoire cryptographiquement dependant de $H$ et $\mathbf{d}$. Étant donnée une distribution approximativement uniforme sur l'intervalle $[0, 2^{64}]$, le temps estimé pour trouver une solution est proportionnel à la difficulté $H_d$.

Ceci est le fondement de la sécurité de la chaîne de blocs et est la raison fondamentale pour laquelle un code malicieux ne peut pas propager des blocs nouvellement forgés qui pourraient autrement écraser (``réécrire'') l'historique. Parce que le nonce doit satisfaire cette condition, et parce que cette satisfaction dépend du contenu du bloc et des transactions qui le composent, créer de nouveaux blocs valides est difficile et, avec le temps, demande  approximativement la puissance de calcul totale de la partie de confiance parmi les pairs mineurs.

Ainsi on est en mesure de définir la fonction de validation de l'entête de bloc $V(H)$:
\begin{eqnarray}
V(H) & \equiv &  n \leqslant \frac{2^{256}}{H_d} \wedge m = H_m \quad \wedge \\
& & H_d = D(H) \quad \wedge \\
& & H_g \le H_l  \quad \wedge \\
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l \geqslant 125000  \quad \wedge \\
& & H_s > {P(H)_H}_s \quad \wedge \\
& & H_i = {P(H)_H}_i +1 \quad \wedge \\
& & \lVert H_x \rVert \le 32
\end{eqnarray}
où $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$

Notons que \textbf{extraData} doit être au plus de 32 octets.

\section{Gaz et paiement} \label{ch:payment}

Pour éviter d'avoir des problèmes d'abus du réseau et pour contourner les inévitables questions découlant de la complétude au sens de Turing, tout calcul programmable dans Ethereum est sujet à des frais. Le barème des frais est spécifié en unités de \textit{gas} (voir Annexe \ref{app:fees} pour les frais associés avec divers calculs). Ainsi tout fragment donné de calcul programmable (ceci inclut créer des contrats, lancer des messages d'appel, accéder et utiliser les données associées aux comptes, et exécuter des opérations sur la machine virtuelle) a un coût en gaz universellement approuvé.

Toute transaction a un montant spécifique de gaz qui lui est associé: \textbf{gasLimit}. C'est le montant en gaz qui est implicitement prélevé sur le compte de l'expéditeur. L'achat est fait à la valeur de \textbf{gasPrice}, également spécifié dans la transaction. La transaction est considérée comme invalide si le solde du compte ne peut assurer l'achat. Il est nommé \textbf{gasLimit} parce que toute quantité de gaz non utilisée est rendue (au même taux d'achat) au compte de l'expéditeur. Le gaz n'existe pas en dehors de l'exécution d'une transaction. Ainsi pour des comptes avec du code de confiance associé, une limite relativement haute de gaz peut être ainsi réservée.

En général, l'Ether utilisé pour acheter du gaz qui n'est pas rendu est délivré à l'adresse du \textit{bénéficiaire}, adresse typiquement sous le contrôle du mineur. Les contractants sont libres de spécifier tout \textbf{gasPrice} qui leur convienne, cependant les mineurs sont libres d'ignorer les transactions de leur choix. Un prix de gaz plus élevé pour une transaction coûtera davantage d'Ether à son expéditeur et donnera davantage au mineur, et donc elle sera plus aisément sélectionnée pour inclusion par davantage de mineurs. Les mineurs, en général, choisiront d'annoncer le prix du gaz minimum pour lequel ils exécuteront des transactions et les contractants seront libres de marchander ces prix en déterminant quel prix du gaz offrir. Comme il y aura une distribution (pondérée) des minima des prix du gaz, les contractants devront nécessairement marchander entre baisser le prix du gaz et maximiser les chances que leurs transactions seront minées avec rapidité.

%\subsubsection{Determining Computation Costs}

\section{Exécution de transaction} \label{ch:transactions}

L'exécution d'une transaction est la partie la plus complexe du protocole Ethereum: il définit la fonction de transition d'état $\Upsilon$. On suppose que toutes transactions exécutées passent d'abord les tests de validité intrinsèques. Les voici:

\begin{enumerate}
\item La transaction est un RLP bien formé sans octets additionnels à la fin;
\item La signature de transaction est valide;
\item Le nonce de transaction est valide (équivalent au nonce courant du compte de l'expéditeur);
\item La limite de gaz n'est pas plus petite que le gaz intrinsèque, $g_0$, utilisé par la transaction;
\item Le solde du compte de l'expéditeur contient au moins le coût, $v_0$, demandé comme paiement de départ.
\end{enumerate}

Formellement, nous considérons la fonction $\Upsilon$, $T$ étant une transaction et $\boldsymbol{\sigma}$ l'état:
\begin{equation}
\boldsymbol{\sigma}' = \Upsilon(\boldsymbol{\sigma}, T)
\end{equation}

$\boldsymbol{\sigma}'$ est donc l'état post-transactionnel. Nous définissons également $\Upsilon^g$ pour évaluer le montant de gaz utilisé dans l'exécution d'une transaction et $\Upsilon^\mathbf{l}$ pour évaluer les items de logs ajoutés, les deux étant formellement définis plus loin.

\subsection{Sous-état}
Pendant l'exécution d'une transaction, nous voyons s'accroître certaines informations sur lesquelles on agit immédiatement à la suite de la transaction. Nous appelons ceci \textit{sous-état de transaction} et le représentons par $A$, qui est un tuple:
\begin{equation}
A \equiv (A_\mathbf{s}, A_\mathbf{l}, A_r)
\end{equation}

Le contenu du tuple comprend $A_\mathbf{s}$, l'ensemble de suicide: un ensemble de comptes qui sera mis au rebut après la fin de la transaction. $A_\mathbf{l}$ est la série de logs: il s'agit d'une série de `points de contrôles' dans l'exécution du code de la VM qui permet de facilement tracer les appels de contrats par des observateurs extérieurs au monde Ethereum (comme des frontaux d'applications décentralisées). Enfin, il y a $A_r$, le solde de remboursement, accru par l'utilisation de l'instruction {\small SSTORE} afin de remettre la mémoire de stockage à zéro à partir d'une valeur différente de zéro. Bien qu'il ne soit pas immédiatement remboursé, il lui est permis de compenser partiellement les coûts totaux d'exécution.

Dans un souci de concision, nous définissons le sous-état vide $A^0$ comme n'ayant pas de suicide, pas de logs et un solde de remboursement à zéro:
\begin{equation}
A^0 \equiv (\varnothing, (), 0)
\end{equation}

\subsection{Exécution}
Nous définissons le gaz $g_0$, le montant de gaz que cette transaction demande pour être payée avant exécution, comme suit:
\begin{align}
g_0 \equiv {} & \sum_{i \in T_\mathbf{i}, T_\mathbf{d}} \begin{cases} G_{txdatazero} & \text{si} \quad i = 0 \\ G_{txdatanonzero} & \text{sinon} \end{cases} \\
{} & + \begin{cases} G_\text{txcreate} & \text{si} \quad T_t = \varnothing \wedge H_i \geq \firsthomesteadblock \\ 0 & \text{sinon} \end{cases} \\
{} & + G_{transaction}
\end{align}

où $T_\mathbf{i},T_\mathbf{d}$ signifie la série d'octets des données et du code EVM associés à la transaction, selon que la transaction sert à une création de contrat ou un a un appel de message. $G_\text{txcreate}$ est ajouté si la transaction crée un message mais ce n'est pas le cas s'il s'agit d'un résultat de code EVM ou avant la {\it transition Homestead}. $G$ est totalement défini à l'Annexe  \ref{app:fees}.

%todo Explain g_d reason?

Le coût de départ $v_0$ est calculé par:
\begin{equation}
v_0 \equiv T_g T_p + T_v
\end{equation}

La validité est déterminée comme:
\begin{equation}
\begin{array}[t]{rcl}
S(T) & \neq & \varnothing \quad \wedge \\
\boldsymbol{\sigma}[S(T)] & \neq & \varnothing \quad \wedge \\
T_n & = & \boldsymbol{\sigma}[S(T)]_n \quad \wedge \\
g_0 & \leqslant & T_g \quad \wedge \\
v_0 & \leqslant & \boldsymbol{\sigma}[S(T)]_b \quad \wedge \\
T_g & \leqslant & {B_H}_l - \ell(B_\mathbf{R})_u
\end{array}
\end{equation}

On note la condition finale: la somme de la limite en gaz de la transaction, $T_g$, et le gaz auparavant utilisé dans ce bloc, donné par $\ell(B_\mathbf{R})_u$, ne doit pas être plus grand que la \textbf{gasLimit}, ${B_H}_l$ du bloc.

L'exécution d'une transaction valide commence par un changement irrévocable de l'état: le nonce du compte de l'expéditeur, $S(T)$, est incrémenté et le solde est réduit par une partie du coût de départ, $T_gT_p$. Le gaz disponible pour le calcul en cours, $g$, est défini par $T_g - g_0$. Le calcul, qu'il s'agisse d'une création de contrat ou d'un appel de message, donne un état final (qui peut être légalement équivalent à l'état courant), dont le changement est déterministe et jamais invalide: il ne peut y avoir de transaction invalide à partir de ce point.

Nous définissons l'état au point de contrôle $\boldsymbol{\sigma}_0$:
\begin{eqnarray}
\boldsymbol{\sigma}_0 & \equiv & \boldsymbol{\sigma} \quad \text{except\,:} \\
\boldsymbol{\sigma}_0[S(T)]_b & \equiv & \boldsymbol{\sigma}[S(T)]_b - T_g T_p \\
\boldsymbol{\sigma}_0[S(T)]_n & \equiv & \boldsymbol{\sigma}[S(T)]_n + 1
\end{eqnarray}

L'évaluation de $\boldsymbol{\sigma}_P$ à partir de $\boldsymbol{\sigma}_0$ dépend du type de la transaction, création de contrat ou appel de message; nous définissons le tuple: état provisionnel de post-exécution $\boldsymbol{\sigma}_P$, gaz restant $g'$ et sous-état $A$:
\begin{equation}
(\boldsymbol{\sigma}_P, g', A) \equiv \begin{cases}
\Lambda(\boldsymbol{\sigma}_0, S(T), T_o, &\\ \quad\quad g, T_p, T_v, T_\mathbf{i}, 0) & \text{si} \quad T_t = \varnothing \\
\Theta_{3}(\boldsymbol{\sigma}_0, S(T), T_o, &\\ \quad\quad T_t, T_t, g, T_p, T_v, T_v, T_\mathbf{d}, 0) & \text{sinon}
\end{cases}
\end{equation}

où $g$ est le montant de gaz restant après avoir déduit le montant de base demandé pour payer pour l'existence de la transaction:
\begin{equation}
g \equiv T_g - g_0
\end{equation}
et $T_o$ est l'auteur originel de la transaction, qui peut différer de l'expéditeur dans le cas d'un appel de message ou d'une crréation de contact qui n'a pas été directement déclenché par une transaction mais qui vient de l'exécution de code EVM.

On remarque que nous utilisons $\Theta_{3}$ pour noter le fait que seuls les trois premiers composants de la valeur de la fonction sont pris; le composant final représente la valeur de sortie d'un appel de message (un tableau d'octets) et est inutilisé dans le contexte de l'évaluation d'une transaction.

Après le traitement de l'appel de message ou de la création de contrat, l'état est finalisé en déterminant le montant à rembourser, $g^*$, du gaz restant, $g'$, plus un certain montant du compteur de remboursement, à l'expéditeur du taux d'origine.
\begin{equation}
g^* \equiv g' + \min \{ \Big\lfloor \dfrac{T_g - g'}{2} \Big\rfloor, A_r \}
\end{equation}

Le montant total à rembourser est le gaz légitimement restant $g'$, ajouté à $A_r$, ce dernier composant étant limité à un maximum de la moitié (tronquée) du montant total utilisé $T_g - g'$.

L'Ether du gaz est donné au mineur dont l'adresse est spécifiée comme bénéficiaire du bloc présent $B$. Nous définissons donc l'état pré-final $\boldsymbol{\sigma}^*$ en termes d'état provisionnel  $\boldsymbol{\sigma}_P$:
\begin{eqnarray}
\boldsymbol{\sigma}^* & \equiv & \boldsymbol{\sigma}_P \quad \text{except} \\
\boldsymbol{\sigma}^*[S(T)]_b & \equiv & \boldsymbol{\sigma}_P[S(T)]_b + g^* T_p \\
\boldsymbol{\sigma}^*[m]_b & \equiv & \boldsymbol{\sigma}_P[m]_b + (T_g - g^*) T_p \\
m & \equiv & {B_H}_c
\end{eqnarray}

L'état final, $\boldsymbol{\sigma}'$, est atteint après la suppression de tous les comptes qui apparaissent dans la liste de suicide:
\begin{eqnarray}
\boldsymbol{\sigma}' & \equiv & \boldsymbol{\sigma}^* \quad \text{except} \\
\forall i \in A_\mathbf{s}: \boldsymbol{\sigma}'[i] & \equiv & \varnothing
\end{eqnarray}

Et finalement, nous spécifions $\Upsilon^g$, le gaz total utilisé dans cette transaction et $\Upsilon^\mathbf{l}$, les logs créés par cette transaction:
\begin{eqnarray}
\Upsilon^g(\boldsymbol{\sigma}, T) & \equiv & T_g - g' \\
\Upsilon^\mathbf{l}(\boldsymbol{\sigma}, T) & \equiv & A_\mathbf{l}
\end{eqnarray}

Ils sont utilisés pour aider à définir le reçu de la transaction qui sera détaillé plus bas.

%In the case that $s = m$ then we simply return the Ether back to the sender/miner, collapsing the exception into:
%\begin{eqnarray}
%\boldsymbol{\sigma}'[s]_b & \equiv & \boldsymbol{\sigma}_P[s]_b + g
%\end{eqnarray}

\section{Création de contrat} \label{ch:create}

Il existe un certain nombre de paramètres intrinsèques utilisés quand on crée un compte: expéditeur ($s$), \textbf{\textit{transactor}} originel ($o$), prix du gaz ($p$), dotation ($v$) assemblés avec un tableau d'octets de longueur variable, $\mathbf{i}$, le code EVM d'initialisation et enfin la profondeur actuelle de la pile d'appel de message/création de contrat ($e$)

Nous définissons formellement la fonction de création comme la fonction $\Lambda$ qui évalue, à partir de ces valeurs et de l'état $\boldsymbol{\sigma}$, le tuple contenant le nouvel état, le gaz restant et le substrat de transaction augmenté $(\boldsymbol{\sigma}', g', A)$, comme en section  \ref{ch:transactions}:
\begin{equation}
(\boldsymbol{\sigma}', g', A) \equiv \Lambda(\boldsymbol{\sigma}, s, o, g, p, v, \mathbf{i}, e)
\end{equation}

L'adresse du nouveau compte est défini comme étant les 160 bits de droite de l'empreinte Keccak de l'encodage RLP de la structure ne contenant que l'expéditeur et le nonce. Nous définissons donc l'adresse résultante pour le nouveau compte $a$:
\begin{equation}
a \equiv \mathcal{B}_{96..255}\Big(\mathtt{\tiny KEC}\Big(\mathtt{\tiny RLP}\big(\;(s, \boldsymbol{\sigma}[s]_n - 1)\;\big)\Big)\Big)
\end{equation}

où $\mathtt{\tiny KEC}$ est la fonction de hachage Keccak sur 256 bits, $\mathtt{\tiny RLP}$ est la fonction d'encodage RLP, $\mathcal{B}_{a..b}(X)$ donne une valeur binaire contenant les bits des indices dans l'intervalle $[a, b]$ des données binaires $X$ et $\boldsymbol{\sigma}[x]$ est l'état de l'adresse de $x$ ou $\varnothing$ si aucun n'existe. Notons que nous utilisons un de moins que la valeur du nonce de l'expéditeur; nous alléguons que nous avons incrémenté le nonce du compte de l'expéditeur avant cet appel et la valeur utilisée est donc celle du début de la transaction ou de l'opération de VM responsable.

Le nonce du compte est initialement défini à zéro, le solde à la valeur passée, la mémoire de stockage à vide et l'empreinte du code à l'empreinte Keccak sur 256 bits de la chaîne vide; la valeur passée est également défalquée du solde de l'expéditeur. Donc, l'état modifié devient $\boldsymbol{\sigma}^*$:
\begin{equation}
\boldsymbol{\sigma}^* \equiv \boldsymbol{\sigma} \quad \text{except:}
\end{equation}
\begin{eqnarray}
\boldsymbol{\sigma}^*[a] &\equiv& \big( 0, v + v', \mathtt{\tiny TRIE}(\varnothing), \mathtt{\tiny KEC}\big(()\big) \big) \\
\boldsymbol{\sigma}^*[s]_b &\equiv& \boldsymbol{\sigma}[s]_b - v
\end{eqnarray}

où $v'$ est la valeur préexistante du compte le cas échéant:
\begin{equation}
v' \equiv \begin{cases}
0 & \text{si} \quad \boldsymbol{\sigma}[a] = \varnothing\\
\boldsymbol{\sigma}[a]_b & \text{sinon}
\end{cases}
\end{equation}

%It is asserted that the state database will also change such that it defines the pair $(\mathtt{\tiny KEC}(\mathbf{b}), \mathbf{b})$.

Enfin, le compte est initialisé par l'exécution du code EVM d'initialisation $\mathbf{i}$ d'après le modèle d'exécution (voir la section \ref{ch:model}). L'exécution du code peut engendre plusieurs événements qui ne sont pas internes à l'état d'exécution: la mémoire de stockage peut être altérée, des comptes supplémentaires peuvent être créé et d'autres appels de message peuvent être lancés. En tant que telle, la fonction d'exécution de code $\Xi$ donne un tuple de l'état résultant $\boldsymbol{\sigma}^{**}$, du gaz disponible restant $g^{**}$, du substrat accru $A$ et du code du corps du compte $\mathbf{o}$.

\begin{equation}
(\boldsymbol{\sigma}^{**}, g^{**}, A, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}^*, g, I) \\
\end{equation}
où $I$ contient les paramètres de l'environnement d'exécution tels que définis en section \ref{ch:model}, c'est-à-dire:
\begin{eqnarray}
I_a & \equiv & a \\
I_o & \equiv & o \\
I_p & \equiv & p \\
I_\mathbf{d} & \equiv & () \\
I_s & \equiv & s \\
I_v & \equiv & v \\
I_\mathbf{b} & \equiv & \mathbf{i} \\
I_e & \equiv & e
\end{eqnarray}

$I_\mathbf{d}$ donne le tuple vide puisqu'il n'y a pas de données en entrée de cet appel. $I_H$ n'a pas de traitement spécial et est déterminé à partir de la blockchain.

L'exécution du code diminue le gaz, lequel ne peut pas descendre en-dessous de zéro, donc l'exécution peut sortir avant que le code ne soit arrivé à un état d'arrêt. Dans ces cas exceptionnel (et dans plusieurs autres), nous disons qu'une exception \textit{Out-of-Gas} (panne d'essence) s'est produite: l'état évalué est défini comme étant l'ensemble vide, $\varnothing$, et l'opération de création dans son intégralité ne doit avoir aucun effet sur l'état, le laissant dans les faits tel qu'il était immédiatement avant la tentative de création.

Si le code d'initialisation se termine avec succès, un coût final de création de contrat est payé, le coût de dépôt du code, $c$, étant proportionnel à la taille du code du contrat créé:
\begin{equation}
c \equiv G_{codedeposit} \times |\mathbf{o}|
\end{equation}

S'il n'y a pas assez de gaz restant pour payer ceci, c'est-à-dire $g^{**} < c$, alors nous déclarons également une exception Out-of-Gas.

Le gaz restant sera à zéro dans ces circonstances exceptionnelles, c'est-à-dire que si la création a été conduite à la réception d'une transaction, alors cela n'affecte pas le paiement du coût intrinsèque de la création du contrat; celui-ci est payé de toute manière. Cependant, la valeur de la transaction n'est pas transférée à l'adresse du contrat avorté quand nous somme Out-of-Gas.

Si ce type d'exception ne se produit pas, alors le gaz restant est renvoyé à l'\textbf{\textit{originator}} et l'état maintenant altéré a le droit de persister. Nous pouvons donc formellement spécifier l'état, le gaz et le sous-état résultants par $(\boldsymbol{\sigma}', g', A)$ où:

\begin{align}
\quad g' &\equiv \begin{cases}
0 & \text{si} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
g^{**} & \text{si} \quad g^{**}<c \wedge H_i<\firsthomesteadblock \\
g^{**} - c & \text{sinon} \\
\end{cases} \\
\quad \boldsymbol{\sigma}' &\equiv  \begin{cases}
\boldsymbol{\sigma} & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} & \text{if} \quad g^{**}<c \wedge H_i<\firsthomesteadblock \\
\boldsymbol{\sigma}^{**} \quad \text{except:} & \\
\quad\boldsymbol{\sigma}'[a]_c = \texttt{\small KEC}(\mathbf{o}) & \text{sinon}
\end{cases}
\end{align}

L'exception dans la détermination de $\boldsymbol{\sigma}'$ dicte que $\mathbf{o}$, la séquence d'octets résultant de l'exécution du code d'initialisation, spécifie le code final du corps du compte nouvellement créé.

On remarque que l'intention à partir du bloc \firsthomesteadblock\  ({\it Homestead}) est que le résultat est soit un nouveau contrat créé avec succès avec sa dotation, soit aucun contrat et aucun transfert de valeur. Avant {\it Homestead}, s'il n'y avait pas assez de gaz pour payer $c$, un compte était créé à l'adresse du nouveau contrat, en même temps que tous les effets secondaires de l'initialisation, et la valeur était transférée mais aucun code de contrat n'était déployé.

\subsection{Subtilités}
Notons qu'alors que le code d'initialisation est en train de s'exécuter, l'adresse nouvellement crééee existe mais sans code de corps intrinsèque. Un appel de message qu'il reçoit pendant ce temps n'engendre donc aucune exécution de code. Si l'exécution de l'initialisation se termine par une instruction {\small SUICIDE}, cela importe peu puisque le compte est supprimé avant la fin de la transaction. Pour un code {\small STOP}, ou si le code renvoyé est vide, alors l'état reste avec un compte zombie et tout solde résiduel reste à jamais verrouillé dans ce compte.

\section{Appel de message} \label{ch:call}
Lors de l'exécution d'un appel de message, plusieurs paramètres sont requis: émetteur ($s$), créateur de la transaction ($o$), récepteur ($r$), le compte dont le code doit être exécuté ($c$, habituellement le même que le récepteur), le gaz disponible ($g$), valeur ($v$) et prix du gaz ($p$) ensemble avec un tableau d'octets de longueur arbitraire, $\mathbf{d}$, les données d'entrée de l'appel de message et finalement la hauteur actuelle de la pile du appel de message ou de la création de contrat ($e$).

À part l'évaluation de nouveaux états et de leurs sous-états, un appel de message a aussi un autre composant---les données de sortie désignées par le tableau d'octets $\mathbf{o}$. Il est ignoré durant les exécutions de transactions, cependant les appels de message peuvent être lancés par l'exécution de code dans la VM et dans ce cas cette information est utilisée.
\begin{equation}
(\boldsymbol{\sigma}', g', A, \mathbf{o}) \equiv \Theta(\boldsymbol{\sigma}, s, o, r, c, g, p, v, \tilde{v}, \mathbf{d}, e)
\end{equation}
Notons que nous devons différencier la valeur qui doit être transférée $v$, de la valeur apparente dans le contexte d'execution $\tilde{v}$, pour l'instruction {\small DELEGATECALL}.

On définit $\boldsymbol{\sigma}_1$, le premier état de transition comme l'état original mais avec la valeur transférée de l'émetteur au récepteur:
\begin{equation}
\boldsymbol{\sigma}_1[r]_b \equiv \boldsymbol{\sigma}[r]_b + v \quad\wedge\quad \boldsymbol{\sigma}_1[s]_b \equiv \boldsymbol{\sigma}[s]_b - v
\end{equation}

Au long du présent travail, il est admis que $\boldsymbol{\sigma}_1[r]$ était indéfini à l'origine, il va être créé comme un compte sans code ou état et avec zéro solde ou nonce. ainsi la précédente équation doit être interprétée comme suit:
\begin{equation}
\boldsymbol{\sigma}_1 \equiv \boldsymbol{\sigma}_1' \quad \text{except:} \\
\end{equation}
\begin{equation}
\boldsymbol{\sigma}_1[s]_b \equiv \boldsymbol{\sigma}_1'[s]_b - v
\end{equation}
\begin{equation}
\text{and}\quad \boldsymbol{\sigma}_1' \equiv \boldsymbol{\sigma} \quad \text{except:} \\
\end{equation}
\begin{equation}
\begin{cases}
\boldsymbol{\sigma}_1'[r] \equiv (v, 0, \mathtt{\tiny KEC}(()), \mathtt{\tiny TRIE}(\varnothing)) & \text{if} \quad \boldsymbol{\sigma}[r] = \varnothing \\
\boldsymbol{\sigma}_1'[r]_b \equiv \boldsymbol{\sigma}[r]_b + v & \text{otherwise}
\end{cases}
\end{equation}

Le code associé au compte (identifié comme le fragment dont l'empreinte Keccack $\boldsymbol{\sigma}[c]_c$) est exécuté conformément au modèle d'exécution (voir section \ref{ch:model}). Comme avec la création de contrat, si l'exécution cesse pour cause d'anomalie (i.e. à cause de l'épuisement de la fourniture en gaz, épuisement de la pile, saut invalide ou instruction invalide), alors l'appelant n'est pas remboursé et l'état est remis au point immédiatement avant le transfert de solde (i.e. $\boldsymbol{\sigma}$).

\begin{eqnarray}
\boldsymbol{\sigma}' & \equiv & \begin{cases}
\boldsymbol{\sigma} & \text{if} \quad \boldsymbol{\sigma}^{**} = \varnothing \\
\boldsymbol{\sigma}^{**} & \text{otherwise}
\end{cases} \\
(\boldsymbol{\sigma}^{**}, g', \mathbf{s}, \mathbf{o}) & \equiv & \begin{cases}
\Xi_{\mathtt{ECREC}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 1 \\
\Xi_{\mathtt{SHA256}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 2 \\
\Xi_{\mathtt{RIP160}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 3 \\
\Xi_{\mathtt{ID}}(\boldsymbol{\sigma}_1, g, I) & \text{if} \quad r = 4 \\
\Xi(\boldsymbol{\sigma}_1, g, I) & \text{otherwise} \end{cases} \\
I_a & \equiv & r \\
I_o & \equiv & o \\
I_p & \equiv & p \\
I_\mathbf{d} & \equiv & \mathbf{d} \\
I_s & \equiv & s \\
I_v & \equiv & \tilde{v} \\
I_e & \equiv & e \\
\text{Let} \; \mathtt{\tiny KEC}(I_\mathbf{b}) & = & \boldsymbol{\sigma}[c]_c
\end{eqnarray}

On suppose que le client aura stocké la paire $(\mathtt{\tiny KEC}(I_\mathbf{b}), I_\mathbf{b})$ préalablement pour pouvoir déterminer $I_\mathbf{b}$.

Comme on pourra voir, il y a quatre exceptions au framework général d'exécution $\Xi$ lors de l'évaluation d'un appel de message: ce sont les quatre contrats `précompilés', compris comme des éléments d'architecture préliminaires qui pourront ultérieurement devenir des \textit{extensions natives}. Les quatre contrats aux adresses 1, 2, 3 et 4 executent la fonction de récupération de la clé publique de courbe elliptique, le schema d'empreinte SHA2 256-bit, le schema d'empreinte RIPEMD 160-bit et la fonction d'identité respectivement.

Leur définition formelle complète est dans l'Annexe \ref{app:precompiled}.

\section{Modèle d'exécution} \label{ch:model}

Le modèle d'exécution spécifie la façon dont l'état du système est altéré étant donné une série d'instructions de bytecode et un petit tuple de données environnementales. On le spécifie par un modèle formel d'une machine à état nommée Ethereum Virtual Machine (EVM). Il s'agit d'une machine de Turing quasi-complète; la qualification de \textit{quasi} vient de ce que le traitement est intrinsèquement borné par un paramètre, \textit{gas} (gaz), qui limite le traitement total effectué.

\subsection{Fondamentaux}

L'EVM est une architecture simple basée sur une pile. La taille des mots de la machine (et donc la taille de l'élément de la pile) est de 256 bits. Ce choix est destiné à faciliter le mécanisme d'empreinte Keccak-256 et les calculs de courbes elliptiques. Le modèle mémoire est un simple tableau d'octets adressé par mots. La pile a une taille maximale de $1024$. La machine comporte également un modèle de stockage indépendant, conceptuellement similaire à celui de la mémoire mais, au lieu d'un tableau d'octets, il s'agit d'un tableau de mots adressé par mots. Au contraire de la mémoire, qui est volatile, le stockage est non volatil et est maintenu comme partie de l'état système. Tous les emplacements tant en stockage qu'en mémoire sont définis à zéro à l'initialisation.

La machine n'est pas conçue selon l'architecture standard de Von Neumann. Au lieu de stocker le code des programmes dans une mémoire transitoire ou permanente générique, il est mis à part dans une ROM virtuelle avec laquelle seule une instruction spécialisée peut interagir.

La machine peut entrer dans une exécution exceptionnelles pour plusieurs raisons, comme un dépassement de dépilage et des instructions invalides. Comme l'exception \textit{out-of-gas} (OOG), elles ne laissent pas les changements d'état intacts. La machine s'arrête immédiatement et rapporte le problème à l'agent d'exécution (soit le processeur de transactions, soit, récursivement, l'environnement d'exécution du lancement) qui le gèrera de son côté.

\subsection{Aperçu des frais}

Les \textit{fees} (frais), chiffrés en gaz, sont décomptés en trois circonstances distinctes, toutes trois étant des prérequis à l'exécution d'une opération. D'abord et le plus fréquemment, les frais intrinsèques au calcul de l'opération (voir Appendice \ref{app:fees}). Ensuite le gaz peut être déduit afin de constituer le paiement d'un appel de message ou d'une création de contrat subordonné; cela fait partie du paiement de {\small CREATE}, {\small CALL} et {\small CALLCODE}. Enfin, le gaz peut être payé en raison de l'augmentation de l'utilisation de la mémoire.

Pendant l'exécution d'un compte,
% l'exécution appartement à un compte ?
les frais totaux dûs pour l'utilisation de la mémoire sont proportionnels au plus petit multiple de 32 octets qui est requis tel que tous les index mémoire (en lecture ou en écriture) sont inclus dans l'intervalle. Le paiement se fait en juste-à-temps; le référencement d'une zone de mémoire plus grande d'au moins 32 octets que la mémoire précédemment référencée résulte avec certitude en des frais d'utilisation mémoire supplémentaires. Ces frais rendent extrêmement improbable un adressage dépassant la limite de 32 bits. Cela dit, les implémentations doivent être capables de gérer cette éventualité.

Les frais de stockage se comportent de manière légèrement différente. Pour inciter à minimiser l'utilisation du stockage (qui correspond directement à une base de données d'état plus grande sur tous les n\oe{}uds, les frais d'exécution d'une opération supprimant une entrée dans le stockage ne sont pas seulement abandonnés mais un remboursement explicite est effectué; dans les faits, ce remboursement est payé immédiatement puisque l'utilisation initiale d'un emplacement mémoire coûte bien plus qu'une utilisation courante.

%More formally, given an instruction, it is possible to calculate the gas cost of executing it as follows:
%
%\begin{itemize}
%\item {\small SHA3} costs $G_{sha3}$ gas
%\item {\small SLOAD} costs $G_{sload}$ gas
%\item {\small BALANCE} costs $G_{balance}$ gas
%\item {\small SSTORE} costs $d.G_{sstore}$ gas where:
%\begin{itemize}
%\item $d = 2$ if the new value of the storage is non-zero and the old is zero;
%\item $d = 0$ if the new value of the storage is zero and the old is non-zero;
%\item $d = 1$ otherwise.
%\end{itemize}
%\item {\small CALL} costs $G_{call}$, though additional gas may be taken for the execution of the account's associated code, if non-empty.
%\item {\small CREATE} costs $G_{create}$, though additional gas may be taken for the execution of the account initialisation code.
%\item {\small STOP} costs $G_{stop}$ gas
%\item {\small SUICIDE} costs $G_{suicide}$ gas
%\item All other operations cost $G_{step}$ gas.
%\end{itemize}
%
%Additionally, when memory is accessed with {\small MSTORE}, {\small MSTORE8}, {\small MLOAD}, {\small CALLDATACOPY}, {\small CODECOPY}, {\small RETURN}, {\small SHA3}, {\small CREATE} or {\small CALL}, the memory should be enlarged to the smallest multiple of words such that all addressed bytes now fit in it.

Voir l'appendice \ref{app:vm} pour une définition rigoureuse du coût en gaz de l'EVM.

%Whenever a higher memory index is referenced, the fee difference to take it to the higher usage from the original (lower) usage is charged. Notably, because {\small MSTORE} and {\small MLOAD} operate on word lengths, they implicitly increase the highest-accessed index to 31 greater than their target index.

\subsection{Environnement d'exécution}

En plus de l'état du système $\boldsymbol{\sigma}$ et du gaz restant pour le traitement $g$, l'agent d'exécution doit fournir plusieurs informations importantes utilisées dans l'environnement d'exécution, qui sont contenues dans le tuple $I$:

\begin{itemize}
\item $I_a$, l'adresse du compte qui possède le code en cours d'exécution.
\item $I_o$, l'adresse de l'expéditeur de la transaction d'où provient cette exécution.
\item $I_p$, le prix du gaz dans la transaction d'où provient cette exécution.
\item $I_\mathbf{d}$, le tableau d'octets qui constitue les données d'entrée pour cette exécution; si l'agent d'exécution est une transaction, il s'agit des données de transaction.
\item $I_s$, l'adresse du compte qui a provoqué l'exécution du code; si l'agent d'exécution est une transaction, il s'agit de l'expéditeur de la transaction.
\item $I_v$, la valeur, en Wei, passée à ce compte comme faisant partie de la même procédure que l'exécution; si l'agent d'exécution est une transaction, c'est la valeur de la transaction.
\item $I_\mathbf{b}$, le tableau d'octets qui est le code machine à exécuter.
\item $I_H$, l'en-tête de bloc du bloc actuel.
\item $I_e$, la profondeur de l'appel de message actuel ou de la création de contrat actuelle (c.à.d. le nombre de {\small CALL} ou de {\small CREATE} exécutés à ce moment).
\end{itemize}

Le modèle d'exécution définit la fonction $\Xi$, qui peut calculer l'état résultant $\boldsymbol{\sigma}'$, le gaz restant $g'$, la liste de suicide $\mathbf{s}$, la série de logs $\mathbf{l}$, les remboursements $r$ et la sortie résultante, $\mathbf{o}$, étant données ces définitions:
\begin{equation}
(\boldsymbol{\sigma}', g', \mathbf{s}, \mathbf{l}, r, \mathbf{o}) \equiv \Xi(\boldsymbol{\sigma}, g, I)
\end{equation}

\subsection{Aperçu de l'exécution}

Nous devons maintenant définir la fonction $\Xi$. Dans la plupart des implémentations concrètes, elle sera conçue comme une progression itérative de la paire comprenant l'état complet du système, $\boldsymbol{\sigma}$ et de l'état de la machine,  $\boldsymbol{\mu}$. Formellement, nous la définissons récursivement avec une fonction $X$, qui utilise une fonction itératrice $O$ (qui définit le résultat d'un cycle unique de la machine à état) avec les fonctions $Z$, qui détermine si l'état actuel est un état d'arrêt exceptionnel de la machine, et $H$, spécifiant les données de sortie de l'instruction si et seulement si l'état actuel est un état d'arrêt normal de la machine.

La séquence vide, notée $()$, n'est pas égale à l'ensemble vide, noté $\varnothing$; c'est important au moment d'interpréter la sortie de $H$, qui donne $\varnothing$ quand l'exécution doit continuer mais une série (potentiellement vide) quand l'exécution doit s'arrêter.
\begin{eqnarray}
\Xi(\boldsymbol{\sigma}, g, I) & \equiv & X_{0,1,2,4}\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A^0, I)\big) \\
\boldsymbol{\mu}_g & \equiv & g \\
\boldsymbol{\mu}_{pc} & \equiv & 0 \\
\boldsymbol{\mu}_\mathbf{m} & \equiv & (0, 0, ...) \\
\boldsymbol{\mu}_i & \equiv & 0 \\
\boldsymbol{\mu}_\mathbf{s} & \equiv & ()
\end{eqnarray}
\begin{equation}
X\big( (\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \big) \equiv \begin{cases}
\big(\varnothing, \boldsymbol{\mu}, A^0, I, ()\big) & \text{si} \quad Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I)\\
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \cdot \mathbf{o} & \text{si} \quad \mathbf{o} \neq \varnothing\\
X\big(O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) & \text{sinon}\\
\end{cases}
\end{equation}

où
\begin{eqnarray}
\mathbf{o} & \equiv & H(\boldsymbol{\mu}, I) \\
(a, b, c) \cdot d & \equiv & (a, b, c, d)
\end{eqnarray}

On remarque que nous devons omettre la quatrième value du tuple renvoyé par $X$ pour évaluer correctement $\Xi$, d'où la notation $X_{0,1,2,4}$.

On cycle donc dans $X$ (ici, récursivement, mais on s'attend généralement à ce que les implémentations emploient une simple boucle itérative) jusqu'à ce que soit $Z$ devienne vrai, indiquant ainsi que l'état actuel est exceptionnel et que la machine doit être arrêtée en revenant sur toutes les modifications, ou jusqu'à ce que $H$ devienne une série (au lieu de l'ensemble vide) indiquant que la machine a atteint un arrêt contrôlé.

\subsubsection{État de la machine}
L'état de la machine $\boldsymbol{\mu}$ est défini par le tuple $(g, pc, \mathbf{m}, i, \mathbf{s})$ qui sont le gaz disponible, le compteur de programme $pc \in \mathbb{P}_{256}$, le contenu de la mémoire, le nombre de mots actifs en mémoire (en comptant en continu depuis la position 0) et le contenu de la pile. Le contenu de la mémoire $\boldsymbol{\mu}_\mathbf{m}$ est une série de zéros de taille $2^{256}$.

Dans un but de lisibilité, les mnémoniques d'instructions, écrites en petites capitales (comme {\small ADD}), doivent être interprétées comme leurs équivalents numériques; la table complète des instructions et de leurs spécificités est donnée à l'Appendice \ref{app:vm}.

Dans le but de définir $Z$, $H$ et $O$, nous définissons $x$ comme l'opération actuelle à exécuter:
\begin{equation}\label{eq:currentoperation}
w \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_{pc}] & \text{si} \quad \boldsymbol{\mu}_{pc} < \lVert I_\mathbf{b} \rVert \\
\text{\small STOP} & \text{sinon}
\end{cases}
\end{equation}

Nous supposons également les montants fixes de $\mathbf{\delta}$ et $\mathbf{\alpha}$, en spécifiant les éléments de la pile qui ont été supprimés et ajoutés, les deux étant \textit{subscriptables} sur l'instruction et une fonction de coût d'instruction $C$ qui donne le coût total, en gaz, de l'exécution de l'instruction donnée.
%We also assume the fixed amounts of $\mathbf{\delta}$ and $\mathbf{\alpha}$, specifying the stack items removed and added, both subscriptable on the instruction and an instruction cost function $C$ evaluating to the full cost, in gas, of executing the given instruction.

\subsubsection{Arrêt exceptionnel}

La fonction d'arrêt exceptionnel $Z$ est définie par:
\begin{equation}
Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \equiv
\begin{array}[t]{l}
\boldsymbol{\mu}_g < C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \quad \vee \\
\mathbf{\delta}_w = \varnothing \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert < \mathbf{\delta}_w \quad \vee \\
( w \in \{ \text{\small JUMP}, \text{\small JUMPI} \} \quad \wedge \\ \quad \boldsymbol{\mu}_\mathbf{s}[0] \notin D(I_\mathbf{b}) ) \quad \vee \\
\lVert\boldsymbol{\mu}_\mathbf{s}\rVert - \mathbf{\delta}_w + \mathbf{\alpha}_w > 1024 \quad
\end{array}
\end{equation}

Cela établit que l'éxécution se trouve dans un état d'arrêt exceptionnel s'il n'y a pas assez de gaz, si l'instruction est invalide (et donc son \textit{subscript} est indéfini), s'il n'y a pas suffisamment d'éléments de pile, si une destination de {\small JUMP}/{\small JUMPI} est invalide ou si la nouvelle taille de la pile serait supérieure à 1024. Le lecteur attentif aura compris que cela signifie également qu'aucune instruction ne peut, par son exécution, provoquer un arrêt exceptionnel.

\subsubsection{Validité d'une destination de saut}

Nous avons auparavant utilisé $D$ comme fonction pour déterminer l'ensemble des destinations de saut valides étant donné le code en train de tourner. Nous définission ceci comme toute position dans le code occupée par une instruction {\small JUMPDEST}.

Toutes ces positions doivent se trouver sur des limites d'instruction valides au lieu d'occuper la partie de données des opération {\small PUSH} et doivent apparaître dans la portion explicitement définie du code (et non dans les opérations {\small STOP} implicitement définies qui les suivent).

Formellement:
\begin{equation}
D(\mathbf{c}) \equiv D_J(\mathbf{c}, 0)
\end{equation}

où:
\begin{equation}
D_J(\mathbf{c}, i) \equiv \begin{cases}
\{\} & \text{si} \quad i \geqslant |\mathbf{c}|  \\
\{ i \} \cup D_J(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{if} \quad \mathbf{c}[i] = \text{\small JUMPDEST} \\
D_J(\mathbf{c}, N(i, \mathbf{c}[i])) & \text{sinon} \\
\end{cases}
\end{equation}

où $N$ est la position de l'instruction valide suivante dans le code, en sautant les données d'une instruction {\small PUSH} le cas échéant:
\begin{equation}
N(i, w) \equiv \begin{cases}
i + w - \text{\small PUSH1} + 2 & \text{si} \quad w \in [\text{\small PUSH1}, \text{\small PUSH32}] \\
i + 1 & \text{sinon} \end{cases}
\end{equation}

\subsubsection{Arrêt normal}

La fonction d'arrêt normal $H$ est définie par:
\begin{equation}
H(\boldsymbol{\mu}, I) \equiv \begin{cases}
H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) & \text{si} \quad w = \text{\small RETURN} \\
() & \text{if} \quad w \in \{ \text{\small STOP}, \text{\small SUICIDE} \} \\
\varnothing & \text{sinon}
\end{cases}
\end{equation}

L'opération d'arrêt renvoyant les données, \text{\small RETURN}, a une fonction spéciale $H_{\text{\tiny RETURN}}$, définie à l'Appendice \ref{app:vm}.

\subsection{Le cycle d'exécution}

Les éléments de la pile sont ajoutés ou retirés de la partie la plus à gauche et dont l'index est le plus bas de la série; tous les autres éléments restent inchangés:
\begin{eqnarray}
O\big((\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I)\big) & \equiv & (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \\
\Delta & \equiv & \mathbf{\alpha}_w - \mathbf{\delta}_w \\
\lVert\boldsymbol{\mu}'_\mathbf{s}\rVert & \equiv & \lVert\boldsymbol{\mu}_\mathbf{s}\rVert + \Delta \\
\quad \forall x \in [\mathbf{\alpha}_w, \lVert\boldsymbol{\mu}'_\mathbf{s}\rVert): \boldsymbol{\mu}'_\mathbf{s}[x] & \equiv & \boldsymbol{\mu}_\mathbf{s}[x+\Delta]
\end{eqnarray}

Le gaz est réduit du coût en gaz de l'instruction et, pour la plupart des instructions, le compteur de programme s'incrémente à chaque cycle, pour les trois exceptions, nous posons une fonction $J$, \textit{subscripted} par une ou deux instructions, qui donne les valeurs en accord avec:
\begin{eqnarray}
\quad \boldsymbol{\mu}'_{g} & \equiv & \boldsymbol{\mu}_{g} - C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \\
\quad \boldsymbol{\mu}'_{pc} & \equiv & \begin{cases}
J_{\text{JUMP}}(\boldsymbol{\mu}) & \text{si} \quad w = \text{\small JUMP} \\
J_{\text{JUMPI}}(\boldsymbol{\mu}) & \text{si} \quad w = \text{\small JUMPI} \\
N(\boldsymbol{\mu}_{pc}, w) & \text{sinon}
\end{cases}
\end{eqnarray}

En général, nous supposons que la mémoire, la liste de suicide et l'état du système ne changent pas:
\begin{eqnarray}
\boldsymbol{\mu}'_\mathbf{m} & \equiv & \boldsymbol{\mu}_\mathbf{m} \\
\boldsymbol{\mu}'_i & \equiv & \boldsymbol{\mu}_i \\
A' & \equiv & A \\
\boldsymbol{\sigma}' & \equiv & \boldsymbol{\sigma}
\end{eqnarray}

Cependant, les instructions altèrent typiquement une ou plusieurs composantes de ces valeurs. Les composantes altérées listées par instruction sont notées à l'Appendice \ref{app:vm}, accompagnées des valeurs de $\alpha$ et de $\delta$ avec une description formelle des exigences en gaz.

\section{De l'arbre des blocs à la chaîne des blocs} \label{ch:ghost}

La blockchain typique est un chemin de la racine jusqu'à la feuille à travers toute l'arborescence des blocs. Pour atteindre le consensus sur ce chemin, conceptuellement, nous identifions celui où le plus de calculs ont été effectués, c'est-à-dire le chemin dont \textit{le poids est le plus élevé}. L'un des facteurs qui permettent de déterminer le chemin dont poids le plus élevé est clairement le numéro de bloc de la feuille, qui est équivalent au nombre de blocs sans compter le bloc \textit{genesis} non miné, dans le chemin. Plus le chemin est long, plus l'effort nécessaire pour arriver à la feuille a été grand. Ce principe est comparable à d'autres, comme ceux employés dans les protocoles dérivés de Bitcoin.

Comme un en-tête de bloc inclut la difficulté, il suffit à lui seul à valider le calcul effectué. Chaque bloc contribue au calcul total, ou à la \textit{diffulté totale} d'une chaîne.

En conséquence, nous définissons récursivement la difficulté totale du bloc $B$ comme suit:
\begin{eqnarray}
B_t & \equiv & B'_t + B_d \\
B' & \equiv & P(B_H)
\end{eqnarray}

Cela implique qu'étant donné un bloc $B$, $B_t$ est sa difficulté totale, $B'$ est son bloc parent et $B_d$ est sa difficulté.

\section{Block Finalisation} \label{ch:finalisation}

The process of finalising a block involves four stages:

\begin{enumerate}
\item Validate (or, if mining, determine) ommers;
\item validate (or, if mining, determine) transactions;
\item apply rewards;
\item verify (or, if mining, compute a valid) state and nonce.
\end{enumerate}

\subsection{Ommer Validation}

The validation of ommer headers means nothing more than verifying that each ommer header is both a valid header and satisfies the relation of $N$th-generation ommer to the present block where $N \leq 6$. The maximum of ommer headers is two. Formally:
\begin{equation}
\lVert B_\mathbf{U} \rVert \leqslant 2 \bigwedge_{U \in B_\mathbf{U}} V(U) \; \wedge \; k(U, P(B_H)_H, 6)
\end{equation}

where $k$ denotes the ``is-kin'' property:
\begin{equation}
k(U, H, n) \equiv \begin{cases} false & \text{if} \quad n = 0 \\
s(U, H) &\\
\quad \vee \; k(U, P(H)_H, n - 1) & \text{otherwise}
\end{cases}
\end{equation}

and $s$ denotes the ``is-sibling'' property:
\begin{equation}
s(U, H) \equiv (P(H) = P(U)\; \wedge \; H \neq U \; \wedge \; U \notin B(H)_\mathbf{U})
\end{equation}
where $B(H)$ is the block of the corresponding header $H$.

\subsection{Transaction Validation}

%where $s[i]$ equals the root of the state trie immediately after the execution of the transaction $B_\mathbf{T}[i]$, and $g[i]$ the total gas used immediately after said transaction.

The given \textbf{gasUsed} must correspond faithfully to the transactions listed: ${B_H}_g$, the total gas used in the block, must be equal to the accumulated gas used according to the final transaction:
\begin{equation}
{B_H}_g = \ell(\mathbf{R})_u
\end{equation}

\subsection{Reward Application}

The application of rewards to a block involves raising the balance of the accounts of the beneficiary address of the block and each ommer by a certain amount. We raise the block's beneficiary account by $R_b$; for each ommer, we raise the block's beneficiary by an additional $\frac{1}{32}$ of the block reward and the beneficiary of the ommer gets rewarded depending on the block number. Formally we define the function $\Omega$:
\begin{eqnarray}
\Omega(B, \boldsymbol{\sigma}) & \equiv & \boldsymbol{\sigma}': \boldsymbol{\sigma}' = \boldsymbol{\sigma} \quad \text{except:} \\
\boldsymbol{\sigma}'[{B_H}_c]_b & = & \boldsymbol{\sigma}[{B_H}_c]_b + (1 + \frac{\lVert B_\mathbf{U}\rVert}{32})R_b \\
\forall_{U \in B_\mathbf{U}}: \\ \nonumber
 \boldsymbol{\sigma}'[U_c]_b & = & \boldsymbol{\sigma}[U_c]_b + (1 + \frac{1}{8} (U_i - {B_H}_i)) R_b
\end{eqnarray}

If there are collisions of the beneficiary addresses between ommers and the block (i.e. two ommers with the same beneficiary address or an ommer with the same beneficiary address as the present block), additions are applied cumulatively.

We define the block reward as 5 Ether:
\begin{equation}
\text{Let} \quad R_b = 5 \times 10^{18}
\end{equation}

\subsection{State \& Nonce Validation}\label{sec:statenoncevalidation}

We may now define the function, $\Gamma$, that maps a block $B$ to its initiation state:
\begin{equation}
\Gamma(B) \equiv \begin{cases}
\boldsymbol{\sigma}_0 & \text{if} \quad P(B_H) = \varnothing \\
\boldsymbol{\sigma}_i: \mathtt{\small TRIE}(L_S(\boldsymbol{\sigma}_i)) = {P(B_H)_H}_r & \text{otherwise}
\end{cases}
\end{equation}

Here, $\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma}_i))$ means the hash of the root node of a trie of state $\boldsymbol{\sigma}_i$; it is assumed that implementations will store this in the state database, trivial and efficient since the trie is by nature an immutable data structure.

And finally define $\Phi$, the block transition function, which maps an incomplete block $B$ to a complete block $B'$:
\begin{eqnarray}
\Phi(B) & \equiv & B': \quad B' = B^* \quad \text{except:} \\
B'_n & = & n: \quad x \leqslant \frac{2^{256}}{H_d} \\
B'_m & = & m \quad \text{with } (x, m) = \mathtt{PoW}(B^*_{\hcancel{n}}, n, \mathbf{d}) \\
B^* & \equiv & B \quad \text{except:} \quad B^*_r = r(\Pi(\Gamma(B), B))
\end{eqnarray}
With $\mathbf{d}$ being a dataset as specified in appendix \ref{app:ethash}.

As specified at the beginning of the present work, $\Pi$ is the state-transition function, which is defined in terms of $\Omega$, the block finalisation function and $\Upsilon$, the transaction-evaluation function, both now well-defined.

As previously detailed, $\mathbf{R}[n]_{\boldsymbol{\sigma}}$, $\mathbf{R}[n]_\mathbf{l}$ and $\mathbf{R}[n]_u$ are the $n$th corresponding states, logs and cumulative gas used after each transaction ($\mathbf{R}[n]_b$, the fourth component in the tuple, has already been defined in terms of the logs). The former is defined simply as the state resulting from applying the corresponding transaction to the state resulting from the previous transaction (or the block's initial state in the case of the first such transaction):
\begin{equation}
\mathbf{R}[n]_{\boldsymbol{\sigma}} = \begin{cases} \Gamma(B) & \text{if} \quad n < 0 \\ \Upsilon(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n]) & \text{otherwise} \end{cases}
\end{equation}

In the case of $B_\mathbf{R}[n]_u$, we take a similar approach defining each item as the gas used in evaluating the corresponding transaction summed with the previous item (or zero, if it is the first), giving us a running total:
\begin{equation}
\mathbf{R}[n]_u = \begin{cases} 0 & \text{if} \quad n < 0 \\
\begin{array}[b]{l}
\Upsilon^g(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n])\\ \quad + \mathbf{R}[n-1]_u
\end{array}
 & \text{otherwise} \end{cases}
\end{equation}

For $\mathbf{R}[n]_\mathbf{l}$, we utilise the $\Upsilon^\mathbf{l}$ function that we conveniently defined in the transaction execution function.
\begin{equation}
\mathbf{R}[n]_\mathbf{l} =
\Upsilon^\mathbf{l}(\mathbf{R}[n - 1]_{\boldsymbol{\sigma}}, B_\mathbf{T}[n])
\end{equation}

Finally, we define $\Pi$ as the new state given the block reward function $\Omega$ applied to the final transaction's resultant state, $\ell(B_\mathbf{R})_{\boldsymbol{\sigma}}$:
\begin{equation}
\Pi(\boldsymbol{\sigma}, B) \equiv \Omega(B, \ell(\mathbf{R})_{\boldsymbol{\sigma}})
\end{equation}

Thus the complete block-transition mechanism, less $\mathtt{PoW}$, the proof-of-work function is defined.

\subsection{Mining Proof-of-Work} \label{ch:pow}

The mining proof-of-work (PoW) exists as a cryptographically secure nonce that proves beyond reasonable doubt that a particular amount of computation has been expended in the determination of some token value $n$. It is utilised to enforce the blockchain security by giving meaning and credence to the notion of difficulty (and, by extension, total difficulty). However, since mining new blocks comes with an attached reward, the proof-of-work not only functions as a method of securing confidence that the blockchain will remain canonical into the future, but also as a wealth distribution mechanism.

For both reasons, there are two important goals of the proof-of-work function; firstly, it should be as accessible as possible to as many people as possible. The requirement of, or reward from, specialised and uncommon hardware should be minimised. This makes the distribution model as open as possible, and, ideally, makes the act of mining a simple swap from electricity to Ether at roughly the same rate for anyone around the world.

Secondly, it should not be possible to make super-linear profits, and especially not so with a high initial barrier. Such a mechanism allows a well-funded adversary to gain a troublesome amount of the network's total mining power and as such gives them a super-linear reward (thus skewing distribution in their favour) as well as reducing the network security.

One plague of the Bitcoin world is ASICs. These are specialised pieces of compute hardware that exist only to do a single task. In Bitcoin's case the task is the SHA256 hash function. While ASICs exist for a proof-of-work function, both goals are placed in jeopardy. Because of this, a proof-of-work function that is ASIC-resistant (i.e. difficult or economically inefficient to implement in specialised compute hardware) has been identified as the proverbial silver bullet.

Two directions exist for ASIC resistance; firstly make it sequential memory-hard, i.e. engineer the function such that the determination of the nonce requires a lot of memory and bandwidth such that the memory cannot be used in parallel to discover multiple nonces simultaneously. The second is to make the type of computation it would need to do general-purpose; the meaning of ``specialised hardware''  for a general-purpose task set is, naturally, general purpose hardware and as such commodity desktop computers are likely to be pretty close to ``specialised hardware'' for the task. For Ethereum 1.0 we have chosen the first path.

More formally, the proof-of-work function takes the form of $\mathtt{PoW}$:
\begin{equation}
m = H_m \quad \wedge \quad n \leqslant \frac{2^{256}}{H_d} \quad \text{with} \quad (m, n) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})
\end{equation}

Where $H_{\hcancel{n}}$ is the new block's header but \textit{without} the nonce and mix-hash components; $H_n$ is the nonce of the header; $\mathbf{d}$ is a large data set needed to compute the mixHash and $H_d$ is the new block's difficulty value (i.e. the block difficulty from section \ref{ch:ghost}). $\mathtt{PoW}$ is the proof-of-work function which evaluates to an array with the first item being the mixHash and the second item being a pseudo-random number cryptographically dependent on $H$ and $\mathbf{d}$. The underlying algorithm is called Ethash and is described below.
\subsubsection{Ethash}
Ethash is the planned PoW algorithm for Ethereum 1.0. It is the latest version of Dagger-Hashimoto, introduced by \cite{dagger} and \cite{hashimoto}, although it can no longer appropriately be called that since many of the original features of both algorithms have been drastically changed in the last month of research and development. The general route that the algorithm takes is as follows:

There exists a seed which can be computed for each block by scanning through the block headers up until that point. From the seed, one can compute a pseudorandom cache, $J_{cacheinit}$ bytes in initial size. Light clients store the cache. From the cache, we can generate a dataset, $J_{datasetinit}$ bytes in initial size, with the property that each item in the dataset depends on only a small number of items from the cache. Full clients and miners store the dataset. The dataset grows linearly with time.

Mining involves grabbing random slices of the dataset and hashing them together. Verification can be done with low memory by using the cache to regenerate the specific pieces of the dataset that you need, so you only need to store the cache. The large dataset is updated once every $J_{epoch}$ blocks, so the vast majority of a miner's effort will be reading the dataset, not making changes to it. The mentioned parameters as well as the algorithm is explained in detail in appendix \ref{app:ethash}.

\section{Implementing Contracts}

There are several patterns of contracts engineering that allow particular useful behaviours; two of these that I will briefly discuss are data feeds and random numbers.

\subsection{Data Feeds}
A data feed contract is one which provides a single service: it gives access to information from the external world within Ethereum. The accuracy and timeliness of this information is not guaranteed and it is the task of a secondary contract author---the contract that utilises the data feed---to determine how much trust can be placed in any single data feed.

The general pattern involves a single contract within Ethereum which, when given a message call, replies with some timely information concerning an external phenomenon. An example might be the local temperature of New York City. This would be implemented as a contract that returned that value of some known point in storage. Of course this point in storage must be maintained with the correct such temperature, and thus the second part of the pattern would be for an external server to run an Ethereum node, and immediately on discovery of a new block, creates a new valid transaction, sent to the contract, updating said value in storage. The contract's code would accept such updates only from the identity contained on said server.

\subsection{Random Numbers}
Providing random numbers within a deterministic system is, naturally, an impossible task. However, we can approximate with pseudo-random numbers by utilising data which is generally unknowable at the time of transacting. Such data might include the block's hash, the block's timestamp and the block's beneficiary address. In order to make it hard for malicious miner to control those values, one should use the {\small BLOCKHASH} operation in order to use hashes of the previous 256 blocks as pseudo-random numbers. For a series of such numbers, a trivial solution would be to add some constant amount and hashing the result.

\section{Future Directions} \label{ch:future}

The state database won't be forced to maintain all past state trie structures into the future. It should maintain an age for each node and eventually discard nodes that are neither recent enough nor checkpoints; checkpoints, or a set of nodes in the database that allow a particular block's state trie to be traversed, could be used to place a maximum limit on the amount of computation needed in order to retrieve any state throughout the blockchain.

Blockchain consolidation could be used in order to reduce the amount of blocks a client would need to download to act as a full, mining, node. A compressed archive of the trie structure at given points in time (perhaps one in every 10,000th block) could be maintained by the peer network, effectively recasting the genesis block. This would reduce the amount to be downloaded to a single archive plus a hard maximum limit  of blocks.

Finally, blockchain compression could perhaps be conducted: nodes in state trie that haven't sent/received a transaction in some constant amount of blocks could be thrown out, reducing both Ether-leakage and the growth of the state database.

\subsection{Scalability}

Scalability remains an eternal concern. With a generalised state transition function, it becomes difficult to partition and parallelise transactions to apply the divide-and-conquer strategy. Unaddressed, the dynamic value-range of the system remains essentially fixed and as the average transaction value increases, the less valuable of them become ignored, being economically pointless to include in the main ledger. However, several strategies exist that may potentially be exploited to provide a considerably more scalable protocol.

Some form of hierarchical structure, achieved by either consolidating smaller lighter-weight chains into the main block or building the main block through the incremental combination and adhesion (through proof-of-work) of smaller transaction sets may allow parallelisation of transaction combination and block-building. Parallelism could also come from a prioritised set of parallel blockchains, consolidated each block and with duplicate or invalid transactions thrown out accordingly.

Finally, verifiable computation, if made generally available and efficient enough, may provide a route to allow the proof-of-work to be the verification of final state.

\section{Conclusion} \label{ch:conclusion}

I have introduced, discussed and formally defined the protocol of Ethereum. Through this protocol the reader may implement a node on the Ethereum network and join others in a decentralised secure social operating system. Contracts may be authored in order to algorithmically specify and autonomously enforce rules of interaction.

\section{Acknowledgements}

Many thanks to Aeron Buchanan for authoring the Homestead revisions, Christoph Jentzsch for authoring the Ethash algorithm and Yoichi Hirai for doing most of the EIP-150 changes. Important maintenance, useful corrections and suggestions were provided by a number of others from the Ethereum DEV organisation and Ethereum community at large including Gustav Simonsson, Pawe\l{} Bylica, Jutta Steiner, Nick Savers, Viktor Tr\'{o}n, Marko Simovic, Giacomo Tazzari and, of course, Vitalik Buterin.

\bibliography{Biblio}
\bibliographystyle{plainnat}

\end{multicols}

\appendix

\section{Terminology}

\begin{description}
\item[External Actor] A person or other entity able to interface to an Ethereum node, but external to the world of Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain and associated state. Has one (or more) intrinsic Accounts.

\item[Address] A 160-bit code used for identifying Accounts.

\item[Account] Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state. They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them. Though homogenous, it makes sense to distinguish between two practical types of account: those with empty associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a single Address that identifies it.

\item[Transaction] A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous Object. Transactions are recorded into each block of the blockchain.

\item[Autonomous Object] A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated only as the Storage State of that account.

\item[Storage State] The information particular to a given Account that is maintained between the times that the Account's associated EVM Code runs.

\item[Message] Data (as a set of bytes) and Value (specified as Ether) that is passed between two Accounts, either through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the Transaction.

\item[Message Call] The act of passing a message from one Account to another. If the destination account is associated with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM operation.

\item[Gas] The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.

\item[Contract] Informal term used to mean both a piece of EVM Code that may be associated with an Account or an Autonomous Object.

\item[Object] Synonym for Autonomous Object.

\item[App] An end-user-visible application hosted in the Ethereum Browser.

\item[Ethereum Browser] (aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simplified browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum protocol.

\item[Ethereum Virtual Machine] (aka EVM) The virtual machine that forms the key part of the execution model for an Account's associated EVM Code.

\item[Ethereum Runtime Environment] (aka ERE) The environment which is provided to an Autonomous Object executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for certain I/O instructions including CALL \& CREATE.

\item[EVM Code] The bytecode that the EVM can natively execute. Used to formally specify the meaning and ramifications of a message to an Account.

\item[EVM Assembly] The human-readable form of EVM-code.

\item[LLL] The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general low-level language toolkit for trans-compiling to.

\end{description}

\section{Recursive Length Prefix}\label{app:rlp}
This is a serialisation method for encoding arbitrarily structured binary data (byte arrays).

We define the set of possible structures $\mathbb{T}$:
\begin{eqnarray}
\mathbb{T} & \equiv & \mathbb{L} \cup \mathbb{B} \\
\mathbb{L} & \equiv & \{ \mathbf{t}: \mathbf{t} = ( \mathbf{t}[0], \mathbf{t}[1], ... ) \; \wedge \; \forall_{n < \lVert \mathbf{t} \rVert} \; \mathbf{t}[n] \in \mathbb{T} \} \\
\mathbb{B} & \equiv & \{ \mathbf{b}: \mathbf{b} = ( \mathbf{b}[0], \mathbf{b}[1], ... ) \; \wedge \; \forall_{n < \lVert \mathbf{b} \rVert} \; \mathbf{b}[n] \in \mathbb{O} \}
\end{eqnarray}

Where $\mathbb{O}$ is the set of bytes. Thus $\mathbb{B}$ is the set of all sequences of bytes (otherwise known as byte-arrays, and a leaf if imagined as a tree), $\mathbb{L}$ is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if imagined as a tree) and $\mathbb{T}$ is the set of all byte-arrays and such structural sequences.

We define the RLP function as $\mathtt{\tiny RLP}$ through two sub-functions, the first handling the instance when the value is a byte array, the second when it is a sequence of further values:
\begin{equation}
\mathtt{\tiny RLP}(\mathbf{x}) \equiv \begin{cases} R_b(\mathbf{x}) & \text{if} \quad \mathbf{x} \in \mathbb{B} \\ R_l(\mathbf{x}) & \text{otherwise} \end{cases}
\end{equation}

If the value to be serialised is a byte-array, the RLP serialisation takes one of three forms:

\begin{itemize}
\item If the byte-array contains solely a single byte and that single byte is less than 128, then the input is exactly equal to the output.
\item If the byte-array contains fewer than 56 bytes, then the output is equal to the input prefixed by the byte equal to the length of the byte array plus 128.
\item Otherwise, the output is equal to the input prefixed by the minimal-length byte-array which when interpreted as a big-endian integer is equal to the length of the input byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 183.
\end{itemize}

Formally, we define $R_b$:
\begin{eqnarray}
R_b(\mathbf{x}) & \equiv & \begin{cases}
\mathbf{x} & \text{if} \quad \lVert \mathbf{x} \rVert = 1 \wedge \mathbf{x}[0] < 128 \\
(128 + \lVert \mathbf{x} \rVert) \cdot \mathbf{x} & \text{else if} \quad \lVert \mathbf{x} \rVert < 56 \\
\big(183 + \big\lVert \mathtt{\tiny BE}(\lVert \mathbf{x} \rVert) \big\rVert \big) \cdot \mathtt{\tiny BE}(\lVert \mathbf{x} \rVert) \cdot \mathbf{x} & \text{otherwise}
\end{cases} \\
\mathtt{\tiny BE}(x) & \equiv & (b_0, b_1, ...): b_0 \neq 0 \wedge x = \sum_{n = 0}^{n < \lVert \mathbf{b} \rVert} b_n \cdot 256^{\lVert \mathbf{b} \rVert - 1 - n} \\
(a) \cdot (b, c) \cdot (d, e) & = & (a, b, c, d, e)
\end{eqnarray}

Thus $\mathtt{\tiny BE}$ is the function that expands a positive integer value to a big-endian byte array of minimal length and the dot operator performs sequence concatenation.

If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:

\begin{itemize}
\item If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal to that concatenation prefixed by the byte equal to the length of this byte array plus 192.
\item Otherwise, the output is equal to the concatenated serialisations prefixed by the minimal-length byte-array which when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte array, which is itself prefixed by the number of bytes required to faithfully encode this length value plus 247.
\end{itemize}

Thus we finish by formally defining $R_l$:
\begin{eqnarray}
R_l(\mathbf{x}) & \equiv & \begin{cases}
(192 + \lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) & \text{if} \quad \lVert s(\mathbf{x}) \rVert < 56 \\
\big(247 + \big\lVert \mathtt{\tiny BE}(\lVert s(\mathbf{x}) \rVert) \big\rVert \big) \cdot \mathtt{\tiny BE}(\lVert s(\mathbf{x}) \rVert) \cdot s(\mathbf{x}) & \text{otherwise}
\end{cases} \\
s(\mathbf{x}) & \equiv & \mathtt{\tiny RLP}(\mathbf{x}_0) \cdot \mathtt{\tiny RLP}(\mathbf{x}_1) ...
\end{eqnarray}

If RLP is used to encode a scalar, defined only as a positive integer ($\mathbb{P}$ or any $x$ for $\mathbb{P}_x$), it must be specified as the shortest byte array such that the big-endian interpretation of it is equal. Thus the RLP of some positive integer $i$ is defined as:
\begin{equation}
\mathtt{\tiny RLP}(i : i \in \mathbb{P}) \equiv \mathtt{\tiny RLP}(\mathtt{\tiny BE}(i))
\end{equation}

When interpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP data, dismissing it completely.

There is no specific canonical encoding format for signed or floating-point values.

\section{Hex-Prefix Encoding}\label{app:hexprefix}
Hex-prefix encoding is an efficient method of encoding an arbitrary number of nibbles as a byte array. It is able to store an additional flag which, when used in the context of the trie (the only context in which it is used), disambiguates between node types.

It is defined as the function $\mathtt{\tiny HP}$ which maps from a sequence of nibbles (represented by the set $\mathbb{Y}$) together with a boolean value to a sequence of bytes (represented by the set $\mathbb{B}$):

\begin{eqnarray}
\mathtt{\tiny HP}(\mathbf{x}, t): \mathbf{x} \in \mathbb{Y} & \equiv & \begin{cases}
(16f(t), 16\mathbf{x}[0] + \mathbf{x}[1], 16\mathbf{x}[2] + \mathbf{x}[3], ...) &
\text{if} \quad \lVert \mathbf{x} \rVert \; \text{is even} \\
(16(f(t) + 1) + \mathbf{x}[0], 16\mathbf{x}[1] + \mathbf{x}[2], 16\mathbf{x}[3] + \mathbf{x}[4], ...) &
\text{otherwise}
\end{cases} \\
f(t) & \equiv & \begin{cases} 2 & \text{if} \quad t \neq 0 \\ 0 & \text{otherwise} \end{cases}
\end{eqnarray}

Thus the high nibble of the first byte contains two flags; the lowest bit encoding the oddness of the length and the second-lowest encoding the flag $t$. The low nibble of the first byte is zero in the case of an even number of nibbles and the first nibble in the case of an odd number. All remaining nibbles (now an even number) fit properly into the remaining bytes.

\section{Modified Merkle Patricia Tree}\label{app:trie}
The modified Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary data (byte arrays). It is defined in terms of a mutable data structure to map between 256-bit binary fragments and arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms of the protocol specification is to provide a single value that identifies a given set of key-value pairs, which may be either a 32 byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the structure of the trie in a manner the allows effective and efficient realisation of the protocol.

Formally, we assume the input value $\mathfrak{I}$, a set containing pairs of byte sequences:
\begin{equation}
\mathfrak{I} = \{ (\mathbf{k}_0 \in \mathbb{B}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1 \in \mathbb{B}, \mathbf{v}_1 \in \mathbb{B}), ... \}
\end{equation}

When considering such a sequence, we use the common numeric subscript notation to refer to a tuple's key or value, thus:
\begin{equation}
\forall_{I \in \mathfrak{I}} I \equiv (I_0, I_1)
\end{equation}

Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-specific notation; here we assume big-endian. Thus:
\begin{eqnarray}
y(\mathfrak{I}) & = & \{ (\mathbf{k}_0' \in \mathbb{Y}, \mathbf{v}_0 \in \mathbb{B}), (\mathbf{k}_1' \in \mathbb{Y}, \mathbf{v}_1 \in \mathbb{B}), ... \} \\
\forall_n \quad \forall_{i: i < 2\lVert\mathbf{k}_n\rVert} \quad \mathbf{k}_n'[i] & \equiv &
\begin{cases}
\lfloor \mathbf{k}_n[i \div 2] \div 16 \rfloor & \text{if} \; i \; \text{is even} \\
\mathbf{k}_n[\lfloor i \div 2 \rfloor] \bmod 16 & \text{otherwise}
\end{cases}
\end{eqnarray}

We define the function $\texttt{\small TRIE}$, which evaluates to the root of the trie that represents this set when encoded in this structure:
\begin{equation}
\texttt{\small TRIE}(\mathfrak{I}) \equiv \texttt{\small KEC}(c(\mathfrak{I}, 0))
\end{equation}

We also assume a function $n$, the trie's node cap function. When composing a node, we use RLP to encode the structure. As a means of reducing storage complexity, for nodes whose composed RLP is fewer than 32 bytes, we store the RLP directly; for those larger we assert prescience of the byte array whose Keccak hash evaluates to our reference. Thus we define in terms of $c$, the node composition function:
\begin{equation}
n(\mathfrak{I}, i) \equiv \begin{cases}
() & \text{if} \quad \mathfrak{I} = \varnothing \\
c(\mathfrak{I}, i) & \text{if} \quad \lVert c(\mathfrak{I}, i)\rVert < 32 \\
\texttt{\small KEC}(c(\mathfrak{I}, i)) & \text{otherwise}
\end{cases}
\end{equation}

In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair. The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree). Unlike a radix tree, in the case of multiple keys sharing the same prefix or in the case of a single key having a unique suffix, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each of the other two node types, extension and leaf. There are three kinds of nodes in the trie:
\begin{description}
\item[Leaf] A two-item structure whose first item corresponds to the nibbles in the key not already accounted for by the accumulation of keys and branches traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be $true$.
\item[Extension] A two-item structure whose first item corresponds to a series of nibbles of size greater than one that are shared by at least two distinct keys past the accumulation of nibbles keys and branches as traversed from the root. The hex-prefix encoding method is used and the second parameter to the function is required to be $false$.
\item[Branch] A 17-item structure whose first sixteen items correspond to each of the sixteen possible nibble values for the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and thus a key being ended at this point in its traversal.
\end{description}

A branch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We may formally define this structure with the structural composition function $c$:
\begin{equation}
c(\mathfrak{I}, i) \equiv \begin{cases}
\texttt{\small RLP}\Big( \big(\texttt{\small HP}(I_0[i .. (\lVert I_0\rVert - 1)], true), I_1 \big) \Big) & \text{if} \quad \lVert \mathfrak{I} \rVert = 1 \quad \text{where} \; \exists I: I \in \mathfrak{I} \\
\texttt{\small RLP}\Big( \big(\texttt{\small HP}(I_0[i .. (j - 1)], false), n(\mathfrak{I}, j) \big) \Big) & \text{if} \quad i \ne j \quad \text{where} \; j = \arg \max_x : \exists \mathbf{l}: \lVert \mathbf{l} \rVert = x : \forall_{I \in \mathfrak{I}}: I_0[0 .. (x - 1)] = \mathbf{l} \\
\texttt{\small RLP}\Big( (u(0), u(1), ..., u(15), v) \Big) & \text{otherwise} \quad \text{where} \begin{array}[t]{rcl}
u(j) & \equiv & n(\{ I : I \in \mathfrak{I} \wedge I_0[i] = j \}, i + 1) \\
v & = & \begin{cases}
I_1 & \text{if} \quad \exists I: I \in \mathfrak{I} \wedge \lVert I_0 \rVert = i \\
() & \text{otherwise}
\end{cases}
\end{array}
\end{cases}
\end{equation}

\subsection{Trie Database}
Thus no explicit assumptions are made concerning what data is stored and what is not, since that is an implementation-specific consideration; we simply define the identity function mapping the key-value set $\mathfrak{I}$ to a 32-byte hash and assert that only a single such hash exists for any $\mathfrak{I}$, which though not strictly true is accurate within acceptable precision given the Keccak hash's collision resistance. In reality, a sensible implementation will not fully recompute the trie root hash for each set.

A reasonable implementation will maintain a database of nodes determined from the computation of various tries or, more formally, it will memoise the function $c$. This strategy uses the nature of the trie to both easily recall the contents of any previous key-value set and to store multiple such sets in a very efficient manner. Due to the dependency relationship, Merkle-proofs may be constructed with an $O(\log N)$ space requirement that can demonstrate a particular leaf must exist within a trie of a given root hash.

\section{Precompiled Contracts}\label{app:precompiled}

For each precompiled contract, we make use of a template function, $\Xi_{\mathtt{PRE}}$, which implements the out-of-gas checking.
\begin{equation}
\Xi_{\mathtt{PRE}}(\boldsymbol{\sigma}, g, I) \equiv \begin{cases}
(\varnothing, 0, A^0, ()) & \text{if} \quad g < g_r \\
(\boldsymbol\sigma, g - g_r, A^0, \mathbf{o}) & \text{otherwise}\end{cases}
\end{equation}

The precompiled contracts each use these definitions and provide specifications for the $\mathbf{o}$ (the output data) and $g_r$, the gas requirements.

For the elliptic curve DSA recover VM execution function, we also define $\mathbf{d}$ to be the input data, well-defined for an infinite length by appending zeroes as required. Importantly in the case of an invalid signature ($\mathtt{\tiny ECDSARECOVER}(h, v, r, s) = \varnothing$), then we have no output.
\begin{eqnarray}
\Xi_{\mathtt{ECREC}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 3000\\
|\mathbf{o}| &=& \begin{cases} 0 & \text{if} \quad \mathtt{\tiny ECDSARECOVER}(h, v, r, s) = \varnothing\\ 32 & \text{otherwise} \end{cases}\\
\text{if} \quad |\mathbf{o}| = 32: &&\\
\mathbf{o}[0..11] &=& 0 \\
\mathbf{o}[12..31] &=& \mathtt{\tiny KEC}\big(\mathtt{\tiny ECDSARECOVER}(h, v, r, s)\big)[12..31] \quad \text{where:}\\
\mathbf{d}[0..(|I_\mathbf{d}|-1)] &=& I_\mathbf{d}\\
\mathbf{d}[|I_\mathbf{d}|..] &=& (0, 0, ...) \\
h &=& \mathbf{d}[0..31]\\
v &=& \mathbf{d}[32..63]\\
r &=& \mathbf{d}[64..95]\\
s &=& \mathbf{d}[96..127]
\end{eqnarray}

The two hash functions, RIPEMD-160 and SHA2-256 are more trivially defined as an almost pass-through operation. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.
\begin{eqnarray}
\Xi_{\mathtt{SHA256}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 60 + 12\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o}[0..31] &=& \mathtt{\tiny SHA256}(I_\mathbf{d})\\
\Xi_{\mathtt{RIP160}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 600 + 120\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o}[0..11] &=& 0 \\
\mathbf{o}[12..31] &=& \mathtt{\tiny RIPEMD160}(I_\mathbf{d})\\
\end{eqnarray}

For the purposes here, we assume we have well-defined standard cryptographic functions for RIPEMD-160 and SHA2-256 of the form:
\begin{eqnarray}
\mathtt{\small SHA256}(\mathbf{i} \in \mathbb{B}) & \equiv & o \in \mathbb{B}_{32} \\
\mathtt{\small RIPEMD160}(\mathbf{i} \in \mathbb{B}) & \equiv & o \in \mathbb{B}_{20}
\end{eqnarray}

Finally, the fourth contract, the identity function $\Xi_{\mathtt{ID}}$ simply defines the output as the input:
\begin{eqnarray}
\Xi_{\mathtt{ID}} &\equiv& \Xi_{\mathtt{PRE}} \quad \text{where:} \\
g_r &=& 15 + 3\Big\lceil \dfrac{|I_\mathbf{d}|}{32} \Big\rceil\\
\mathbf{o} &=& I_\mathbf{d}
\end{eqnarray}


\section{Signing Transactions}\label{app:signing}

The method of signing transactions is similar to the `Electrum style signatures'; it utilises the SECP-256k1 curve as described by \cite{gura2004comparing}.

It is assumed that the sender has a valid private key $p_r$, which is a randomly selected positive integer (represented as a byte array of length 32 in big-endian form) in the range \hbox{$[1, \mathtt{\tiny secp256k1n} - 1]$}.

We assert the functions $\mathtt{\small ECDSASIGN}$, $\mathtt{\small ECDSARESTORE}$ and $\mathtt{\small ECDSAPUBKEY}$. These are formally defined in the literature.
\begin{eqnarray}
\mathtt{\small ECDSAPUBKEY}(p_r \in \mathbb{B}_{32}) & \equiv & p_u \in \mathbb{B}_{64} \\
\mathtt{\small ECDSASIGN}(e \in \mathbb{B}_{32}, p_r \in \mathbb{B}_{32}) & \equiv & (v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) \\
\mathtt{\small ECDSARECOVER}(e \in \mathbb{B}_{32}, v \in \mathbb{B}_{1}, r \in \mathbb{B}_{32}, s \in \mathbb{B}_{32}) & \equiv & p_u \in \mathbb{B}_{64}
\end{eqnarray}

Where $p_u$ is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive integers each $< 2^{256}$) and $p_r$ is the private key, a byte array of size 32 (or a single positive integer in the aforementioned range). It is assumed that $v$ is the `recovery id', a 1 byte value specifying the sign and finiteness of the curve point; this value is in the range of $[27, 30]$, however we declare the upper two possibilities, representing infinite values, invalid.

\newcommand{\slimit}{\ensuremath{\text{s-limit}}}

We declare that a signature is invalid unless all the following conditions are true:
\begin{align}
0 < r &< \mathtt{\tiny secp256k1n} \\
0 < s &< \begin{dcases}
\mathtt{\tiny secp256k1n} & \text{if} \quad H_i < \firsthomesteadblock \\
\mathtt{\tiny secp256k1n} \div 2 & \text{otherwise} \\
\end{dcases} \\
 v &\in \{27,28\}
\end{align}
where:
\begin{align}
\mathtt{\tiny secp256k1n} &= 115792089237316195423570985008687907852837564279074904382605163141518161494337
%\mathtt{\tiny secp256k1p} &= 2^{256} - 2^{32} - 977\\
\end{align}

For a given private key, $p_r$, the Ethereum address $A(p_r)$ (a 160-bit value) to which it corresponds is defined as the right most 160-bits of the Keccak hash of the corresponding ECDSA public key:
\begin{equation}
A(p_r) = \mathcal{B}_{96..255}\big(\mathtt{\tiny KEC}\big( \mathtt{\small ECDSAPUBKEY}(p_r) \big) \big)
\end{equation}

The message hash, $h(T)$, to be signed is the Keccak hash of the transaction without the latter three signature components, formally described as $T_r$, $T_s$ and $T_w$:
\begin{eqnarray}
L_S(T) & \equiv & \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}) & \text{if} \; T_t = 0\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}) & \text{otherwise}
\end{cases} \\
h(T) & \equiv & \mathtt{\small KEC}( L_S(T) )
\end{eqnarray}

The signed transaction $G(T, p_r)$ is defined as:
\begin{eqnarray}
G(T, p_r) \equiv T \quad \text{except:} \\
(T_w, T_r, T_s) = \mathtt{\small ECDSASIGN}(h(T), p_r)
\end{eqnarray}

We may then define the sender function $S$ of the transaction as:
\begin{equation}
S(T) \equiv \mathcal{B}_{96..255}\big(\mathtt{\tiny KEC}\big( \mathtt{\small ECDSARECOVER}(h(T), T_w, T_r, T_s) \big) \big)
\end{equation}

The assertion that the sender of the a signed transaction equals the address of the signer should be self-evident:
\begin{equation}
\forall T: \forall p_r: S(G(T, p_r)) \equiv A(p_r)
\end{equation}

\section{Fee Schedule}\label{app:fees}

The fee schedule $G$ is a tuple of 31 scalar values corresponding to the relative costs, in gas, of a number of abstract operations that a transaction may effect.

\begin{tabular*}{\columnwidth}[h]{lrl}
\toprule
Name & Value & Description* \\
\midrule
$G_{zero}$ & 0 & Nothing paid for operations of the set {\small $W_{zero}$}. \\
$G_{base}$ & 2 & Amount of gas to pay for operations of the set {\small $W_{base}$}. \\
$G_{verylow}$ & 3 & Amount of gas to pay for operations of the set {\small $W_{verylow}$}. \\
$G_{low}$ & 5 & Amount of gas to pay for operations of the set {\small $W_{low}$}. \\
$G_{mid}$ & 8 & Amount of gas to pay for operations of the set {\small $W_{mid}$}. \\
$G_{high}$ & 10 & Amount of gas to pay for operations of the set {\small $W_{high}$}. \\
$G_{extcode}$ & 700 & Amount of gas to pay for operations of the set {\small $W_{extcode}$}. \\
$G_{balance}$ & 400 & Amount of gas to pay for a {\small BALANCE} operation. \\
$G_{sload}$ & 200 & Paid for a {\small SLOAD} operation. \\
$G_{jumpdest}$ & 1 & Paid for a {\small JUMPDEST} operation. \\
$G_{sset}$ & 20000 & Paid for an {\small SSTORE} operation when the storage value is set to non-zero from zero. \\
$G_{sreset}$ & 5000 & Paid for an {\small SSTORE} operation when the storage value's zeroness remains unchanged or is set to zero. \\
$R_{sclear}$ & 15000 & Refund given (added into refund counter) when the storage value is set to zero from non-zero. \\
$R_{suicide}$ & 24000 & Refund given (added into refund counter) for suiciding an account. \\
$G_{suicide}$ & 5000 & Amount of gas to pay for a {\small SUICIDE} operation. \\
$G_{create}$ & 32000 & Paid for a {\small CREATE} operation. \\
$G_{codedeposit}$ & 200 & Paid per byte for a {\small CREATE} operation to succeed in placing code into state. \\
$G_{call}$ & 700 & Paid for a {\small CALL} operation. \\
$G_{callvalue}$ & 9000 & Paid for a non-zero value transfer as part of the {\small CALL} operation. \\
$G_{callstipend}$ & 2300 & A stipend for the called contract subtracted from $G_{callvalue}$ for a non-zero value transfer. \\
$G_{newaccount}$ & 25000 & Paid for a {\small CALL} or {\small SUICIDE} operation which creates an account. \\
$G_{exp}$ & 10 & Partial payment for an {\small EXP} operation. \\
$G_{expbyte}$ & 10 & Partial payment when multiplied by $\lceil\log_{256}(exponent)\rceil$ for the {\small EXP} operation. \\
$G_{memory}$ & 3 & Paid for every additional word when expanding memory. \\
$G_\text{txcreate}$ & 32000 & Paid by all contract-creating transactions after the {\it Homestead transition}.\\
$G_{txdatazero}$ & 4 & Paid for every zero byte of data or code for a transaction. \\
$G_{txdatanonzero}$ & 68 & Paid for every non-zero byte of data or code for a transaction. \\
$G_{transaction}$ & 21000 & Paid for every transaction. \\
$G_{log}$ & 375 & Partial payment for a {\small LOG} operation. \\
$G_{logdata}$ & 8 & Paid for each byte in a {\small LOG} operation's data. \\
$G_{logtopic}$ & 375 & Paid for each topic of a {\small LOG} operation. \\
$G_{sha3}$ & 30 & Paid for each {\small SHA3} operation. \\
$G_{sha3word}$ & 6 & Paid for each word (rounded up) for input data to a {\small SHA3} operation. \\
$G_{copy}$ & 3 & Partial payment for {\small *COPY} operations, multiplied by words copied, rounded up. \\
$G_{blockhash}$ & 20 & Payment for {\small BLOCKHASH} operation. \\

%extern u256 const c_copyGas;			///< Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added.
\bottomrule
\end{tabular*}

\section{Virtual Machine Specification}\label{app:vm}

When interpreting 256-bit binary values as integers, the representation is big-endian.

When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE) 20 bytes are used and the left most 12 are discarded or filled with zeroes, thus the integer values (when the bytes are interpreted as big-endian) are equivalent.

\subsection{Gas Cost}

The general gas cost function, $C$, is defined as:

\begin{equation}
C(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) \equiv C_{mem}(\boldsymbol{\mu}'_i)-C_{mem}(\boldsymbol{\mu}_i) + \begin{cases}
C_\text{\tiny SSTORE}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small SSTORE} \\
G_{exp} & \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_\mathbf{s}[1] = 0 \\
G_{exp} + G_{expbyte}\times(1+\lfloor\log_{256}(\boldsymbol{\mu}_\mathbf{s}[1])\rfloor) & \text{if} \quad w = \text{\small EXP} \wedge \boldsymbol{\mu}_\mathbf{s}[1] > 0 \\
G_{verylow} + G_{copy}\times\lceil\boldsymbol{\mu}_\mathbf{s}[2] \div 32\rceil & \text{if} \quad w = \text{\small CALLDATACOPY} \lor \text{\small CODECOPY} \\
G_{extcode} + G_{copy}\times\lceil\boldsymbol{\mu}_\mathbf{s}[3] \div 32\rceil & \text{if} \quad w = \text{\small EXTCODECOPY} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1] & \text{if} \quad w = \text{\small LOG0} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+G_{logtopic} & \text{if} \quad w = \text{\small LOG1} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+2G_{logtopic} & \text{if} \quad w = \text{\small LOG2} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+3G_{logtopic} & \text{if} \quad w = \text{\small LOG3} \\
G_{log}+G_{logdata}\times\boldsymbol{\mu}_\mathbf{s}[1]+4G_{logtopic} & \text{if} \quad w = \text{\small LOG4} \\
C_\text{\tiny CALL}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small CALL} \lor \text{\small CALLCODE} \lor \text{\small DELEGATECALL} \\
C_\text{\tiny SUICIDE}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{if} \quad w = \text{\small SUICIDE} \\
G_{create} & \text{if} \quad w = \text{\small CREATE}\\
G_{sha3}+G_{sha3word} \lceil \mathbf{s}[1] \div 32 \rceil & \text{if} \quad w = \text{\small SHA3}\\
G_{jumpdest} & \text{if} \quad w = \text{\small JUMPDEST}\\
G_{sload} & \text{if} \quad w = \text{\small SLOAD}\\
G_{zero} & \text{if} \quad w \in W_{zero}\\
G_{base} & \text{if} \quad w \in W_{base}\\
G_{verylow} & \text{if} \quad w \in W_{verylow}\\
G_{low} & \text{if} \quad w \in W_{low}\\
G_{mid} & \text{if} \quad w \in W_{mid}\\
G_{high} & \text{if} \quad w \in W_{high}\\
G_{extcode} & \text{if} \quad w \in W_{extcode}\\
G_{balance} & \text{if} \quad w = \text{\small BALANCE}\\
G_{blockhash} & \text{if} \quad w = \text{\small BLOCKHASH}\\
\end{cases}
\end{equation}
\begin{equation}
w \equiv \begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_{pc}] & \text{if} \quad \boldsymbol{\mu}_{pc} < \lVert I_\mathbf{b} \rVert\\
\text{\small STOP} & \text{otherwise}
\end{cases}
\end{equation}

where:
\begin{equation}
C_{mem}(a) \equiv G_{memory} \cdot a + \Big\lfloor \dfrac{a^2}{512} \Big\rfloor
\end{equation}

with $C_\text{\tiny CALL}$, $C_\text{\tiny SUICIDE}$ and $C_\text{\tiny SSTORE}$ as specified in the appropriate section below. We define the following subsets of instructions:

$W_{zero}$ = \{{\small STOP}, {\small RETURN}\}

$W_{base}$ = \{{\small ADDRESS}, {\small ORIGIN}, {\small CALLER}, {\small CALLVALUE}, {\small CALLDATASIZE}, {\small CODESIZE}, {\small GASPRICE}, {\small COINBASE},\newline \noindent\hspace*{1cm} {\small TIMESTAMP}, {\small NUMBER}, {\small DIFFICULTY}, {\small GASLIMIT}, {\small POP}, {\small PC}, {\small MSIZE}, {\small GAS}\}

$W_{verylow}$ = \{{\small ADD}, {\small SUB}, {\small NOT}, {\small LT}, {\small GT}, {\small SLT}, {\small SGT}, {\small EQ}, {\small ISZERO}, {\small AND}, {\small OR}, {\small XOR}, {\small BYTE}, {\small CALLDATALOAD}, \newline \noindent\hspace*{1cm} {\small MLOAD}, {\small MSTORE}, {\small MSTORE8}, {\small PUSH*}, {\small DUP*}, {\small SWAP*}\}

$W_{low}$ = \{{\small MUL}, {\small DIV}, {\small SDIV}, {\small MOD}, {\small SMOD}, {\small SIGNEXTEND}\}

$W_{mid}$ = \{{\small ADDMOD}, {\small MULMOD}, {\small JUMP}\}

$W_{high}$ = \{{\small JUMPI}\}

$W_{extcode}$ = \{{\small EXTCODESIZE}\}

Note the memory cost component, given as the product of $G_{memory}$ and the maximum of 0 \& the ceiling of the number of words in size that the memory must be over the current number of words, $\boldsymbol{\mu}_i$ in order that all accesses reference valid memory whether for read or write. Such accesses must be for non-zero number of bytes.

Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory to be extended to the beginning of the range. $\boldsymbol{\mu}'_i$ is defined as this new maximum number of words of active memory; special-cases are given where these two are not equal.

Note also that $C_{mem}$ is the memory cost function (the expansion function being the difference between the cost before and after). It is a polynomial, with the higher-order coefficient divided and floored, and thus linear up to 724B of memory used, after which it costs substantially more.

While defining the instruction set, we defined the memory-expansion for range function, $M$, thus:

\begin{equation}
M(s, f, l) \equiv \begin{cases}
s & \text{if} \quad l = 0 \\
\max(s, \ceil{ (f + l) \div 32 }) & \text{otherwise}
\end{cases}
\end{equation}

Another useful function is ``all but one 64th'' function~$L$ defined as:

\begin{equation}
L(n) \equiv n - \lfloor n / 64 \rfloor
\end{equation}

\subsection{Instruction Set}

As previously specified in section \ref{ch:model}, these definitions take place in the final context there. In particular we assume $O$ is the EVM state-progression function and define the terms pertaining to the next cycle's state $(\boldsymbol{\sigma}', \boldsymbol{\mu}')$ such that:
\begin{equation}
O(\boldsymbol{\sigma}, \boldsymbol{\mu}, A, I) \equiv (\boldsymbol{\sigma}', \boldsymbol{\mu}', A', I) \quad \text{with exceptions, as noted}
\end{equation}

Here given are the various exceptions to the state transition rules given in section \ref{ch:model} specified for each instruction, together with the additional instruction-specific definitions of $J$ and $C$. For each instruction, also specified is $\alpha$, the additional items placed on the stack and $\delta$, the items removed from stack, as defined in section \ref{ch:model}.

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{0s: Stop and Arithmetic Operations}} \\
\multicolumn{5}{l}{All arithmetic is modulo $2^{256}$ unless otherwise noted.} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x00 & {\small STOP} & 0 & 0 & Halts execution. \\
\midrule
0x01 & {\small ADD} & 2 & 1 & Addition operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x02 & {\small MUL} & 2 & 1 & Multiplication operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x03 & {\small SUB} & 2 & 1 & Subtraction operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] - \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
0x04 & {\small DIV} & 2 & 1 & Integer division operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \lfloor\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]\rfloor & \text{otherwise}\end{cases}$  \\
\midrule
0x05 & {\small SDIV} & 2 & 1 & Signed integer division operation (truncated). \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ -2^{255} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = -2^{255} \wedge \quad \boldsymbol{\mu}_\mathbf{s}[1] = -1\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]) \lfloor |\boldsymbol{\mu}_\mathbf{s}[0] \div \boldsymbol{\mu}_\mathbf{s}[1]| \rfloor & \text{otherwise}\end{cases}$  \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
&&&& Note the overflow semantic when $-2^{255}$ is negated.\\
\midrule
0x06 & {\small MOD} & 2 & 1 & Modulo remainder operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \boldsymbol{\mu}_\mathbf{s}[0] \bmod \boldsymbol{\mu}_\mathbf{s}[1] & \text{otherwise}\end{cases}$  \\
\midrule
0x07 & {\small SMOD} & 2 & 1 & Signed modulo remainder operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0\\ \mathbf{sgn} (\boldsymbol{\mu}_\mathbf{s}[0]) |\boldsymbol{\mu}_\mathbf{s}[0]| \bmod |\boldsymbol{\mu}_\mathbf{s}[1]| & \text{otherwise}\end{cases}$  \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x08 & {\small ADDMOD} & 3 & 1 & Modulo addition operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}$  \\
&&&& All intermediate calculations of this operation are not subject to the $2^{256}$ modulo. \\
\midrule
0x09 & {\small MULMOD} & 3 & 1 & Modulo multiplication operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}0 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] = 0\\ (\boldsymbol{\mu}_\mathbf{s}[0] \times \boldsymbol{\mu}_\mathbf{s}[1]) \mod \boldsymbol{\mu}_\mathbf{s}[2] & \text{otherwise}\end{cases}$  \\
&&&& All intermediate calculations of this operation are not subject to the $2^{256}$ modulo. \\
\midrule
0x0a & {\small EXP} & 2 & 1 & Exponential operation. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0] ^ {\boldsymbol{\mu}_\mathbf{s}[1] }$ \\
\midrule
0x0b & {\small SIGNEXTEND} & 2 & 1 & Extend length of two's complement signed integer. \\
&&&& $ \forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_t &\text{if} \quad i \leqslant t \quad \text{where} \; t = 256 - 8(\boldsymbol{\mu}_\mathbf{s}[0] + 1) \\ \boldsymbol{\mu}_\mathbf{s}[1]_i &\text{otherwise} \end{cases}$ \\
\multicolumn{5}{l}{$\boldsymbol{\mu}_\mathbf{s}[x]_i$ gives the $i$th bit (counting from zero) of $\boldsymbol{\mu}_\mathbf{s}[x]$} \vspace{5pt} \\
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{10s: Comparison \& Bitwise Logic Operations}} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x10 & {\small LT} & 2 & 1 & Less-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x11 & {\small GT} & 2 & 1 & Greater-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x12 & {\small SLT} & 2 & 1 & Signed less-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] < \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x13 & {\small SGT} & 2 & 1 & Signed greater-than comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& Where all values are treated as two's complement signed 256-bit integers. \\
\midrule
0x14 & {\small EQ} & 2 & 1 & Equality comparision. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = \boldsymbol{\mu}_\mathbf{s}[1] \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x15 & {\small ISZERO} & 1 & 1 & Simple not operator. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] = 0 \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x16 & {\small AND} & 2 & 1 & Bitwise AND operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \wedge \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x17 & {\small OR} & 2 & 1 & Bitwise OR operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \vee \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x18 & {\small XOR} & 2 & 1 & Bitwise XOR operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \boldsymbol{\mu}_\mathbf{s}[0]_i \oplus \boldsymbol{\mu}_\mathbf{s}[1]_i$ \\
\midrule
0x19 & {\small NOT} & 1 & 1 & Bitwise NOT operation. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} 1 & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0]_i = 0 \\ 0 & \text{otherwise} \end{cases}$ \\
\midrule
0x1a & {\small BYTE} & 2 & 1 & Retrieve single byte from word. \\
&&&& $\forall i \in [0..255]: \boldsymbol{\mu}'_\mathbf{s}[0]_i \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[1]_{(i + 8\boldsymbol{\mu}_\mathbf{s}[0])} & \text{if} \quad i < 8 \wedge \boldsymbol{\mu}_\mathbf{s}[0] < 32 \\ 0 & \text{otherwise} \end{cases} $\\
&&&& For Nth byte, we count from the left (i.e. N=0 would be the most significant in big endian). \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{20s: SHA3}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x20 & {\small SHA3} & 2 & 1 & Compute Keccak-256 hash. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \mathtt{\tiny Keccak}(\boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])$ \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{30s: Environmental Information}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x30 & {\small ADDRESS} & 0 & 1 & Get address of currently executing account. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_a$ \\
\midrule
0x31 & {\small BALANCE} & 1 & 1 & Get balance of the given account. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \begin{cases}\boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0]]_b& \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}] \neq \varnothing\\0&\text{otherwise}\end{cases}$ \\
\midrule
0x32 & {\small ORIGIN} & 0 & 1 & Get execution origination address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_o$ \\
&&&& This is the sender of original transaction; it is never an account with non-empty \\
&&&& associated code. \\
\midrule
0x33 & {\small CALLER} & 0 & 1 & Get caller address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_s$ \\
&&&& This is the address of the account that is directly responsible for this execution. \\
\midrule
0x34 & {\small CALLVALUE} & 0 & 1 & Get deposited value by the instruction/transaction responsible for this execution. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_v$ \\
\midrule
0x35 & {\small CALLDATALOAD} & 1 & 1 & Get input data of current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_\mathbf{d}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \quad \text{with} \quad I_\mathbf{d}[x] = 0 \quad \text{if} \quad x \geqslant \lVert I_\mathbf{d} \rVert$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x36 & {\small CALLDATASIZE} & 0 & 1 & Get size of input data in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{d} \rVert$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x37 & {\small CALLDATACOPY} & 3 & 0 & Copy input data in current environment to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv
\begin{cases} I_\mathbf{d}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{d} \rVert \\ 0 & \text{otherwise} \end{cases}$\\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[2])$ \\
&&&& This pertains to the input data passed with the message call instruction or transaction. \\
\midrule
0x38 & {\small CODESIZE} & 0 & 1 & Get size of code running in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert I_\mathbf{b} \rVert$ \\
\midrule
0x39 & {\small CODECOPY} & 3 & 0 & Copy code running in current environment to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[2] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] + i ] \equiv
\begin{cases} I_\mathbf{b}[\boldsymbol{\mu}_\mathbf{s}[1] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] + i < \lVert I_\mathbf{b} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}$\\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\midrule
0x3a & {\small GASPRICE} & 0 & 1 & Get price of gas in current environment. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv I_p$ \\
&&&& This is gas price specified by the originating transaction.\\
\midrule
0x3b & {\small EXTCODESIZE} & 1 & 1 & Get size of an account's code. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \lVert \boldsymbol{\sigma}[\boldsymbol{\mu}_s[0] \mod 2^{160}]_c \rVert$ \\
\midrule
0x3c & {\small EXTCODECOPY} & 4 & 0 & Copy an account's code to memory. \\
&&&& $\forall_{i \in \{ 0 \dots \boldsymbol{\mu}_\mathbf{s}[3] - 1\} } \boldsymbol{\mu}'_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[1] + i ] \equiv
\begin{cases} \mathbf{c}[\boldsymbol{\mu}_\mathbf{s}[2] + i] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] + i < \lVert \mathbf{c} \rVert \\ \text{\small STOP} & \text{otherwise} \end{cases}$\\
&&&& where $\mathbf{c} \equiv \boldsymbol{\sigma}[\boldsymbol{\mu}_s[0] \mod 2^{160}]_c$ \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[1], \boldsymbol{\mu}_\mathbf{s}[3])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{40s: Block Information}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x40 & {\small BLOCKHASH} & 1 & 1 & Get the hash of one of the 256 most recent complete blocks. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv P(I_{H_p}, \boldsymbol{\mu}_\mathbf{s}[0], 0)$ \\
&&&& where $P$ is the hash of a block of a particular number, up to a maximum age.\\
&&&& 0 is left on the stack if the looked for block number is greater than the current block number \\
&&&& or more than 256 blocks behind the current block. \\
&&&& $P(h, n, a) \equiv \begin{cases} 0 & \text{if} \quad n > H_i \vee a = 256 \vee h = 0 \\ h & \text{if} \quad n = H_i \\ P(H_p, n, a + 1) & \text{otherwise} \end{cases}$ \\
&&&& and we assert the header $H$ can be determined as its hash is the parent hash \\
&&&& in the block following it. \\
\midrule
0x41 & {\small COINBASE} & 0 & 1 & Get the block's beneficiary address. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_c$ \\
\midrule
0x42 & {\small TIMESTAMP} & 0 & 1 & Get the block's timestamp. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_s$ \\
\midrule
0x43 & {\small NUMBER} & 0 & 1 & Get the block's number. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_i$ \\
\midrule
0x44 & {\small DIFFICULTY} & 0 & 1 & Get the block's difficulty. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_d$ \\
\midrule
0x45 & {\small GASLIMIT} & 0 & 1 & Get the block's gas limit. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv {I_H}_l$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{50s: Stack, Memory, Storage and Flow Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x50 & {\small POP} & 1 & 0 & Remove item from stack. \\
\midrule
0x51 & {\small MLOAD} & 1 & 1 & Load word from memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{m}[\boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ]$ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })$ \\
&&&& The addition in the calculation of $\boldsymbol{\mu}'_i$ is not subject to the $2^{256}$ modulo. \\
\midrule
0x52 & {\small MSTORE} & 2 & 0 & Save word to memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + 31) ] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 32) \div 32 })$ \\
&&&& The addition in the calculation of $\boldsymbol{\mu}'_i$ is not subject to the $2^{256}$ modulo. \\
\midrule
0x53 & {\small MSTORE8} & 2 & 0 & Save byte to memory. \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv (\boldsymbol{\mu}_\mathbf{s}[1] \bmod 256) $ \\
&&&& $\boldsymbol{\mu}'_i \equiv \max(\boldsymbol{\mu}_i, \ceil{ (\boldsymbol{\mu}_\mathbf{s}[0] + 1) \div 32 })$ \\
&&&& The addition in the calculation of $\boldsymbol{\mu}'_i$ is not subject to the $2^{256}$ modulo. \\
\midrule
0x54 & {\small SLOAD} & 1 & 1 & Load word from storage. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]]$ \\
\midrule
0x55 & {\small SSTORE} & 2 & 0 & Save word to storage. \\
&&&& $\boldsymbol{\sigma}'[I_a]_\mathbf{s}[ \boldsymbol{\mu}_\mathbf{s}[0] ] \equiv \boldsymbol{\mu}_\mathbf{s}[1] $ \\
&&&& $C_{\text{\tiny SSTORE}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{sset} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \; \wedge \; \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]] = 0 \\
G_{sreset} & \text{otherwise}
\end{cases}$ \\
&&&& $A'_{r} \equiv A_{r} + \begin{cases}
R_{sclear} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] = 0 \; \wedge \; \boldsymbol{\sigma}[I_a]_\mathbf{s}[\boldsymbol{\mu}_\mathbf{s}[0]] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
\midrule
0x56 & {\small JUMP} & 1 & 0 & Alter the program counter. \\
&&&& $J_{\text{\tiny JUMP}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{s}[0] $ \\
&&&& This has the effect of writing said value to $\boldsymbol{\mu}_{pc}$. See section \ref{ch:model}. \\
\midrule
0x57 & {\small JUMPI} & 2 & 0 & Conditionally alter the program counter. \\
&&&& $J_{\text{\tiny JUMPI}}(\boldsymbol{\mu}) \equiv \begin{cases} \boldsymbol{\mu}_\mathbf{s}[0] & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[1] \neq 0 \\ \boldsymbol{\mu}_{pc} + 1 & \text{otherwise} \end{cases} $ \\
&&&& This has the effect of writing said value to $\boldsymbol{\mu}_{pc}$. See section \ref{ch:model}. \\
\midrule
0x58 & {\small PC} & 0 & 1 & Get the value of the program counter \textit{prior} to the increment \\
&&&&  corresponding to this instruction. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{pc}$ \\
\midrule
0x59 & {\small MSIZE} & 0 & 1 & Get the size of active memory in bytes. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv 32\boldsymbol{\mu}_{i}$ \\
\midrule
0x5a & {\small GAS} & 0 & 1 & Get the amount of available gas, including the corresponding reduction \\
&&&& for the cost of this instruction. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_{g}$ \\
\midrule
0x5b & {\small JUMPDEST} & 0 & 0 & Mark a valid destination for jumps. \\
&&&& This operation has no effect on machine state during execution. \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{60s \& 70s: Push Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x60 & {\small PUSH1} & 0 & 1 & Place 1 byte item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv c(\boldsymbol{\mu}_{pc} + 1)$ \\
&&&& $\text{where} \quad c(x) \equiv \begin{cases} I_\mathbf{b}[x] & \text{if} \quad x < \lVert I_\mathbf{b} \rVert \\ 0 & \text{otherwise} \end{cases}$ \\
&&&& The bytes are read in line from the program code's bytes array. \\
&&&& The function $c$ ensures the bytes default to zero if they extend past the limits.\\
&&&& The byte is right-aligned (takes the lowest significant place in big endian). \\
\midrule
0x61 & {\small PUSH2} & 0 & 1 & Place 2-byte item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big( (\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 2) \big)$ \\
&&&& with $\boldsymbol{c}(\boldsymbol{x}) \equiv (c(\boldsymbol{x}_0), ..., c(\boldsymbol{x}_{\lVert x \rVert -1})) $ with $c$ as defined as above. \\
&&&& The bytes are right-aligned (takes the lowest significant place in big endian). \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x7f & {\small PUSH32} & 0 & 1 & Place 32-byte (full word) item on stack. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{c}\big((\boldsymbol{\mu}_{pc} + 1) \dots (\boldsymbol{\mu}_{pc} + 32) \big)$ \\
&&&& where $\boldsymbol{c}$ is defined as above. \\
&&&& The bytes are right-aligned (takes the lowest significant place in big endian). \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{80s: Duplication Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x80 & {\small DUP1} & 1 & 2 & Duplicate 1st stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
0x81 & {\small DUP2} & 2 & 3 & Duplicate 2nd stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x8f & {\small DUP16} & 16 & 17 & Duplicate 16th stack item. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[15]$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{90s: Exchange Operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0x90 & {\small SWAP1} & 2 & 2 & Exchange 1st and 2nd stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[1]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[1] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
0x91 & {\small SWAP2} & 3 & 3 & Exchange 1st and 3rd stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[2]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[2] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0x9f & {\small SWAP16} & 17 & 17 & Exchange 1st and 17th stack items. \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv \boldsymbol{\mu}_\mathbf{s}[16]$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[16] \equiv \boldsymbol{\mu}_\mathbf{s}[0]$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{a0s: Logging Operations}} \vspace{5pt} \\
\multicolumn{5}{l}{For all logging operations, the state change is to append an additional log entry on to the substate's log series:}\\
\multicolumn{5}{l}{$A'_\mathbf{l} \equiv A_\mathbf{l} \cdot (I_a, \mathbf{t}, \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots (\boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1) ])$}\\
\multicolumn{5}{l}{The entry's topic series, $\mathbf{t}$, differs accordingly:}\vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0xa0 & {\small LOG0} & 2 & 0 & Append log record with no topics. \\
&&&& $\mathbf{t} \equiv ()$ \\
\midrule
0xa1 & {\small LOG1} & 3 & 0 & Append log record with one topic. \\
&&&& $\mathbf{t} \equiv (\boldsymbol{\mu}_\mathbf{s}[2])$ \\
\midrule
\multicolumn{1}{c}{\vdots} & \multicolumn{1}{c}{\vdots} & \vdots & \vdots & \multicolumn{1}{c}{\vdots} \\
\midrule
0xa4 & {\small LOG4} & 6 & 0 & Append log record with four topics. \\
&&&& $\mathbf{t} \equiv (\boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[3], \boldsymbol{\mu}_\mathbf{s}[4], \boldsymbol{\mu}_\mathbf{s}[5])$ \\
\bottomrule
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\toprule
\multicolumn{5}{c}{\textbf{f0s: System operations}} \vspace{5pt} \\
\textbf{Value} & \textbf{Mnemonic} & $\delta$ & $\alpha$ & \textbf{Description} \vspace{5pt} \\
0xf0 & {\small CREATE} & 3 & 1 & Create a new account with associated code. \\
&&&& $\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[1] \dots (\boldsymbol{\mu}_\mathbf{s}[1] + \boldsymbol{\mu}_\mathbf{s}[2] - 1) ]$ \\
&&&& $(\boldsymbol{\sigma}', \boldsymbol{\mu}'_g, A^+) \equiv \begin{cases}\Lambda(\boldsymbol{\sigma}^*, I_a, I_o, L(\boldsymbol{\mu}_g), I_p, \boldsymbol{\mu}_\mathbf{s}[0], \mathbf{i}, I_e + 1) & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[0] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024\\ \big(\boldsymbol{\sigma}, \boldsymbol{\mu}_g, \varnothing\big) & \text{otherwise} \end{cases}$ \\
&&&& $\boldsymbol{\sigma}^* \equiv \boldsymbol{\sigma} \quad \text{except} \quad \boldsymbol{\sigma}^*[I_a]_n = \boldsymbol{\sigma}[I_a]_n + 1$ \\
&&&& $A' \equiv A \Cup A^+$ which implies: $A'_\mathbf{s} \equiv A_\mathbf{s} \cup A^+_\mathbf{s} \quad \wedge \quad A'_\mathbf{l} \equiv A_\mathbf{l} \cdot A^+_\mathbf{l} \quad \wedge \quad A'_\mathbf{r} \equiv A_\mathbf{r} + A^+_\mathbf{r}$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\
&&&& where $x=0$ if the code execution for this operation failed due to an exceptional halting \\
&&&& $Z(\boldsymbol{\sigma}^*, \boldsymbol{\mu}, I) = \top$ or $I_e = 1024$ \\
&&&& (the maximum call depth limit is reached) or $\boldsymbol{\mu}_\mathbf{s}[0] > \boldsymbol{\sigma}[I_a]_b$ (balance of the caller is too \\
&&&& low to fulfil the value transfer); and otherwise $x=A(I_a, \boldsymbol{\sigma}[I_a]_n)$, the address of the newly \\
&&&& created account, otherwise. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[1], \boldsymbol{\mu}_\mathbf{s}[2])$ \\
&&&& Thus the operand order is: value, input offset, input size. \\
\midrule
0xf1 & {\small CALL} & 7 & 1 & Message-call into an account. \\
&&&& $\mathbf{i} \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[3] \dots (\boldsymbol{\mu}_\mathbf{s}[3] + \boldsymbol{\mu}_\mathbf{s}[4] - 1) ]$ \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}, I_a, I_o, t, t,\\ \quad C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}), I_p, \boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge \\ \quad\quad I_e < 1024\end{array}\\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& $n \equiv \min(\{ \boldsymbol{\mu}_\mathbf{s}[6], |\mathbf{o}|\})$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[5] \dots (\boldsymbol{\mu}_\mathbf{s}[5] + n - 1) ] = \mathbf{o}[0 \dots (n - 1)]$ \\
&&&& $\boldsymbol{\mu}'_g \equiv \boldsymbol{\mu}_g + g'$ \\
&&&& $\boldsymbol{\mu}'_\mathbf{s}[0] \equiv x$ \\
&&&& $A' \equiv A \Cup A^+$ \\
&&&& $t \equiv \boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}$ \\
&&&& where $x=0$ if the code execution for this operation failed due to an exceptional halting \\
&&&& $Z(\boldsymbol{\sigma}, \boldsymbol{\mu}, I) = \top$ or if  \\
&&&& $\boldsymbol{\mu}_\mathbf{s}[2] > \boldsymbol{\sigma}[I_a]_b$ (not enough funds) or $I_e = 1024$ (call depth limit reached); $x=1$ \\
&&&& otherwise. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[3], \boldsymbol{\mu}_\mathbf{s}[4]), \boldsymbol{\mu}_\mathbf{s}[5], \boldsymbol{\mu}_\mathbf{s}[6])$ \\
&&&& Thus the operand order is: gas, to, value, in offset, in size, out offset, out size. \\
&&&& $C_{\text{\tiny CALL}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) + C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$ \\
&&&& $C_{\text{\tiny CALLGAS}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv  \begin{cases}
C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) + G_{callstipend} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \neq 0 \\
C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny GASCAP}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
\min\{ L(\boldsymbol{\mu}_g - C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu})), \boldsymbol{\mu}_{\mathbf{s}}[0] \} & \text{if} \quad \boldsymbol{\mu}_g \ge C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu})\\
\boldsymbol{\mu}_{\mathbf{s}}[0] & \text{otherwise}
\end{cases}$\\
&&&& $C_{\text{\tiny EXTRA}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv G_{call} + C_{\text{\tiny XFER}}(\boldsymbol{\mu}) + C_{\text{\tiny NEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu})$\\
&&&& $C_{\text{\tiny XFER}}(\boldsymbol{\mu}) \equiv \begin{cases}
G_{callvalue} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \neq 0 \\
0 & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny NEW}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv \begin{cases}
G_{newaccount} & \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}] = \varnothing \\
0 & \text{otherwise}
\end{cases}$ \\
\midrule
0xf2 & {\small CALLCODE} & 7 & 1 & Message-call into this account with an alternative account's code. \\
&&&& Exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_a, I_o, I_a, t,\\\quad C_{\text{\tiny CALLGAS}}(\boldsymbol{\mu}), I_p, \boldsymbol{\mu}_\mathbf{s}[2], \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \begin{array}{l}\text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\\ \quad\quad{}I_e < 1024\end{array} \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the change in the fourth parameter to the call $\Theta$ from the 2nd stack value $\boldsymbol{\mu}_\mathbf{s}[1]$\\
&&&& (as in {\small CALL}) to the present address $I_a$. This means that the recipient is in fact the\\
&&&& same account as at present, simply that the code is overwritten.\\
\midrule
0xf3 & {\small RETURN} & 2 & 0 & Halt execution returning output data. \\
&&&& $H_{\text{\tiny RETURN}}(\boldsymbol{\mu}) \equiv \boldsymbol{\mu}_\mathbf{m}[ \boldsymbol{\mu}_\mathbf{s}[0] \dots ( \boldsymbol{\mu}_\mathbf{s}[0] + \boldsymbol{\mu}_\mathbf{s}[1] - 1 ) ]$ \\
&&&& This has the effect of halting the execution at this point with output defined.\\
&&&& See section \ref{ch:model}. \\
&&&& $\boldsymbol{\mu}'_i \equiv M(\boldsymbol{\mu}_i, \boldsymbol{\mu}_\mathbf{s}[0], \boldsymbol{\mu}_\mathbf{s}[1])$ \\
\end{tabular*}

\begin{tabular*}{\columnwidth}[h]{rlrrl}
\midrule
0xf4 & {\small DELEGATECALL} & 6 & 1 & Message-call into this account with an alternative account's code, but persisting\\
&&&& the current values for {\it sender} and {\it value}. \\
<<<<<<< HEAD
&&&& Exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_s, I_o, I_a, t,\\\quad \boldsymbol{\mu}_\mathbf{s}[0], I_p, 0, \boldsymbol{\mu}_\mathbf{s}[2], \mathbf{i}, I_e + 1)\end{array} & \text{if} \quad \boldsymbol{\mu}_\mathbf{s}[2] \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024 \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the changes (in addition to that of the fourth parameter) to the second and eighth\\
&&&& parameters to the call $\Theta$.\\
=======
&&&& Compared with {\small CALL}, {\small DELEGATECALL} takes one fewer arguments.  The omitted\\
&&&& argument is $\boldsymbol{\mu}_\mathbf{s}[2]$. As a result, $\boldsymbol{\mu}_\mathbf{s}[3]$, $\boldsymbol{\mu}_\mathbf{s}[4]$, $\boldsymbol{\mu}_\mathbf{s}[5]$ and $\boldsymbol{\mu}_\mathbf{s}[6]$ in the definition of {\small CALL} \\
&&&& should respectively be replaced with $\boldsymbol{\mu}_\mathbf{s}[2]$, $\boldsymbol{\mu}_\mathbf{s}[3]$, $\boldsymbol{\mu}_\mathbf{s}[4]$ and $\boldsymbol{\mu}_\mathbf{s}[5]$. \\
&&&& Otherwise exactly equivalent to {\small CALL} except: \\
&&&& $(\boldsymbol{\sigma}', g', A^+, \mathbf{o}) \equiv \begin{cases}\begin{array}{l}\Theta(\boldsymbol{\sigma}^*, I_s, I_o, I_a, t,\\\quad \boldsymbol{\mu}_\mathbf{s}[0], I_p, 0, I_v, \mathbf{i}, I_e + 1)\end{array} & \text{if} \quad I_v \leqslant \boldsymbol{\sigma}[I_a]_b \;\wedge\; I_e < 1024 \\ (\boldsymbol{\sigma}, g, \varnothing, \mathbf{o}) & \text{otherwise} \end{cases}$ \\
&&&& Note the changes (in addition to that of the fourth parameter) to the second \\
&&&& and ninth parameters to the call $\Theta$.\\
>>>>>>> upstream/master
&&&& This means that the recipient is in fact the same account as at present, simply\\
&&&& that the code is overwritten {\it and} the context is almost entirely identical.\\
\midrule
0xff & {\small SUICIDE} & 1 & 0 & Halt execution and register account for later deletion. \\
&&&& $A'_\mathbf{s} \equiv A_\mathbf{s} \cup \{ I_a \}$ \\
&&&& $\boldsymbol{\sigma}'[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_b \equiv \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[0] \mod 2^{160}]_b + \boldsymbol{\sigma}[I_a]_b$ \\
&&&& $\boldsymbol{\sigma}'[I_a]_b \equiv 0$ \\
&&&& $A'_{r} \equiv A_{r} + \begin{cases}
R_{suicide} & \text{if} \quad I_a \notin A_\mathbf{s} \\
0 & \text{otherwise}
\end{cases}$ \\
&&&& $C_{\text{\tiny SUICIDE}}(\boldsymbol{\sigma}, \boldsymbol{\mu}) \equiv G_{suicide} + \begin{cases}
G_{newaccount} & \text{if} \quad \boldsymbol{\sigma}[\boldsymbol{\mu}_\mathbf{s}[1] \mod 2^{160}] = \varnothing \\
0 & \text{otherwise}
\end{cases}$ \\
\bottomrule
\end{tabular*}

%\section{Low-level Lisp-like Language}\label{app:lll}
%The Low-level Lisp-like Language is a language created in order to efficiently author low-level programs (contracts) without having to resort to EVM-Assembly.

\section{Genesis Block}\label{app:genesis}

The genesis block is 15 items, and is specified thus:
\begin{equation}
\big( \big( 0_{256}, \mathtt{\tiny KEC}\big(\mathtt{\tiny RLP}\big( () \big)\big), 0_{160}, stateRoot, 0, 0, 0_{2048}, 2^{17}, 0, 0, 3141592, time, 0, 0_{256},  \mathtt{\tiny KEC}\big( (42) \big) \big), (), () \big)
\end{equation}

Where $0_{256}$ refers to the parent hash, a 256-bit hash which is all zeroes; $0_{160}$ refers to the beneficiary address, a 160-bit hash which is all zeroes; $0_{2048}$ refers to the log bloom, 2048-bit of all zeros; $2^{17}$ refers to the difficulty; the transaction trie root, receipt trie root, gas used, block number and extradata are both $0$, being equivalent to the empty byte array. The sequences of both ommers and transactions are empty and represented by $()$. $\mathtt{\tiny KEC}\big( (42) \big)$ refers to the Keccak hash of a byte array of length one whose first and only byte is of value 42, used for the nonce. $\mathtt{\tiny KEC}\big(\mathtt{\tiny RLP}\big( () \big)\big)$ value refers to the hash of the ommer lists in RLP, both empty lists.

The proof-of-concept series include a development premine, making the state root hash some value $stateRoot$. Also $time$ will be set to the intial timestamp of the genesis block. The latest documentation should be consulted for those values.

\section{Ethash}\label{app:ethash}
\subsection{Definitions}
We employ the following definitions:

\begin{tabular*}{\columnwidth}[h]{lrl}
\toprule
Name & Value & Description \\
\midrule
$J_{wordbytes}$ & 4  & Bytes in word. \\
$J_{datasetinit}$ & $2^{30}$ & Bytes in dataset at genesis. \\
$J_{datasetgrowth}$ & $2^{23}$ & Dataset growth per epoch. \\
$J_{cacheinit}$ & $2^{24}$ & Bytes in cache at genesis. \\
$J_{cachegrowth}$ & $2^{17}$ & Cache growth per epoch. \\
$J_{epoch}$ & 30000 & Blocks per epoch. \\
$J_{mixbytes}$ & 128 & mix length in bytes. \\
$J_{hashbytes}$ & 64 & Hash length in bytes. \\
$J_{parents}$ & 256 & Number of parents of each dataset element. \\
$J_{cacherounds}$ & 3 & Number of rounds in cache production. \\
$J_{accesses}$ & 64 & Number of accesses in hashimoto loop. \\
\bottomrule
\end{tabular*}

\subsection{Size of dataset and cache}
The size for Ethash's cache $\mathbf{c} \in \mathbb{B}$  and dataset $\mathbf{d} \in \mathbb{B}$ depend on the epoch, which in turn depends on the block number.
\begin{equation}
 E_{epoch}(H_i) = \left\lfloor\frac{H_i}{J_{epoch}}\right\rfloor
\end{equation}
The size of the dataset growth by $J_{datasetgrowth}$ bytes, and the size of the cache by $J_{cachegrowth}$ bytes, every epoch. In order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a multiple of $J_{mixbytes}$, for the dataset, and $J_{hashbytes}$ for the cache.
Let $d_{size} = \lVert \mathbf{d} \rVert$ be the size of the dataset. Which is calculated using
\begin{equation}
 d_{size} = E_{prime}(J_{datasetinit} + J_{datasetgrowth} \cdot E_{epoch} - J_{mixbytes}, J_{mixbytes})
\end{equation}
The size of the cache, $c_{size}$, is calculated using
\begin{equation}
 c_{size} = E_{prime}(J_{cacheinit} + J_{cachegrowth} \cdot E_{epoch} - J_{hashbytes}, J_{hashbytes})
\end{equation}
\begin{equation}
 E_{prime}(x, y) = \begin{cases}
x & \text{if} \quad x / y \in \mathbb{P} \\
E_{prime}(x - 1 \cdot y, y) & \text{otherwise}
\end{cases}
\end{equation}
\subsection{Dataset generation}
In order the generate the dataset we need the cache $\mathbf{c}$, which is an array of bytes. It depends on the cache size  $c_{size}$ and the seed hash $\mathbf{s} \in \mathbb{B}_{32}$.
\subsubsection{Seed hash}
The seed hash is different for every epoch. For the first epoch it is the Keccak-256 hash of a series of 32 bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:
\begin{equation}
 \mathbf{s} = C_{seedhash}(H_i)
\end{equation}
\begin{equation}
 C_{seedhash}(H_i) = \begin{cases}
\texttt{KEC}(\mathbf{0}_{32}) & \text{if} \quad E_{epoch}(H_i) = 0 \quad  \\
\texttt{KEC}(C_{seedhash}(H_i - J_{epoch})) & \text{otherwise}
\end{cases}
\end{equation}
With $\mathbf{0}_{32}$ being 32 bytes of zeros.

\subsubsection{Cache}
The cache production process involves using the seed hash to first sequentially filling up $c_{size}$ bytes of memory, then performing $J_{cacherounds}$ passes of the RandMemoHash algorithm created by \cite{lerner2014randmemohash}. The intial cache $\mathbf{c'}$, being an array of arrays of single bytes, will be constructed as follows.

We define the array $\mathbf{c}_{i}$, consisting of 64 single bytes,  as the $i$th element of the intial cache:
\begin{equation}
 \mathbf{c}_{i} = \begin{cases}
\texttt{KEC512}(\mathbf{s}) & \text{if} \quad i = 0 \quad  \\
\texttt{KEC512}(\mathbf{c}_{i-1}) & \text{otherwise}
\end{cases}
\end{equation}
Therefore $ \mathbf{c'}$ can be defined as
\begin{equation}
 \mathbf{c'}[i] = \mathbf{c}_{i} \quad \forall \quad i < n
\end{equation}
\begin{equation}
 n = \left\lfloor\frac{c_{size}}{J_{hashbytes}}\right\rfloor
\end{equation}
The cache is calculated by performing $J_{cacherounds}$ rounds of the RandMemoHash algorithm to the inital cache $\mathbf{c'}$:
\begin{equation}
 \mathbf{c} = E_{cacherounds}(\mathbf{c'}, J_{cacherounds})
\end{equation}
\begin{equation}
 E_{cacherounds}(\mathbf{x}, y) = \begin{cases}
\mathbf{x} & \text{if} \quad y = 0 \quad  \\
E_\text{\tiny RMH}(\mathbf{x}) & \text{if} \quad y = 1 \quad  \\
E_{cacherounds}(E_\text{\tiny RMH}(\mathbf{x}), y -1 ) & \text{otherwise}
\end{cases}
\end{equation}
Where a single round modifies each subset of the cache as follows:
\begin{equation}
 E_\text{\tiny RMH}(\mathbf{x}) = \big( E_{rmh}(\mathbf{x}, 0), E_{rmh}(\mathbf{x}, 1), ... , E_{rmh}(\mathbf{x}, n - 1) \big)
\end{equation}
\begin{multline}
  E_{rmh}(\mathbf{x}, i) = \texttt{KEC512}(\mathbf{x'}[(i - 1 + n) \mod n] \oplus \mathbf{x'}[\mathbf{x'}[i][0] \mod n]) \\
  \text{with} \quad \mathbf{x'} = \mathbf{x} \quad \text{except} \quad \mathbf{x'}[j] = E_{rmh}(\mathbf{x}, j) \quad \forall \quad j < i
\end{multline}

\subsubsection{Full dataset calculation} \label{dataset}
Essentially, we combine data from $J_{parents}$ pseudorandomly selected cache nodes, and hash that to compute the dataset. The entire dataset is then generated by a number of items, each $J_{hashbytes}$ bytes in size:
\begin{equation}
 \mathbf{d}[i] = E_{datasetitem}(\mathbf{c}, i) \quad \forall \quad i < \left\lfloor\frac{d_{size}}{J_{hashbytes}}\right\rfloor
\end{equation}
In order to calculate the single item we use an algorithm inspired by the FNV hash (\cite{FowlerNollVo1991FNVHash}) in some cases as a non-associative substitute for XOR.
\begin{equation}
 E_\text{\tiny FNV}(\mathbf{x}, \mathbf{y}) = (\mathbf{x} \cdot (\mathrm{0x01000193} \oplus \mathbf{y})) \mod 2^{32}
\end{equation}
The single item of the dataset can now be calculated as:
\begin{equation}
 E_{datasetitem}(\mathbf{c}, i) = E_{parents}(\mathbf{c}, i, -1, \varnothing)
\end{equation}
\begin{equation}
  E_{parents}(\mathbf{c}, i, p, \mathbf{m}) = \begin{cases}
E_{parents}(\mathbf{c}, i, p +1, E_{mix}(\mathbf{m}, \mathbf{c}, i, p + 1)) & \text{if} \quad p < J_{parents} -2 \\
E_{mix}(\mathbf{m}, \mathbf{c}, i, p + 1) & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
 E_{mix}(\mathbf{m}, \mathbf{c}, i, p) = \begin{cases}
\texttt{KEC512}(\mathbf{c}[i \mod c_{size}] \oplus i) & \text{if} \quad p = 0 \\
E_\text{\tiny FNV}\big(\mathbf{m}, \mathbf{c}[E_\text{\tiny FNV}(i \oplus p, \mathbf{m}[p \mod \lfloor J_{hashbytes} / J_{wordbytes} \rfloor]) \mod c_{size}] \big) & \text{otherwise}
\end{cases}
\end{equation}

\subsection{Proof-of-work function}
Essentially, we maintain a "mix" $J_{mixbytes}$ bytes wide, and repeatedly sequentially fetch $J_{mixbytes}$ bytes from the full dataset and use the $E_\text{\tiny FNV}$ function to combine it with the mix. $J_{mixbytes}$ bytes of sequential access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside buffer misses which ASICs would theoretically be able to avoid.

If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application of \texttt{KEC} at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small amount of work was done; this quick outer PoW verification can be used for anti-DDoS purposes. It also serves to provide statistical assurance that the result is an unbiased, 256 bit number.

The PoW-function returns an array with the compressed mix as its first item and the Keccak-256 hash of the concatenation of the compressed mix with the seed hash as the second item:
\begin{equation}
 \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d}) = \lbrace \mathbf{m}_c(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n, \mathbf{d}), \texttt{KEC}(\mathbf{s}_h(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n) + \mathbf{m}_c(\mathtt{\small KEC}(\mathtt{\small RLP}(L_H(H_{\hcancel{n}}))), H_n, \mathbf{d})) \rbrace
\end{equation}
With $H_{\hcancel{n}}$ being the hash of the header without the nonce. The compressed mix $\mathbf{m}_c$ is obtained as follows:
\begin{equation}
 \mathbf{m}_c(\mathbf{h}, \mathbf{n}, \mathbf{d}) = E_{compress}(E_{accesses}(\mathbf{d}, \sum_{i = 0}^{n_{mix}} \mathbf{s}_h(\mathbf{h}, \mathbf{n}), \mathbf{s}_h(\mathbf{h}, \mathbf{n}), -1), -4)
\end{equation}

The seed hash being:
\begin{equation}
 \mathbf{s}_h(\mathbf{h}, \mathbf{n}) = \texttt{KEC512}(\mathbf{h} + E_{revert}(\mathbf{n}))
\end{equation}
$E_{revert}(\mathbf{n})$ returns the reverted bytes sequence of the nonce $\mathbf{n}$:
\begin{equation}
 E_{revert}(\mathbf{n})[i] = \mathbf{n}[\lVert \mathbf{n} \rVert -i]
\end{equation}
We note that the ``$+$''-operator between two byte sequences results in the concatenation of both sequences.

The dataset $\mathbf{d}$ is obtained as described in section \ref{dataset}.

The number of replicated sequences in the mix is:
\begin{equation}
 n_{mix} =  \left\lfloor\frac{J_{mixbytes}}{J_{hashbytes}}\right\rfloor
\end{equation}
In order to add random dataset nodes to the mix, the $E_{accesses}$ function is used:
\begin{equation}
 E_{accesses}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = \begin{cases}
E_{mixdataset}(\mathbf{d}, \mathbf{m},  \mathbf{s}, i) & \text{if} \quad i = J_{accesses} -2 \\
E_{accesses}(E_{mixdataset}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i), \mathbf{s}, i + 1) & \text{otherwise}
\end{cases}
\end{equation}
\begin{equation}
 E_{mixdataset}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i) = E_\text{\tiny FNV}(\mathbf{m}, E_{newdata}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)
\end{equation}
$E_{newdata}$ returns an array with $n_{mix}$ elements:
\begin{equation}
 E_{newdata}(\mathbf{d}, \mathbf{m}, \mathbf{s}, i)[j] = \mathbf{d}[E_\text{\tiny FNV}(i \oplus \mathbf{s}[0], \mathbf{m}[i \mod \left\lfloor\frac{J_{mixbytes}}{J_{wordbytes}}\right\rfloor]) \mod \left\lfloor\frac{d_{size} / J_{hashbytes}}{n_{mix}}\right\rfloor \cdot n_{mix} + j] \quad \forall \quad j < n_{mix}
\end{equation}
The mix is compressed as follows:
\begin{equation}
 E_{compress}(\mathbf{m}, i) = \begin{cases}
\mathbf{m} & \text{if} \quad i \geqslant \lVert \mathbf{m} \rVert - 8 \\
E_{compress}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(E_\text{\tiny FNV}(\mathbf{m}[i + 4], \mathbf{m}[i + 5]), \mathbf{m}[i + 6]), \mathbf{m}[i + 7]), i + 8) & \text{otherwise}
\end{cases}
\end{equation}

\end{document}
